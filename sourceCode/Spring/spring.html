<!DOCTYPE html>
<html>
<head>
<title>spring</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<base href=''/>
</head>
<body>
<h1>Spring源码笔记</h1>
<h2>1.容器的基本实现</h2>
<h3>1.1.首先来看一个最简单的例子</h3>
<pre><code>@Test
public void Test() {
    BeanFactory bf = new XmlBeanFactory(&quot;xxx.xml&quot;);
    User user = (User)bf.getBean(&quot;user&quot;);
    Sting name = user.getName();
}
</code></pre>

<h4>1.1.1分析：</h4>
<ol>
<li>首先从xml文件中读取配置</li>
<li>使用反射创建User对象</li>
<li>调用User实例的getName()方法</li>
</ol>
<h4>1.1.2想完成上述功能至少需要三个类:</h4>
<ol>
<li>读取配置文件的类Reader</li>
<li>创建实例的类</li>
<li>把整个流程串联到一起的类</li>
</ol>
<h3>1.2.核心类的介绍</h3>
<h4>1.2.1 DefaultListableBeanFactory</h4>
<h6>它是注册和加载bean的默认实现，和它的子类XmlBeanFactory的区别就是XmlBeanFactory使用的是自定义的xml读取器---XmlBeanDefinitionReader，实现了个性化的读取。DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory和BeanDefinitionRegistry</h6>
<p><img src="./img/1.png" /></p>
<h4>1.2.2XmlBeanDefinitionReader</h4>
<h6>这个类就是XmlBeanFactory用来读取xml配置文件的。继承了AbstractBeanDefinitionReader，使用ResourceLoader将资源路径转换成Resource文件，然后在通过DocumentLoader把Resource文件转换成Document文件，这个是一个接口，源码中是new了一个默认实现类。然后通过BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader解析Document。</h6>
<h4>1.3容器的基础XmlBeanFactory</h4>
<p><img src="./img/2.png" /></p>
<h6>1.3.1配置文件的封装</h6>
<p><img src="./img/3.png" /></p>
<h6>在XmlBeanFactory的构造函数中进行了资源的加载，在真正进行资源加载的之前，调用了父类的构造方法，一直追下去会发现AbstractAutowireCapableBeanFactory这个类的构造方法中使用了ignoreDependencyInterface方法，这个方法的作用是自动装配忽略指定类，为的是，例如a属性依赖b属性时，a初始化了，b还没有初始化，就会自动初始化b。当b继承了BeanNameAware就不会被自动装配</h6>
<p><img src="./img/4.png" /></p>
<h6>1.3.2加载Bean</h6>
<p><img src="./img/5.png" /></p>
<h6>doLoadBeanDefinitions()方法主要是做了三件事，第一是获取xml的校验模式，第二加载xml文件，得到Document对象，第三是根据返回的Document信息注册Bean信息。</h6>
<ol>
<li>获取检验模式：如果手动指定了就使用手动指定的，没有指定则使用自动的，自动的话会使用专门检验xml的类XmlValidationModeDetector来处理，这个类通过验证有没有DOCTYPE，来区分DTD还是XSD。</li>
<li>加载xml文件： 调用的是DocumentLoader接口的实现类DefaultDocumentLoader，其中有一个参数是entityResolver。这个接口接收publicId，systemId，返回InputSource对象。查看它的实现类DelegatingEntityResolver。不同的验证模式使用不同的解析器，解析dtd是BeansDtdResolver这个类干的，它截取systemId最后的xx.dtd，然后在当前路径下寻找。 解析xsd则是用PluggableSchemaResolver，它是默认到META-INF/Spring.schemas文件中找systemId对应的xsd文件。</li>
<li><strong>解析以及注册BeanDefinition</strong>：首先会解析profile属性，然后在DefaultBeanDefinitionDocumentReader类中解析前后都由两个方法执行preProcessXml，postProcessXml，但是两个方法中都没有代码。在面向对象设计方法学中常说的一句话：<strong>一个类要么是面向继承设计的，要么就用final修饰。</strong>这两个方法是为子类设计的，是模板方法模式。继承自DefaultBeanDefinitionDocumentReader的类想要在解析前后做处理，只需要重写这两个方法即可。继续深入会发现处理xml中bean标签时会有所差距，默认的标签就使用默认的处理，自定义的就需要另外处理，如下图黑色代码部分所示。
<img src="./img/6.png" /></li>
</ol>
<h3>1.4 默认标签的解析</h3>
<h6>对四种(import, alias, bean, beans)默认标签做了不同的解析</h6>
<h4>1.4.1 bean标签的解析及注册</h4>
<ol>
<li><strong>解析BeanDefinition：</strong> 就是从元素中解析各个属性如class，id等，然后封装到AbstractBeanDefinition中返回。</li>
<li>
<strong>AbstractBeanDefinition的属性：</strong> 这个类中包含了bean标签的很多属性，基本都有
<ol>
<li>ChildBeanDefinition： 标签里嵌套标签就用这个存</li>
<li>GenericBeanDefinition： 没有父标签，也没有子标签就用这个存</li>
<li>RootBeanDefinition： 有子标签用这个存</li>
</ol>
</li>
<li><strong>解析默认标签中的自定义标签元素：</strong></li>
<li>
<strong>注册解析的BeanDefinition：</strong>
<ol>
<li>
通过beanName注册BeanDefinition
<ol>
<li>校验methodOverride属性</li>
<li>注册bean，就是往ConcurrentHashMap存数据</li>
<li>记录beanName</li>
<li>重置缓存信息</li>
</ol>
</li>
<li>
通过别名注册BeanDefinition
<ol>
<li>名称相同就不用处理， 把原来的alias移除掉</li>
<li>如果alias不允许被覆盖就抛出异常</li>
<li>循环检查alias，当a-&gt;b 存在时，再次出现a-&gt;c-&gt;b就会抛出异常</li>
<li>注册alias</li>
</ol>
</li>
</ol>
</li>
<li><strong>通知监听器解析及注册完成：</strong>当需要在注册BeanDefinition事件进行监听时可以通过注册监听器的方法将处理逻辑写入监听器，spring没有做逻辑处理。</li>
</ol>
<h4>1.4.2 alias标签的解析</h4>
<h6>跟1.4.1中第4.2里说的差不多</h6>
<p><img src="./img/7.png" /></p>
<pre><code>protected void processAliasRegistration(Element ele) {
    // 获取beanName
    String name = ele.getAttribute(NAME_ATTRIBUTE);
    // 获取别名
    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
    boolean valid = true;
    if (!StringUtils.hasText(name)) {
        getReaderContext().error(&quot;Name must not be empty&quot;, ele);
        valid = false;
    }
    if (!StringUtils.hasText(alias)) {
        getReaderContext().error(&quot;Alias must not be empty&quot;, ele);
        valid = false;
    }
    if (valid) {
        try {
            // 注册alias
            getReaderContext().getRegistry().registerAlias(name, alias);
        }
        catch (Exception ex) {
            getReaderContext().error(&quot;Failed to register alias '&quot; + alias +
                    &quot;' for bean with name '&quot; + name + &quot;'&quot;, ele, ex);
        }
        // 通知监听器注册完成了
        getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
    }
}
</code></pre>

<h4>1.4.3 import标签的解析</h4>
<ol>
<li>获取resource属性所表示的路径</li>
<li>解析系统属性：例如“ $ {user.dir}”</li>
<li>判断是绝对路径还是相对路径</li>
<li>如果是绝对路径就递归调用bean的解析过程</li>
<li>如果是相对路径就计算出绝对路径再进行解析</li>
<li>通知监听器解析完成</li>
</ol>
<h1></h1>
<pre><code>protected void importBeanDefinitionResource(Element ele) {
    // 获取resource属性
    String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
    // 如果不存在就不做任何处理
    if (!StringUtils.hasText(location)) {
        getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);
        return;
    }

    // Resolve system properties: e.g. &quot;${user.dir}&quot;  解析系统属性：例如“ $ {user.dir}”
    location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

    Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4);

    // Discover whether the location is an absolute or relative URI 判断是绝对路径还是相对路径
    boolean absoluteLocation = false;
    try {
        absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
    }
    catch (URISyntaxException ex) {
        // cannot convert to an URI, considering the location relative//考虑到相对位置，因此无法转换为URI
        // unless it is the well-known Spring prefix &quot;classpath*:&quot; //除非它是众所周知的Spring前缀“ classpath *：”
    }

    // Absolute or relative? 绝对还是相对？
    if (absoluteLocation) {
        try {
            // 如果是绝对路径就直接根据地址加载配置文件
            int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);
            }
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(
                    &quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex);
        }
    }
    else {
        // No URL -&gt; considering resource location as relative to the current file. 没有URL-&gt;考虑相对于当前文件的资源位置。
        // 如果是相对地址就根据相对地址算出绝对地址
        try {
            int importCount;
            //Resource存在多个子实现类,如VfsResource, FilesystemResource等,
            // 而每个resource的createRelative方式实现都不一样,所以这里先使用子类的方法尝试解析
            Resource relativeResource = getReaderContext().getResource().createRelative(location);
            if (relativeResource.exists()) {
                importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
                actualResources.add(relativeResource);
            }
            else {
                // 如果解析不成功就使用默认的解析器ResourcePatternResolver进行解析
                String baseLocation = getReaderContext().getResource().getURL().toString();
                importCount = getReaderContext().getReader().loadBeanDefinitions(
                        StringUtils.applyRelativePath(baseLocation, location), actualResources);
            }
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;);
            }
        }
        catch (IOException ex) {
            getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(
                    &quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, ex);
        }
    }
    Resource[] actResArray = actualResources.toArray(new Resource[0]);
    // 通知监听器注册完成了
    getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
}
</code></pre>

<h4>1.4.4 嵌入式beans标签的解析</h4>
<p><img src="./img/8.png" /></p>
<h3>1.5 自定义标签的解析(跳过)</h3>
<h2>2. Bean的加载</h2>
<h3>2.1FactoryBean的使用</h3>
<p><img src="./img/9.png" /></p>
<h3>2.2缓存中获取单例bean</h3>
<pre><code>protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    // Quick check for existing instance without full singleton lock 快速检查现有实例，而无需完全单例锁定
    // 1. 检查singletonObjects缓存中是否有实例 singletonObjects：beanName -》 beanInstance
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
        // 2. singletonObjects中没有， 在从earlySingletonObjects中查询 earlySingletonObjects： beanName -》 beanInstance，
        // 区别是当bean还在加载，就可以调用getBean获取，目的是用来检测循环引用
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null &amp;&amp; allowEarlyReference) {
            // 如果为空，就锁定全局变量并进行处理
            synchronized (this.singletonObjects) {
                // Consistent creation of early reference within full singleton lock
                // 如果这个bean正在加载就不处理
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        // 当某些方法需要提前初始化的时候则会调用addSingletonFactory方法将对应的
                        // ObjectFactory初始化策略储存在singletonFactories中
                        // 3. 再找不到就尝试从singletonFactories获取ObjectFactory
                        ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            // 调用预先设定的getObject方法
                            // 4. 然后再调用getObject方法来创建bean
                            singletonObject = singletonFactory.getObject();
                            // 记录在缓存中 earlySingletonObjects和singletonObject互斥
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }
    return singletonObject;
}
</code></pre>

<h6>2.2.1首先会从singletonObjects中获取bean实例，没有再从earlySingletonObjects获取，还是没有就创建bean。如果bean正在加载就不处理，然后实在找不到，就去singletonFactories中找bean的ObjectFactory，然后调用getObject()方法创建bean，再把bean加到earlySingletonObjects中，然后清除singletonFactories中这个bean的ObjectFactory对象。</h6>
<ol>
<li><strong>singletonObjects：</strong>这个map存的是beanName -&gt; beanInstance</li>
<li><strong>earlySingletonObjects:</strong>这个map存的也是beanName -&gt; beanInstance，区别是当bean放到这里面后，当bean还在创建的时候，家可以通过getBean获取到，目的是为了检测循环引用</li>
<li><strong>singletonFactories&quot;</strong>beanName -&gt; ObjectFactory</li>
<li><strong>registeredSingletons:</strong>用来保存当前已经注册的bean</li>
</ol>
<h3>2.3 从bean的实例中获取对象</h3>
<h4></h4>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
