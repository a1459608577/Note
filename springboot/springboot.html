<!DOCTYPE html>
<html>
<head>
<title>SpringBoot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<base href=''/>
</head>
<body>
<h1>SpringBoot</h1>
<h2>1. 入门程序hello world</h2>
<h3>1. 实现功能：浏览器发送hello请求，服务器接收并响应一个hello world</h3>
<ul>
<li>创建maven工程</li>
<li>
<p>导入springboot的依赖</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

</li>
<li>
<p>编写让springboot启动代码</p>
<pre><code>@SpringBootApplication//说明这是一个springboot应用
public class main {
    public static void main(String[] args) {
        //spring应用启动起来
        SpringApplication.run(main.class, args);
    }
}
</code></pre>

</li>
<li>
<p>编写controller代码，然后运行上面的main方法，访问localhost:8080/hello即可</p>
<pre><code>@RequestMapping(&quot;/hello&quot;)
@ResponseBody
public String main() {
    return &quot;hello world!&quot;;
}
</code></pre>

</li>
</ul>
<h3>2. 简化部署</h3>
<ul>
<li>
<p>导入插件</p>
<pre><code>&lt;!--    这个插件的作用时可以将这个项目打包成一个可执行的jar包--&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

</li>
<li>在maven中使用package打包，然后复制到桌面</li>
<li>然后使用命令<strong>java -jar 桌面路径</strong>即可运行(在linux上可以试一下)</li>
</ul>
<h2>2. hello world探究</h2>
<h3>1. POM文件</h3>
<pre><code>&lt;parent&gt;// 父项目
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
&lt;/parent&gt;

//这是上面那个的父项目，真正管理所有springboot依赖(springboot版本仲裁中心)
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
以后导包不需要写版本号，但是也有没在dependencies中的的依赖就需要写版本号
</code></pre>

<h3>2. 导入的依赖</h3>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<ul>
<li>spring-boot-starter: 是springboot场景启动器(就是导入了web模块正常运行的组件</li>
<li><img src="./img/1.png" /></li>
</ul>
<h3>3.主程序类，主入口类(main)</h3>
<ul>
<li>
<p><img src="./img/2.png" /></p>
<pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration  //springboot配置，表示是一个springboot的配置类
@EnableAutoConfiguration  //开启自动配置功能
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
</code></pre>

</li>
</ul>
<h2>3.快速创建一个SpringBoot项目</h2>
<h3>1. 步骤</h3>
<ul>
<li>new project =&gt; 选择spring initiallizr =&gt; 然后选择jdk =&gt; 选择需要的模块 =&gt; 创建工程</li>
<li><strong>@RestController注解可以代替@controller和@responseBody这两个注解</strong></li>
</ul>
<h3>2.目录结构</h3>
<ul>
<li>
resource：
<ul>
<li>static： 存放静态资源(js，css，img)，相当于WebContent</li>
<li>templates： 存放模板(springboot默认使用嵌入式的Tomcat，因此不支持jsp，要使用jsp则需要使用模板引擎freemarker，thymeleaf)</li>
<li>application.properties： 是springboot的配置文件，可以修改一些默认设置</li>
</ul>
</li>
</ul>
<h2>4.SpringBoot配置</h2>
<h3>1.配置文件</h3>
<ul>
<li>
SpringBoot使用的全局配置文件,这两个后缀都会认为是全局配置文件，名字固定
<ul>
<li>application.properties</li>
<li>application.yml</li>
</ul>
</li>
<li>作用：修改SpringBoot配置的默认值</li>
<li>
YAML（YAML Ain't Markup Language）
<ul>
<li>YAML  A Markup Language：是一个标记语言</li>
<li>YAML   isn't Markup Language：不是一个标记语言；</li>
</ul>
</li>
<li>
<p>标记语言：</p>
<ul>
<li>以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</li>
<li>YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</li>
<li>
<p>YAML：配置例子</p>
<pre><code>server:
  port: 8081
</code></pre>

</li>
</ul>
</li>
</ul>
<h3>2.YML的基本语法</h3>
<ul>
<li>
<p>基本语法： </p>
<ul>
<li>key： val(空格不能少，冒号后面加空格)</li>
<li>
<p>如果是层级关系，只要左边对齐的都是同一级</p>
<pre><code>server： 
  port: 8081
  path: /hello
</code></pre>

</li>
<li>属性和值对大小写敏感</li>
</ul>
</li>
<li>
<p>值的写法</p>
<ul>
<li>
<p>字面量： 普通的值(数字，字符串，boolean)</p>
<ul>
<li>
<p>k: v字面直接来写，字符串默认不用加引号</p>
<ul>
<li>
<p>&quot;&quot;双引号： 不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>
<pre><code>name:   &quot;zhangsan \n lisi&quot;：输出；zhangsan 换行  lisi
</code></pre>

</li>
<li>
<p>''单引号： 会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<pre><code>name:   'zhangsan \n lisi'：输出；zhangsan \n  lisi
</code></pre>

</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对象： Map(属性和值)，(键值对)</p>
<ul>
<li>
<p>还是k: v模式</p>
<pre><code>1.user          //注意缩进
    name: zhangsan
    age: 15

2.user: {name: zhangsan,age: 15}  //行内写法，写成一行的格式
</code></pre>

</li>
</ul>
</li>
<li>
<p>数组(list,set)： </p>
<ul>
<li>
<p>用(- 值)的形式，空格不能少</p>
<pre><code>pets
  - cat
  - dog
  - pig
</code></pre>

</li>
<li>行内写法： pets: [cat,dog,pig]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>3.配置文件的值注入</h3>
<ul>
<li>
<p>1.在yml配置文件中写好后需要在domain的类上加一个<strong>@ConfigurationProperties(prefix = &quot;user&quot;)</strong>注解</p>
<pre><code>user:
    name: zhangsan
    age: 15
    isBoss: false
    birthday: 2015/02/02
    maps: {k1: v1, k2: v2}
    list:
      - aa
      - bb
    Dog:
      name: lisi
      age: 2
</code></pre>

<ul>
<li>@ConfigurationProperties注解表示把这个类中的属性和yml配置文件中的属性绑定，默认从全局配置文件取值</li>
<li>prefix：是yml文件中的user，表示通过这个user来找</li>
</ul>
</li>
<li>
<p>遇到报错：Not registered via @EnableConfigurationProperties, marked as Spring component, or scanned via @ConfigurationPropertiesScan</p>
<ul>
<li>
<p>解决方法在pom文件中添加如下代码，然后在domain的类上添加<strong>@component</strong>注解：</p>
<pre><code>&lt;dependency&gt;  //这个是配置文件处理器，导入后在配置文件中就有提示
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>

</li>
<li>在springboot的test文件中如果不能使用@RunWith(apringRunner.class)注解，在pom.xml中加入junit的配置</li>
<li>使用@autowired注入时有红色下划线，要把包全部放在创建项目时生成类的 那个包下</li>
</ul>
</li>
<li>
<p>2.在properties配置文件中，</p>
<pre><code>user.uname=张三   //这里原本时乱码，在ctrl+alt+s搜索file encoding，把
user.age=18         proterties文件的类型改成utf-8然后把旁边的勾勾上
user.is-boss=false
user.birthday=2018/11/25
user.maps.k1=v1
user.maps.k2=v2
user.list=a,b,c
user.dog.name=qwer
user.dog.age=5
</code></pre>

</li>
</ul>
<h3>4.使用@Value和@ConfiguretionProterties获取值的区别</h3>
<ul>
<li><img src="./img/20.png" /></li>
<li>
<strong>松散语法</strong>： 支持的话lastName和last-name两种写法都可以，不支持就只能lastName
<ul>
<li>大写的就是last-name，小写的就是last_name</li>
</ul>
</li>
<li><strong>spEL表达式</strong>：就是用@Value注入可以@value(${2*11}),但是使用@ConfiguretionProterties注解在yml文件中就不能使用</li>
<li><strong>JSR303:</strong>数据验证规范，使用前要在类上加<strong>@Vilidatded<strong>注解</strong>验证规范：https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/index.html</strong></li>
<li><img src="./img/3.png" /></li>
</ul>
<h3>5.@PropertySource和@ImportResource</h3>
<ul>
<li><strong>@PropertySource：</strong>加载指定的配置文件，先从全局配置文件中查找，在从指定文件中找</li>
<li><img src="./img/4.png" /></li>
<li><strong>@ImportResource：</strong>导入spring的配置文件，让配置文件里的内容生效</li>
<li><img src="./img/5.png" /></li>
<li>
<p><strong>SpringBoot中推荐给容器中添加组件的方式：使用全注解</strong></p>
<ul>
<li>1.类似spring配置文件(不推荐)</li>
<li>
<p>2.配置类(推荐)</p>
<pre><code>@Bean      //id就是getHelloService
public HelloService getHelloService() {
    return new HelloService();
}
</code></pre>

</li>
</ul>
</li>
</ul>
<h3>6.配置文件占位符</h3>
<ul>
<li><img src="./img/6.png" /></li>
<li>
<p><strong>随机数</strong></p>
<pre><code>${random.value}、${random.int}、${random.long} //可以通过这些获取数值
${random.int(10)}、${random.int[1024,65536]}
</code></pre>

</li>
</ul>
<h3>7.Profile</h3>
<ul>
<li>
1.多Profile文件
<ul>
<li>创建多个properties配置文件，格式：application-{profile}.properties,默认读取的是application.properties</li>
</ul>
</li>
<li>2.yml支持多文档块方式</li>
<li><img src="./img/7.png" /></li>
<li>
3.激活指定Profile
<ul>
<li>1.切换读取其他配置文件： <strong>spring.profiles.active = {profile}</strong>(这个就是上面指定的值，这个是在配置文件中指定，直接下写在配置文件中即可)</li>
<li>2.命令行： <strong>--spring.profiles.active = bb</strong>(这个bb是图片上的的bb)</li>
<li><img src="./img/8.png" /></li>
<li>3.虚拟机参数：<strong>-Dspring.profiles.active = bb</strong></li>
<li><img src="./img/9.png" /></li>
</ul>
</li>
</ul>
<h3>8.配置文件位置加载顺序</h3>
<ul>
<li><img src="./img/10.png" /></li>
<li><img src="./img/11.png" /></li>
<li>springboot会从高往低加载，而且会<strong>互补配置</strong></li>
</ul>
<h3>9.外部配置的加载顺序</h3>
<ul>
<li>
<p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p>
<ul>
<li>
<p><strong>1.命令行参数:</strong>所有的配置都可以在命令行上进行指定</p>
<pre><code>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.context-path=/abc 
//多个配置用空格分开； --配置项=值
</code></pre>

</li>
<li>2.来自java:comp/env的JNDI属性</li>
<li>3.Java系统属性（System.getProperties()）</li>
<li>4.操作系统环境变量</li>
<li>5.RandomValuePropertySource配置的random.*属性值</li>
<li><strong>由jar包外向jar包内进行寻找,优先加载带profile</strong></li>
<li><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></li>
<li><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></li>
<li><strong>再来加载不带profile</strong></li>
<li><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></li>
<li><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></li>
<li>10.@Configuration注解类上的@PropertySource</li>
<li>11.通过SpringApplication.setDefaultProperties指定的默认属性</li>
</ul>
<p>所有支持的配置加载来源；<a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config">参考官方文档</a></p>
</li>
</ul>
<h3>10.自动配置的原理</h3>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties">配置文件能配置的属性参照</a></li>
<li>
<p><strong>自动配置原理：</strong></p>
<ul>
<li>1.SpringBoot启动的时候，开启了自动配置功能，<strong>@EnableAutoConfiguretion</strong>注解</li>
<li>
2.@EnableAutoConfiguretion的作用： 
<ul>
<li>利用<strong>AutoConfigurationImportSelector</strong>给容器导入一些组件，可以点进去查看selectImports的内容</li>
</ul>
</li>
<li>
<p>3.以<strong>HttpEncodingAutoConfiguration</strong>自动配置类为例</p>
<pre><code>@Configuration(proxyBeanMethods = false)  //表示这是一个配置类，也可以给容器中添加组件
@EnableConfigurationProperties({HttpProperties.class}) //启用指定类的Httpproperties功能，类里面的内容在读取指定的配置文件，
将配置文件的内容和HttpProperties绑定
@ConditionalOnWebApplication(type = Type.SERVLET)
//它的底层是spring中@Conditional注解，根据不同条件来判断，满足条件时配置类里的配置才生效，当前这个时判断是否是web应用
@ConditionalOnClass({CharacterEncodingFilter.class})
//这个时判断当前项目中有没有这个类(CharacterEncodingFilter),这个是springmvc中的过滤器
@ConditionalOnProperty(
    prefix = &quot;spring.http.encoding&quot;,
    value = {&quot;enabled&quot;},
    matchIfMissing = true//这个的意思时判断如不存在判断也成立
)
//这个注解是判断配置文件中是否有这个配置，在&quot;spring.http.encoding&quot;是否有&quot;enabled&quot;属性
public class HttpEncodingAutoConfiguration {
</code></pre>

</li>
<li><strong>所有配置文件中的属性都在xxxxProperties类中被封装，根据配置类中的条件是否被满足，满足则配置类生效</strong></li>
<li><img src="./img/12.png" /></li>
<li>
<p>精髓： </p>
<ul>
<li>1.springboot启动会加载大量自动配置类</li>
<li>2.然后看我们需要的功能springboot有没有默认写好的配置类</li>
<li>3.然后再看配置了那些组件，有的话就不用在配置</li>
<li>
<p>4.给容器中自动配置类添加组件时，会从properties中获取某些属性，我们可以指定</p>
<pre><code>xxxxAutoConfiguretion自动配置类
给容器中添加组件
xxxxProperties中封装配置文件中的属性
查看方法：找到任意一个xxxAutoConfidyretion类，点进去@EnableConfigurationProperties({xxx.class})，然后就能看到了
</code></pre>

</li>
</ul>
</li>
</ul>
</li>
<li>
细节：
<ul>
<li>1. <strong>@Conditional注解：</strong>必须是@Conditional指定的条件成立，配置类才生效</li>
<li><img src="./img/21.png" /></li>
<li>2.可以通过配置属性debug=true让springboot在控制台打印自动配置报告</li>
<li><img src="./img/13.png" /></li>
</ul>
</li>
</ul>
<h2>5.日志</h2>
<h3>1.日志框架</h3>
<ul>
<li>市面上的日志框架：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j....</li>
<li><img src="./img/22.png" /></li>
<li>
左边选一个门面（抽象层）、右边来选一个实现；
<ul>
<li>日志门面：  SLF4J；</li>
<li>日志实现：Logback；
*</li>
</ul>
</li>
<li>SpringBoot：底层是Spring框架，Spring框架默认是用JCL;</li>
</ul>
<h3>2.SLF4J的使用</h3>
<h4>1.如何在系统中使用slf4j</h4>
<ul>
<li>
<p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；给系统里面导入slf4j的jar和  logback的实现jar</p>
<pre><code>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info(&quot;Hello World&quot;);
  }
}
</code></pre>

</li>
<li><img src="./img/14.png" /></li>
<li><img src="./img/15.png" /></li>
<li>
如何让系统中所有的日志都统一到slf4j
<ul>
<li>1、将系统中其他日志框架先排除出去；</li>
<li>2、用中间包来替换原有的日志框架；</li>
<li>3、我们导入slf4j其他的实现</li>
</ul>
</li>
</ul>
<h4>2.SpringBoot中的日志关系</h4>
<ul>
<li>
<p>查看项目中各个包的关系：<strong>ctrl + alt + shift + u</strong></p>
<pre><code>&lt;dependency&gt;     //springboot用这个来做日志管理
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
  &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

</li>
<li><img src="./img/16.png" /></li>
<li>
总结：
<ul>
<li>SpringBoot底层也是使用slf4j+logback的方式进行日志记录</li>
<li>SpringBoot也把其他的日志都替换成了slf4j；</li>
<li>如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？Spring框架用的是commons-logging；</li>
<li><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可</strong></li>
</ul>
</li>
</ul>
<h3>3.日志的使用</h3>
<h4>1.默认配置</h4>
<ul>
<li>SpringBoot已经默认配置好了</li>
<li><img src="./img/17.png" /></li>
<li><img src="./img/18.png" /></li>
<li>
<strong>日志输出格式例子： %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</strong>
<ul>
<li><strong>%d</strong>表示日期时间，</li>
<li><strong>%thread</strong>表示线程名，</li>
<li><strong>%-5level</strong>：级别从左显示5个字符宽度</li>
<li><strong>%logger{50}</strong> 表示logger名字最长50个字符，否则按照句点分割。 </li>
<li><strong>%msg</strong>：日志消息</li>
<li><strong>%n</strong>是换行符</li>
</ul>
</li>
</ul>
<h4>2.指定配置</h4>
<ul>
<li><img src="./img/23.png" /></li>
<li>直接用logback.xml:会被日志框架直接识别</li>
<li>
<p>使用logback-spring.xml:就会交给springboot来处理​</p>
<pre><code>&lt;springProfile name=&quot;staging&quot;&gt;   //springboot高级功能
    &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;
    可以指定某段配置只在某个环境下生效
&lt;/springProfile&gt;
</code></pre>

</li>
<li>
<p><img src="./img/19.png" /></p>
</li>
</ul>
<h3>4.切换日志框架</h3>
<ul>
<li>可以按照日志结构图来切换</li>
<li>
<p>切换slf4j + log4j</p>
<pre><code>&lt;dependency&gt;   //首先导入这个包(slf4j和log4j的中间包)
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;   //然后在把下面这两个移除
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>

</li>
<li>
<p>切换到log4j2</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;   
</code></pre>

</li>
</ul>
<h2>6.SpringBoot与Web开发</h2>
<h3>SpringBoot对静态资源的映射规则；</h3>
<pre><code>    //源码
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    if (!this.resourceProperties.isAddMappings()) {
        logger.debug(&quot;Default resource handling disabled&quot;);
    } else {
        Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
        CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
        if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
            this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{&quot;/webjars/**&quot;}).addResourceLocations(new String[]{&quot;classpath:/META-INF/resources/webjars/&quot;}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
        }

        String staticPathPattern = this.mvcProperties.getStaticPathPattern();
        if (!registry.hasMappingForPattern(staticPathPattern)) {
            this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
        }

    }
}
</code></pre>

<h4>1.所有<strong>/webjars/</strong>**都去<strong>&quot;classpath:/META-INF/resources/webjars/&quot;</strong>下找资源</h4>
<ul>
<li><strong>/webjars/</strong>：**就是以jar包的方式引入静态资源，<a href="https://www.webjars.org/" title="webjars官网">webjars官网</a></li>
<li>
<p><img src="./img/24.png" /></p>
<pre><code>//WebMvcAutoConfiguration =&gt; this.resourceProperties 
//这里可以设置和静态资源相关的参数，如缓存时间等
@ConfigurationProperties(prefix = &quot;spring.resources&quot;,ignoreUnknownFields = false)
public class ResourceProperties {
</code></pre>

</li>
</ul>
<h4>2.<strong>/</strong>**:访问当前项目的任何资源(这些就是静态资源文件夹)</h4>
<ul>
<li>
<p>访问locahost://8080/abc ==&gt; 去静态资源文件夹里找abc</p>
<pre><code>* &quot;classpath:/META-INF/resources/&quot;(类路径)
* &quot;classpath:/resources/&quot;
* &quot;classpath:/static/&quot;
* &quot;classpath:/public/&quot;
* &quot;/&quot;:当前项目的根路径
</code></pre>

</li>
</ul>
<h4>3.欢迎页：静态资源文件夹下的所有index.html页面，被&quot;/**&quot;映射</h4>
<pre><code>@Bean   //对欢迎页的映射
public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {
    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern());
    welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider));
    return welcomePageHandlerMapping;
}
</code></pre>

<ul>
<li>例如访问locahost://8080/时会去所有静态资源文件夹中找index.html然后显示</li>
</ul>
<h3>4.模板引擎</h3>
<h4><img src="./img/25.png" /></h4>
<h4>thymeleaf</h4>
<ul>
<li>
<p><strong>1.引入thymeleaf</strong></p>
<pre><code>&lt;dependency&gt;  
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;

切换thymeleaf版本
&lt;properties&gt;
    &lt;thymeleaf.version&gt;3.0.11.RELEASE&lt;/thymeleaf.version&gt;
    &lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;
    &lt;!-- thymeleaf2   layout1--&gt;
    &lt;thymeleaf-layout-dialect.version&gt;2.1.1&lt;/thymeleaf-layout-dialect.version&gt;
&lt;/properties&gt;
</code></pre>

</li>
<li><img src="./img/26.png" /></li>
<li>
<p><strong>2.在html文件中导入thymeleaf的命名空间</strong></p>
<pre><code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
</code></pre>

</li>
<li>
<p><strong>3.使用thymeleaf的语法</strong></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;成功！&lt;/h2&gt;
&lt;div th:text=&quot;${hello}&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

</li>
<li>
<strong>4.thymeleaf的语法规则</strong>
<ul>
<li><strong>1.  th：任意html属性，可以替换原来的值</strong>比如： &lt;div id=&quot;aa&quot; th:id=&quot;${bb}&quot;&gt;</div>结果： id=bb</li>
</ul>
</li>
<li>
<p><img src="./img/27.png" /></p>
<ul>
<li>
<p><strong>2.表达式语法</strong></p>
<pre><code>Simple expressions(表达式语法):
    Variable Expressions: ${...} //获取变量值；OGNL；
        1）、获取对象的属性、调用方法
        2）、使用内置的基本对象：
            #ctx : the context object.
            #vars: the context variables.
            #locale : the context locale.
            #request : (only in Web Contexts) the HttpServletRequest object.
            #response : (only in Web Contexts) the HttpServletResponse object.
            #session : (only in Web Contexts) the HttpSession object.
            #servletContext : (only in Web Contexts) the ServletContext object.

            用法例如：${session.foo}
        3）、内置的一些工具对象：
            #execInfo : information about the template being processed.
            #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.
            #uris : methods for escaping parts of URLs/URIs
            #conversions : methods for executing the configured conversion service (if any).
            #dates : methods for java.util.Date objects: formatting, component extraction, etc.
            #calendars : analogous to #dates , but for java.util.Calendar objects.
            #numbers : methods for formatting numeric objects.
            #strings : methods for String objects: contains, startsWith, prepending/appending, etc.
            #objects : methods for objects in general.
            #bools : methods for boolean evaluation.
            #arrays : methods for arrays.
            #lists : methods for lists.
            #sets : methods for sets.
            #maps : methods for maps.
            #aggregates : methods for creating aggregates on arrays or collections.
            #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).
    Selection Variable Expressions: *{...}  //选择表达式，和${}在功能上是一样；
        &lt;div th:object=&quot;${session.user}&quot;&gt;用法
            &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
            &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
            &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
        &lt;/div&gt;
    Message Expressions: #{...}  //获取国际化内容
    Link URL Expressions: @{...}  //定义url
        @{/order/process(execId=${execId},execType='FAST')}
    Fragment Expressions: ~{...}  //片段引用表达式
        &lt;div th:insert=&quot;~{commons :: main}&quot;&gt;...&lt;/div&gt;
Literals(字面量)
    Text literals: 'one text', 'Another one!',…
    Number literals: 0, 34, 3.0, 12.3,…
    Boolean literals: true, false
    Null literal: null
    Literal tokens: one, sometext, main,…
Text operations:(文本操作)
    String concatenation: +
    Literal substitutions: |The name is ${name}|
Arithmetic operations:(数学运算)
    Binary operators: +, -, *, /, %
    Minus sign (unary operator): -
Boolean operations:(布尔运算)
    Binary operators: and, or
    Boolean negation (unary operator): !, not
Comparisons and equality:(比较运算)
    Comparators: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)
    Equality operators: ==, != (eq, ne)
Conditional operators:(条件运算)
    If-then: (if) ? (then)
    If-then-else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
Special tokens:()
    No-Operation: _
</code></pre>

</li>
</ul>
</li>
<li><img src="./img/28.png" /></li>
</ul>
<h3>5.SpringMVC自动配置</h3>
<h4><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications">SpringMVC自动配置官方文档</a></h4>
<h4>1.Spring MVC auto-configuration</h4>
<ul>
<li>
<p>Spring Boot 自动配置好了SpringMVC，以下是SpringBoot对SpringMVC的默认配置:（WebMvcAutoConfiguration）</p>
<ul>
<li>
Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.
<ul>
<li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li>
<li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li>
<li><strong>如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；</strong></li>
</ul>
</li>
<li>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</li>
<li>Static <code>index.html</code> support. 静态首页访问，访问静态资源中的index.html</li>
<li>Custom <code>Favicon</code> support (see below).  favicon.ico(图标)</li>
<li>
<p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p>
<ul>
<li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li>
<li>
<p><code>Formatter</code>  格式化器；  2017.12.17===Date；</p>
<pre><code>@Bean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)//在文件中配置日期格式化的规则
public Formatter&lt;Date&gt; dateFormatter() {
    return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件
}
</code></pre>

</li>
<li><strong>自己添加的格式化器转换器，我们只需要放在容器中即可</strong></li>
</ul>
</li>
<li>
Support for <code>HttpMessageConverters</code> (see below).
<ul>
<li>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User---Json；</li>
<li><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</li>
<li><strong>自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）</strong></li>
</ul>
</li>
<li>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</li>
<li>
<p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p>
<ul>
<li>
<p><strong>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）</strong></p>
<pre><code>初始化WebDataBinder；
请求数据=====JavaBean；
</code></pre>

</li>
</ul>
</li>
</ul>
</li>
<li><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></li>
<li>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.
If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</li>
</ul>
<h4>2、扩展SpringMVC</h4>
<pre><code>&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/hello&quot;/&gt;
        &lt;bean&gt;&lt;/bean&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>

<ul>
<li>
<p><strong>编写一个配置类(@configuration)，是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc</strong></p>
<pre><code>//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能，既保留了所有的自动配置，也能用我们扩展的配置；
@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
       // super.addViewControllers(registry);
        //浏览器发送 /atguigu 请求来到 success
        registry.addViewController(&quot;/test&quot;).setViewName(&quot;success&quot;);
    }
}
</code></pre>

<ul>
<li>
<p>原理：</p>
<ul>
<li>1.WebMvcAutoConfiguration是SpringMVC的自动配置类</li>
<li>
<p>2.在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p>
<pre><code>@Configuration
public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {
  private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();

 //从容器中获取所有的WebMvcConfigurer
  @Autowired(required = false)  //@autowired写在方法上表示方法的参数要从容器中获取
  public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {
      if (!CollectionUtils.isEmpty(configurers)) {
          this.configurers.addWebMvcConfigurers(configurers);
            //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  
            @Override
         // public void addViewControllers(ViewControllerRegistry registry) {
          //    for (WebMvcConfigurer delegate : this.delegates) {
           //       delegate.addViewControllers(registry);
           //   }
          }
      }
}
</code></pre>

</li>
<li>3.容器中所有的WebMvcConfigurer都会一起起作用；</li>
<li>4. 我们的配置类也会被调用；</li>
<li>效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>3.全面接管SpringMVC；</h4>
<ul>
<li><strong>我们在配置类中添加@EnableWebMvc,</strong>SpringBoot对SpringMVC的自动配置就不生效了，所有都是我们自己配置；</li>
<li>
<p>原理：为什么@EnableWebMvc自动配置就失效了；</p>
<ul>
<li>1. @EnableWebMvc的核心(就是导入了DelegatingWebMvcConfiguration这个类)</li>
<li>
<pre><code>@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
</code></pre>

</li>
<li>
<p>2.DelegatingWebMvcConfiguration继承了WebMvcConfigurationSupport</p>
<pre><code>@Configuration
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
</code></pre>

</li>
<li>
<p>3.WebMvcAutoConfiguration中有一个判断的注解，没有上面的类，自动配置才生效</p>
<pre><code>@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
        WebMvcConfigurerAdapter.class })
//容器中没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,ValidationAutoConfiguration.class})
public class WebMvcAutoConfiguration {
</code></pre>

</li>
<li>4.导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</li>
</ul>
</li>
</ul>
<h3>6.修改SpringBoot的默认配置</h3>
<ul>
<li>
<p>1.SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p>
</li>
<li>
<p>2.在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p>
</li>
<li>3.在SpringBoot中会有非常多的xxxCustomizer帮助我们进行定制配置</li>
</ul>
<h3>7、RestfulCRUD</h3>
<h4>1.默认访问首页</h4>
<pre><code>@Configuration
public class myMvcConfig extends WebMvcConfigurerAdapter {

    @Bean
    public WebMvcConfigurerAdapter getWebMvcConfigurerAdapter() {
        WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter(){
            @Override    
            public void addViewControllers(ViewControllerRegistry registry) {
                registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);
                registry.addViewController(&quot;/index&quot;).setViewName(&quot;index&quot;);
            }
        };
        return adapter;
    }
}
</code></pre>

<h4>2.国际化</h4>
<ul>
<li>
1.编写国际化配置文件
<ul>
<li>
抽取页面需要的国际化消息
<ul>
<li>在resources新建文件夹i18n =&gt; 新建一个叫index.properties和index_zh_CN.properties =&gt; 右击父文件夹 =&gt; NEW =&gt; Add =&gt; 点击右边的+号 =&gt; 输入en_US 即可自动创建英语的国际化配置文件</li>
<li>选一个index_zh_CN.properties =&gt; 点击左下角的resource bundle =&gt; 然后点击右上角的+ =&gt; 输入标题 =&gt; 第一个框是默认显示的，第二个是英语显示的，第三个是中文显示的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>2.使用<strong>ResourceBundleMessageSource</strong>管理国际化资源文件</p>
<ul>
<li>
<p>在MessageResourceAutoConfig类中springboot已经配置好了</p>
<pre><code>@Bean
@ConfigurationProperties(prefix = &quot;spring.messages&quot;)//可以通过spring.message来设置一些属性
public MessageSourceProperties messageSourceProperties() {
    return new MessageSourceProperties();
}

private String basename = &quot;messages&quot;;
//我们的配置文件可以放在类路径下叫message.properties，

@Bean
public MessageSource messageSource(MessageSourceProperties properties) {
    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
    if (StringUtils.hasText(properties.getBasename())) {
        //设置国际化资源文件的基础名
        messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));
    }

    if (properties.getEncoding() != null) {
        messageSource.setDefaultEncoding(properties.getEncoding().name());
    }

    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
    Duration cacheDuration = properties.getCacheDuration();
    if (cacheDuration != null) {
        messageSource.setCacheMillis(cacheDuration.toMillis());
    }

    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
    return messageSource;
}   
</code></pre>

</li>
<li>在配置文件中加<strong>spring.message.basename=i18n.index</strong>即可</li>
</ul>
</li>
<li>
<p>3.去页面获取国际化的值</p>
<ul>
<li>出现乱码就在setting中搜file encoding，把GBK改成UTF-8即可</li>
<li>
<p>效果：根据浏览器语言设置的信息切换了国际化；</p>
<ul>
<li>
<p>原理：国际化Locale（区域信息对象）；webmvcAutoconfig中配置了LocaleResolver（获取区域信息对象）；</p>
<pre><code>@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;,name = {&quot;locale&quot;})
public LocaleResolver localeResolver() {
    if (this.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web
                .servlet.WebMvcProperties.LocaleResolver.FIXED) {
        return new FixedLocaleResolver(this.mvcProperties.getLocale());
    } else {
        AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();//从request头中取区域信息
        localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
        return localeResolver;
    }
}
</code></pre>

</li>
</ul>
</li>
<li>
<p>根据下方点击中文或英文来切换页面的语言</p>
<pre><code>//实现LocaleResolver接口，在resolveLocale中判断是那种语言
public class myLocaleResolver implements LocaleResolver {
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        String l = request.getParameter(&quot;l&quot;);
        Locale locale = Locale.getDefault();
        if (!StringUtils.isEmpty(l)) {
            String[] s = l.split(&quot;_&quot;);
            locale = new Locale(s[0], s[1]);//第一个是语言，第二个是国家
        }
        return locale;
    }

//在myWebConfig中加入自己写的localeResolver，localeResolver不能写别的名字，否则不生效
@Bean
public LocaleResolver localeResolver() {
    return new myLocaleResolver();
}
</code></pre>

</li>
</ul>
</li>
<li>
<p>4.登录页面</p>
<ul>
<li>禁用thymeleaf缓存： <strong>spring.thymeleaf.cache=false</strong></li>
<li>日期格式化： <strong>spring.mvc.data-format=yyyy-MM-dd hh:mm:ss</strong></li>
<li>重新编译： <strong>ctrl + f9</strong></li>
<li>
<p>登录后显示错误信息</p>
<pre><code>&lt;p th:text=&quot;${msg}&quot; th:if=&quot;${not #strings.isEmpty(msg)}&quot;&gt;&lt;/p&gt;
</code></pre>

</li>
<li>
<p>拦截器进行登录检查</p>
<pre><code>//实现拦截器的接口
public class logonhandlerinterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object username = request.getSession().getAttribute(&quot;username&quot;);
        if (!StringUtils.isEmpty(username)) {
            return true; //登录了就放行
        }
        request.setAttribute(&quot;msg&quot;, &quot;没有权限&quot;);
        request.getRequestDispatcher(&quot;/index&quot;).forward(request,response);
        return false; //没登陆就不放行，并转发到这个页面
    }

//把自己写的拦截器交给容器管理
@Override
public void addInterceptors(InterceptorRegistry registry) {
    //拦截所有请求后排除下面三个请求
    registry.addInterceptor(new logonhandlerinterceptor()).addPathPatterns(&quot;/**&quot;)
            .excludePathPatterns(&quot;/index&quot;,&quot;/&quot;, &quot;/login&quot;);
}
</code></pre>

</li>
</ul>
</li>
<li>5.CRUD员工列表</li>
<li><img src="./img/29.png" /></li>
<li>
<p>thymeleaf页面公共元素抽取</p>
<pre><code>1、抽取公共片段
&lt;div th:fragment=&quot;copy&quot; id=&quot;aa&quot;&gt;
    &amp;copy; 2011 The Good Thymes Virtual Grocery
&lt;/div&gt;

2、引入公共片段
&lt;div th:insert=&quot;~{footer :: copy}&quot;&gt;&lt;/div&gt;
写法一： ~{templatename::#aa}：模板名::选择器
写法二： ~{templatename::fragmentname}:模板名::片段名
</code></pre>

<ul>
<li>
<p>三种引入方式</p>
<ul>
<li><strong>th:insert：</strong>把原来标签内容插入到div中</li>
<li><strong>th:replace：</strong>用div把原来最外层标签替换掉</li>
<li>
<p><strong>th:include：</strong>将被引入的内容直接用div包含起来</p>
<pre><code>&lt;footer th:fragment=&quot;copy&quot;&gt;
    &amp;copy; 2011 The Good Thymes Virtual Grocery
&lt;/footer&gt;

引入方式
&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;
&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;
&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;

效果
&lt;div&gt;
    &lt;footer&gt;
        &amp;copy; 2011 The Good Thymes Virtual Grocery
    &lt;/footer&gt;
&lt;/div&gt;

&lt;footer&gt;
    &amp;copy; 2011 The Good Thymes Virtual Grocery
&lt;/footer&gt;

&lt;div&gt;
    &amp;copy; 2011 The Good Thymes Virtual Grocery
&lt;/div&gt;
</code></pre>

</li>
</ul>
</li>
<li>
<p>引入片段时传参</p>
<pre><code>&lt;nav class=&quot;col-md-2 d-none d-md-block bg-light sidebar&quot; id=&quot;sidebar&quot;&gt;
&lt;!--引入侧边栏;传入参数--&gt;
&lt;div th:replace=&quot;commons/bar::#sidebar(activeUri='emps')&quot;&gt;&lt;/div&gt;
</code></pre>

</li>
<li>
<p><strong>修改form表单的提交方式</strong></p>
</li>
<li><img src="./img/30.png" /></li>
</ul>
</li>
</ul>
<h3>8.错误处理机制</h3>
<h4>1.SpringBoot默认的错误处理机制</h4>
<h5>默认效果</h5>
<ul>
<li>
1.返回一个默认的页面
<ul>
<li><img src="./img/31.png" /></li>
<li>浏览器发请求的时候</li>
<li><img src="./img/33.png" /></li>
</ul>
</li>
<li>
2.用其他客户端访问，返回的错误页面是json数据
<ul>
<li><img src="./img/32.png" /></li>
<li>其他客户端发请求时</li>
<li><img src="./img/34.png" /></li>
</ul>
</li>
<li>原理：<strong>可以参照ErrorMVCAutoConfiguretion</strong>错误的自动配置</li>
<li>
<p>给容器中添加的组件</p>
<ul>
<li>
<p><strong>DefaultErrorAttributes</strong></p>
<pre><code>public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {
    Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap();
    errorAttributes.put(&quot;timestamp&quot;, new Date());
    this.addStatus(errorAttributes, webRequest);
    this.addErrorDetails(errorAttributes, webRequest, includeStackTrace);
    this.addPath(errorAttributes, webRequest);
    return errorAttributes;
}
</code></pre>

</li>
<li>
<p><strong>BasicErrorController：</strong>处理默认的error请求</p>
<pre><code>@Controller     
@RequestMapping({&quot;${server.error.path:${error.path:/error}}&quot;})
public class BasicErrorController extends AbstractErrorController {


@RequestMapping(produces = {&quot;text/html&quot;})
public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {
    HttpStatus status = this.getStatus(request); //产生html数据，浏览器发的请求来这里
    Map&lt;String, Object&gt; model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.TEXT_HTML)));
    response.setStatus(status.value());
    //去哪个错误页面和包含的内容
    ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);
    return modelAndView != null ? modelAndView : new ModelAndView(&quot;error&quot;, model);
}

@RequestMapping
public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {
    HttpStatus status = this.getStatus(request);  //产生json数据，其他客户端发的来这里
    if (status == HttpStatus.NO_CONTENT) {
        return new ResponseEntity(status);
    } else {
        Map&lt;String, Object&gt; body = this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.ALL));
        return new ResponseEntity(body, status);
    }
}
</code></pre>

</li>
<li>
<p><strong>ErrorPageCustomizer</strong></p>
<pre><code>@Value(&quot;${error.path:/error}&quot;)
private String path = &quot;/error&quot;;  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）
</code></pre>

</li>
<li>
<p><strong>DefaultErrorViewResolver</strong></p>
<pre><code>public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) {

    ModelAndView modelAndView = this.resolve(String.valueOf(status.value()), model);
    if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) {
        modelAndView = this.resolve((String)SERIES_VIEWS.get(status.series()), model);
    }
        return modelAndView;
}

private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) {
    //默认springboot可以去找一个页面  error/404
    String errorViewName = &quot;error/&quot; + viewName;
    //模板引擎可以解析就解析
    TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext);
    //可以的话就用模板引擎解析，不可以就是另一种方式，就子啊静态文件夹下找对应的页面error/404.html
    return provider != null ? new ModelAndView(errorViewName, model) : this.resolveResource(errorViewName, model);
}
</code></pre>

</li>
</ul>
<p>步骤：一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被<strong>BasicErrorController</strong>处理，一种是html一种是json；</p>
<p>1）响应页面；去哪个页面是由<strong>DefaultErrorViewResolver</strong>解析得到的；</p>
<pre><code>protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) {
    Iterator var5 = this.errorViewResolvers.iterator();

    ModelAndView modelAndView;
    do {
        if (!var5.hasNext()) {
            return null;
        }

        ErrorViewResolver resolver = (ErrorViewResolver)var5.next();
        modelAndView = resolver.resolveErrorView(request, status, model);
    } while(modelAndView == null);

    return modelAndView;
}
</code></pre>

</li>
</ul>
<h5>定制错误响应</h5>
<ul>
<li>
<p>1.如何定制错误页面</p>
<ul>
<li>
<p><strong>1）、有模板引擎的情况下；error/状态码;</strong> 【将错误页面命名为  <strong>错误状态码.html</strong> 放在模板引擎文件夹里面的 <strong>error</strong>文件夹下】，发生此状态码的错误就会来到  对应的页面；</p>
<ul>
<li><strong>我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；</strong>	</li>
<li>
页面能获取的信息
<ul>
<li>timestamp:时间戳</li>
<li>status：状态码</li>
<li>error：错误提示</li>
<li>exception：异常对象</li>
<li>message：异常消息</li>
<li>errors：JSR303数据校验的错误都在这里</li>
</ul>
</li>
</ul>
</li>
<li>2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；</li>
<li>3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；	
​				</li>
</ul>
</li>
<li>
<p>2.如何定制错误的json数据</p>
<ul>
<li>
<p>1）、自定义异常处理&amp;返回定制json数据；</p>
<pre><code>@ControllerAdvice
public class MyExceptionHandler {

    @ResponseBody
    @ExceptionHandler(UserNotExistException.class)
    public Map&lt;String,Object&gt; handleException(Exception e){
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;,&quot;user.notexist&quot;);
        map.put(&quot;message&quot;,e.getMessage());
        return map;
    }
}
//没有自适应效果...
</code></pre>

</li>
<li>
<p>2）、转发到/error进行自适应响应效果处理</p>
<pre><code>@ExceptionHandler(UserNotExistException.class)
public String handleException(Exception e, HttpServletRequest request){
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
    /**
     * Integer statusCode = (Integer) request
     .getAttribute(&quot;javax.servlet.error.status_code&quot;);
     */
    //传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程  
    request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500);
    map.put(&quot;code&quot;,&quot;user.notexist&quot;);
    map.put(&quot;message&quot;,e.getMessage());
    request.setAttribute(&quot;ext&quot;, map);
    //转发到/error
    return &quot;forward:/error&quot;;
}
</code></pre>

</li>
<li>
<p>3）、将我们的定制数据携带出去；</p>
<ul>
<li>出现错误后，会来到/error请求。会被BasicErrorController处理，两种方式响应出去可以获取的数据都是由getErrorAttributes得到的，(实现了AbstractErrorController（ErrorController）这个接口)</li>
<li>1.完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</li>
<li>
<p>2.页面上能用的数据，或者是json返回能用的数据都是通过<strong>errorAttributes.getErrorAttributes</strong>得到；容器中<strong>DefaultErrorAttributes.getErrorAttributes()</strong>；默认进行数据处理的；</p>
<ul>
<li>自定义ErrorAttributes</li>
<li>
<pre><code>//给容器中加入我们自己定义的ErrorAttributes
@Component
public class MyErrorAttributes extends DefaultErrorAttributes {

    @Override
    public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) {
        Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace);
        map.put(&quot;company&quot;,&quot;atguigu&quot;);

        Map&lt;String, Object&gt; ext = requestAttributes.getAttribute(&quot;ext&quot;);
        map.put(&quot;ext&quot;, ext)
        return map;
    }
}
</code></pre>

</li>
<li>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>7.配置嵌入式Servlet容器</h2>
<ul>
<li>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</li>
<li><img src="./img/35.png" /></li>
</ul>
<h3>1）、如何定制和修改Servlet容器的相关配置；</h3>
<h4>1.修改和server有关的配置(在ServerProperties中可以看到)</h4>
<pre><code>server.port=8081
server.context-path=/crud
server.tomcat.uri-encoding=utf-8

//通用的server配置：server.xxx
//tomcat的设置：server.tomcat.xxx
</code></pre>

<h4>2.编写一个WebServerFactoryCustomizer：嵌入式的servlet的定制容器，来修改servlet容器的配置</h4>
<pre><code>@Bean
public WebServerFactoryCustomizer webServerFactoryCustomizer() {
    return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;(){
        //定制嵌入式容器的相关规则
        @Override
        public void customize(ConfigurableWebServerFactory factory) {
            factory.setPort(8083);
        }
    };
}
</code></pre>

<h3>2）、注册Servlet三大组件【Servlet、Filter、Listener】</h3>
<p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p>
<h4>1.注册三大组件用以下方式</h4>
<ul>
<li>
<p><strong>ServletRegistrationBean</strong></p>
<pre><code>@Bean
public ServletRegistrationBean myServlet() {
    ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new MyServlet(), &quot;/bb&quot;);
    return servletRegistrationBean;
}
</code></pre>

</li>
<li>
<p><strong>FilterRegistrationBean</strong></p>
<pre><code>@Bean
public FilterRegistrationBean myFilter() {
    FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
    filterRegistrationBean.setFilter(new MyFilter());
    filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/bb&quot;,&quot;/test&quot;));
    return filterRegistrationBean;
}
</code></pre>

</li>
<li>
<p><strong>ServletListenerRegistrationBean</strong></p>
<pre><code>@Bean
public ServletListenerRegistrationBean servletListenerRegistrationBean() {
    ServletListenerRegistrationBean&lt;EventListener&gt; servletListenerRegistrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener());
    return servletListenerRegistrationBean;
}
</code></pre>

<p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p>
<p>DispatcherServletAutoConfiguration中：</p>
<pre><code>@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
public ServletRegistrationBean dispatcherServletRegistration(
      DispatcherServlet dispatcherServlet) {
   ServletRegistrationBean registration = new ServletRegistrationBean(
         dispatcherServlet, this.serverProperties.getServletMapping());
    //默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp
    //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径

   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
   registration.setLoadOnStartup(
         this.webMvcProperties.getServlet().getLoadOnStartup());
   if (this.multipartConfig != null) {
      registration.setMultipartConfig(this.multipartConfig);
   }
   return registration;
}
</code></pre>

</li>
</ul>
<h3>3）、切换为其他嵌入式Servlet容器</h3>
<ul>
<li><img src="./img/36.png" /></li>
<li>
<p>默认支持：</p>
<ul>
<li>
<p>Tomcat(默认使用)</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；
&lt;/dependency&gt;
</code></pre>

</li>
<li>
<p>Jetty</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    //先把tomcat排除掉
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
然后在引入其他容器
&lt;dependency&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;/dependency&gt;
</code></pre>

</li>
<li>
<p>Undertow</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    //先把tomcat排除掉
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
然后在引
</code></pre>

</li>
</ul>
</li>
</ul>
<p>入其他容器
	        <dependency>
	            <artifactId>spring-boot-starter-undertow</artifactId>
	            <groupId>org.springframework.boot</groupId>
	        </dependency></p>
<h3>4）、嵌入式Servlet容器自动配置原理；</h3>
<p><strong>EmbeddedServletContainerAutoConfiguration</strong>：嵌入式Servlet容器的自动配置</p>
<pre><code>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@Import(BeanPostProcessorsRegistrar.class)
//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件
//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：
//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作
public class EmbeddedServletContainerAutoConfiguration {

@Configuration
@ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖；
@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器
public static class EmbeddedTomcat {

    @Bean
    public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {
        return new TomcatEmbeddedServletContainerFactory();
    }

}
</code></pre>

<ul>
<li>EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</li>
<li>
<p><img src="./img/36.png" /></p>
<pre><code>public interface EmbeddedServletContainerFactory {

   //获取嵌入式的Servlet容器
   EmbeddedServletContainer getEmbeddedServletContainer(
         ServletContextInitializer... initializers);

}
</code></pre>

</li>
<li>EmbeddedServletContainer：（嵌入式的Servlet容器）</li>
<li><img src="./img/38.png" /></li>
<li>
<p>以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p>
<pre><code>@Override
public EmbeddedServletContainer getEmbeddedServletContainer(
      ServletContextInitializer... initializers) {
    //创建一个Tomcat
   Tomcat tomcat = new Tomcat();

    //配置Tomcat的基本环节
   File baseDir = (this.baseDirectory != null ? this.baseDirectory
         : createTempDir(&quot;tomcat&quot;));
   tomcat.setBaseDir(baseDir.getAbsolutePath());
   Connector connector = new Connector(this.protocol);
   tomcat.getService().addConnector(connector);
   customizeConnector(connector);
   tomcat.setConnector(connector);
   tomcat.getHost().setAutoDeploy(false);
   configureEngine(tomcat.getEngine());
   for (Connector additionalConnector : this.additionalTomcatConnectors) {
      tomcat.getService().addConnector(additionalConnector);
   }
   prepareContext(tomcat.getHost(), initializers);

    //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器
   return getTomcatEmbeddedServletContainer(tomcat);
}
</code></pre>

</li>
<li>
<p>我们对嵌入式容器的配置修改是怎么生效？</p>
<pre><code>ServerProperties、EmbeddedServletContainerCustomizer
</code></pre>

<ul>
<li><strong>EmbeddedServletContainerCustomizer(定制器)</strong>：定制器帮我们修改了Servlet容器的配置</li>
<li>
<p>原理：</p>
<pre><code>容器中导入了**EmbeddedServletContainerCustomizerBeanPostProcessor**
//初始化之前
@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
      throws BeansException {
    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件
   if (bean instanceof ConfigurableEmbeddedServletContainer) {
       //
      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);
   }
   return bean;
}

private void postProcessBeforeInitialization(
            ConfigurableEmbeddedServletContainer bean) {
    //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；
    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {
        customizer.customize(bean);
    }
}

private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() {
    if (this.customizers == null) {
        // Look up does not include the parent context
        this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(
            this.beanFactory
            //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer
            //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件
            .getBeansOfType(EmbeddedServletContainerCustomizer.class,
                            false, false)
            .values());
        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);
        this.customizers = Collections.unmodifiableList(this.customizers);
    }
    return this.customizers;
}

ServerProperties也是定制器
</code></pre>

</li>
<li>
步骤：
<ul>
<li>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</li>
<li>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；
只要是嵌入式的Servlet容器工厂，后置处理器就工作；</li>
<li>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>5）、嵌入式Servlet容器启动原理；</h3>
<p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p>
<p>获取嵌入式的Servlet容器工厂：</p>
<ul>
<li>
<p>1）、SpringBoot应用启动运行run方法</p>
</li>
<li>
<p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p>
</li>
<li>
<p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p>
<p>public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      prepareRefresh();</p>
<pre><code>  // Tell the subclass to refresh the internal bean factory.
  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

  // Prepare the bean factory for use in this context.
  prepareBeanFactory(beanFactory);

  try {
     // Allows post-processing of the bean factory in context subclasses.
     postProcessBeanFactory(beanFactory);

     // Invoke factory processors registered as beans in the context.
     invokeBeanFactoryPostProcessors(beanFactory);

     // Register bean processors that intercept bean creation.
     registerBeanPostProcessors(beanFactory);

     // Initialize message source for this context.
     initMessageSource();

     // Initialize event multicaster for this context.
     initApplicationEventMulticaster();

     // Initialize other special beans in specific context subclasses.
     onRefresh();

     // Check for listener beans and register them.
     registerListeners();

     // Instantiate all remaining (non-lazy-init) singletons.
     finishBeanFactoryInitialization(beanFactory);

     // Last step: publish corresponding event.
     finishRefresh();
  }

  catch (BeansException ex) {
     if (logger.isWarnEnabled()) {
        logger.warn(&quot;Exception encountered during context initialization - &quot; +
              &quot;cancelling refresh attempt: &quot; + ex);
     }

     // Destroy already created singletons to avoid dangling resources.
     destroyBeans();

     // Reset 'active' flag.
     cancelRefresh(ex);

     // Propagate exception to caller.
     throw ex;
  }

  finally {
     // Reset common introspection caches in Spring's core, since we
     // might not ever need metadata for singleton beans anymore...
     resetCommonCaches();
  }
</code></pre>

<p>}
}</p>
</li>
<li>
<p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p>
</li>
<li>
<p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p>
</li>
<li>
<p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p>
<ul>
<li>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</li>
<li>从ioc容器中获取EmbeddedServletContainerFactory 组件<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</li>
</ul>
</li>
<li>
<p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：</p>
<pre><code>this.embeddedServletContainer = containerFactory.getEmbeddedServletContainer(getSelfInitializer());
</code></pre>

</li>
<li>
<p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p>
</li>
<li>
<p>总结：</p>
<ul>
<li><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></li>
<li><strong>IOC容器启动创建嵌入式的Servlet容器</strong></li>
</ul>
</li>
</ul>
<h2>8、使用外置的Servlet容器</h2>
<p>嵌入式Servlet容器：应用打成可执行的jar</p>
<p>​		优点：简单、便携；</p>
<p>​		缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p>
<h3>快速生成webapp及web.xml文件</h3>
<ul>
<li>ctrl +shift + alt +s 进入项目结构目录</li>
<li><img src="./img/39.png" /></li>
</ul>
<h3>步骤</h3>
<h4>1. 必须创建一个war项目；（创建springboot项目时选择war）</h4>
<h4>2.将嵌入式的Tomcat指定为provided；(生成项目就配置好了)</h4>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
   &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<h4>3.必须编写一个<strong>SpringBootServletInitializer</strong>的子类，并调用configure方法</h4>
<pre><code>public class ServletInitializer extends SpringBootServletInitializer {

   @Override
   protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
       //传入SpringBoot应用的主程序
      return application.sources(SpringBoot04WebJspApplication.class);
   }
}
</code></pre>

<h4>4.启动服务器就可以使用；</h4>
<h3>原理</h3>
<p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p>
<p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>【SpringBootServletInitializer】，启动ioc容器；</p>
<p>servlet3.0</p>
<p>8.2.4 Shared libraries / runtimes pluggability：(pdf文件中的章节)</p>
<ul>
<li>
规则：
<ul>
<li>1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</li>
<li>2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</li>
<li>3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</li>
</ul>
</li>
<li>
<p>流程</p>
<ul>
<li>1）、启动Tomcat</li>
<li>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</li>
<li>Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></li>
<li>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；</li>
<li>4）、每一个WebApplicationInitializer都调用自己的onStartup；</li>
<li><img src="./img/37.png" /></li>
<li>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</li>
<li>
<p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p>
<pre><code>protected WebApplicationContext createRootApplicationContext(
      ServletContext servletContext) {
    //1、创建SpringApplicationBuilder
   SpringApplicationBuilder builder = createSpringApplicationBuilder();
   StandardServletEnvironment environment = new StandardServletEnvironment();
   environment.initPropertySources(servletContext, null);
   builder.environment(environment);
   builder.main(getClass());
   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);
   if (parent != null) {
      this.logger.info(&quot;Root context already created (using as parent).&quot;);
      servletContext.setAttribute(
            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);
      builder.initializers(new ParentContextApplicationContextInitializer(parent));
   }
   builder.initializers(
         new ServletContextApplicationContextInitializer(servletContext));
   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);

    //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来
   builder = configure(builder);

    //使用builder创建一个Spring应用
   SpringApplication application = builder.build();
   if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils
         .findAnnotation(getClass(), Configuration.class) != null) {
      application.getSources().add(getClass());
   }
   Assert.state(!application.getSources().isEmpty(),
         &quot;No SpringApplication sources have been defined. Either override the &quot;
               + &quot;configure method or add an @Configuration annotation&quot;);
   // Ensure error pages are registered
   if (this.registerErrorPageFilter) {
      application.getSources().add(ErrorPageFilterConfiguration.class);
   }
    //启动Spring应用
   return run(application);
}
</code></pre>

</li>
<li>
<p>7）、Spring的应用就启动并且创建IOC容器</p>
<pre><code>public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
   SpringApplicationRunListeners listeners = getRunListeners(args);
   listeners.starting();
   try {
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
      Banner printedBanner = printBanner(environment);
      context = createApplicationContext();
      analyzers = new FailureAnalyzers(context);
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);

       //刷新IOC容器
      refreshContext(context);
      afterRefresh(context, applicationArguments);
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}
</code></pre>

</li>
</ul>
</li>
<li>总结:<strong>启动Servlet容器，再启动SpringBoot应用</strong></li>
</ul>
<h1>9、Docker</h1>
<h2>1、简介</h2>
<p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p>
<p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。
先</p>
<h1>10.SpringBoot与数据访问</h1>
<h2>整合JDBC</h2>
<h3>导入依赖</h3>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<h3>配置yml文件</h3>
<pre><code>spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://192.168.6.133:3307/testjdbc
    driver-class-name: com.mysql.cj.jdbc.Driver
</code></pre>

<h3>效果</h3>
<ul>
<li>默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；(2.0以后就是用Hikari)</li>
<li>数据源的相关配置都在DataSourceProperties里面；</li>
</ul>
<h3>原理</h3>
<ul>
<li>所在包： org.springframework.boot.autoconfigure.jdbc：</li>
<li>参考DataSourceConfiguration，根据配置创建数据源，1.x默认使用Tomcat连接池；可以使用<strong>spring.datasource.type</strong>指定自定义的数据源类型；</li>
<li>
<p>SpringBoot默认可以支持；</p>
<pre><code>org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、
</code></pre>

</li>
<li>
<p>自定义数据源</p>
<pre><code>static class Generic {
    Generic() {
    }

    @Bean
    DataSource dataSource(DataSourceProperties properties) {
        //构建者模式，根据反射创建数据源，并绑定相关属性
        return properties.initializeDataSourceBuilder().build();
    }
}
</code></pre>

</li>
<li>
<p>DataSourceInitializer：ApplicationListener</p>
</li>
<li>
<p>作用：</p>
<ul>
<li>1）、runSchemaScripts();运行建表语句；</li>
<li>2）、runDataScripts();运行插入数据的sql语句；</li>
</ul>
</li>
<li>
<p>默认只需要将文件命名为：</p>
<pre><code>schema-*.sql、data-*.sql
默认规则：schema.sql，schema-all.sql；
可以使用   
    schema:
      - classpath:department.sql
      指定位置
</code></pre>

</li>
</ul>
<h3>使用druid数据源</h3>
<ul>
<li>
<p>先导入依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.22&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

</li>
<li>
<p>maven导包导不进来，Unable to import Maven project   See logs for details</p>
<ul>
<li>解决方法： idea的settings&gt;&gt;build,execution,Deployment&gt;&gt;Build Tools&gt;&gt;Maven&gt;&gt;importing的 JDK for importer 设置问题，我的默认设置是jre，但是jre不满足我们需要，所以要设置为jdk才好。</li>
</ul>
</li>
<li>
<p>新建一个配置类</p>
<pre><code>    @Configuration
    public class jdbcconfig {

        /把yml中的属性跟这个绑定
        @ConfigurationProperties(&quot;spring.datasource&quot;)
        @Bean
        public DataSource druid() {
            return  new DruidDataSource();
        }

    //    配置druid的监控
        //配置一个管理后台的servlet
        @Bean
        public ServletRegistrationBean statViewBean() {
            ServletRegistrationBean&lt;Servlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;);
            HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
            map.put(&quot;loginUsername&quot;, &quot;admin&quot;);
            map.put(&quot;loginPassword&quot;, &quot;123456&quot;);
            map.put(&quot;allow&quot;, &quot;&quot;);
            map.put(&quot;deny&quot;, &quot;192.168.6.139&quot;);

            bean.setInitParameters(map);
            return bean;
        }

        //配置一个web监控的filter
        @Bean
        public FilterRegistrationBean webStatFilter() {
            FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;();
            bean.setFilter(new WebStatFilter());

            HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
            map.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;);

            bean.setInitParameters(map);

            bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));

            return bean;
        }
    }
</code></pre>

</li>
</ul>
<h2>整合mybatis</h2>
<h3>注解版</h3>
<h5>导入依赖</h5>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h5>配置数据源相关属性，同上jdbc</h5>
<h5>正常使用mybatis</h5>
<pre><code>@Mapper
public interface DepartmentMapper {

    @Select(&quot;select *from department where id = #{id}&quot;)
    public Department queryById(Integer id);
</code></pre>

<h5>自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；</h5>
<ul>
<li>
<p>就是数据库列名带下划线，javabean中是大写的解决方法</p>
<pre><code>@org.springframework.context.annotation.Configuration
public class ConfigMybatis {

    @Bean
    public ConfigurationCustomizer configurationCustomizer() {
        return new ConfigurationCustomizer() {
            @Override
            public void customize(Configuration configuration) {
                configuration.setMapUnderscoreToCamelCase(true);
            }
        };
    }
}
</code></pre>

</li>
</ul>
<h5>当@mapper太多时，在启动类上加@MapperScan(&quot;com.hnguigu.springboot06.mapper&quot;)即可扫瞄所有mapper</h5>
<h3>配置文件版</h3>
<ul>
<li>
<p>加入下面配置即可</p>
<pre><code>mybatis:
  config-location: classpath:mybatis/mybatis-config.xml #全局配置文件路径
  mapper-locations: classpath:mybatis/mapper/*.xml #映射文件路径
</code></pre>

</li>
</ul>
<h2>整合springdata_JPA</h2>
<h3>编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</h3>
<pre><code>@Data
@Entity  //告诉jpa这不是普通的javabean，这是要和数据库映射的类
@Table(name = &quot;tbl_user&quot;)  //指定生成的表名，不指定则为user，用来指定和那张数据表映射
public class User {

    @Id //表明这是主键
    @GeneratedValue(strategy = GenerationType.IDENTITY) //表示主键自增
    private Integer id;
    @Column(name = &quot;last_name&quot;)  //表示和数据表对应的列
    private String lastName;
    @Column  //如果省略，属性名就是列名
    private String email;
}
</code></pre>

<h3>编写一个Dao接口来操作实体类对应的数据表（Repository）</h3>
<pre><code>//继承JpaRepository来完成对数据库的操作
public interface UserRepository extends JpaRepository&lt;User, Integer&gt; { //第一个是要操作的实体类对应的数据表，第二个是实体类主键的类型
}
</code></pre>

<h3>yml配置</h3>
<pre><code>  jpa:
    hibernate:
      ddl-auto: update #表示每次都更新或者创建表
    show-sql: true #控制台打印sql语句
</code></pre>

<h1>11，SpringBoot启动配置原理</h1>
<h2>几个重要的事件回调机制</h2>
<p>配置在META-INF/spring.factories</p>
<p><strong>ApplicationContextInitializer</strong></p>
<p><strong>SpringApplicationRunListener</strong></p>
<p>只需要放在ioc容器中</p>
<p><strong>ApplicationRunner</strong></p>
<p><strong>CommandLineRunner</strong></p>
<h2>启动流程</h2>
<h3>1、创建SpringApplication对象</h3>
<pre><code>initialize(sources);
private void initialize(Object[] sources) {
    //保存主配置类
    if (sources != null &amp;&amp; sources.length &gt; 0) {
        this.sources.addAll(Arrays.asList(sources));
    }
    //判断当前是否一个web应用
    this.webEnvironment = deduceWebEnvironment();
    //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来
    setInitializers((Collection) getSpringFactoriesInstances(
        ApplicationContextInitializer.class));
    //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    //从多个配置类中找到有main方法的主配置类
    this.mainApplicationClass = deduceMainApplicationClass();
}
</code></pre>

<h3>2、运行run方法</h3>
<pre><code>public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();

   //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories
   SpringApplicationRunListeners listeners = getRunListeners(args);
    //回调所有的获取SpringApplicationRunListener.starting()方法
   listeners.starting();
   try {
       //封装命令行参数
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      //准备环境
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
            //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成

      Banner printedBanner = printBanner(environment);

       //创建ApplicationContext；决定创建web的ioc还是普通的ioc
      context = createApplicationContext();

      analyzers = new FailureAnalyzers(context);
       //准备上下文环境;将environment保存到ioc中；而且applyInitializers()；
       //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法
       //回调所有的SpringApplicationRunListener的contextPrepared()；
       //
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
       //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；

       //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版
       //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）
      refreshContext(context);
       //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调
       //ApplicationRunner先回调，CommandLineRunner再回调
      afterRefresh(context, applicationArguments);
       //所有的SpringApplicationRunListener回调finished方法
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
       //整个SpringBoot应用启动完成以后返回启动的ioc容器；
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}
</code></pre>

<h3>3、事件监听机制</h3>
<p>先新建这个文件然后配置在META-INF/spring.factories</p>
<p><strong>ApplicationContextInitializer</strong></p>
<pre><code>public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        System.out.println(&quot;ApplicationContextInitializer...initialize...&quot;+applicationContext);
    }
}
</code></pre>

<p><strong>SpringApplicationRunListener</strong></p>
<pre><code>public class HelloSpringApplicationRunListener implements SpringApplicationRunListener {

    //必须有的构造器
    public HelloSpringApplicationRunListener(SpringApplication application, String[] args){

    }

    @Override
    public void starting() {
        System.out.println(&quot;SpringApplicationRunListener...starting...&quot;);
    }

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) {
        Object o = environment.getSystemProperties().get(&quot;os.name&quot;);
        System.out.println(&quot;SpringApplicationRunListener...environmentPrepared..&quot;+o);
    }

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) {
        System.out.println(&quot;SpringApplicationRunListener...contextPrepared...&quot;);
    }

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) {
        System.out.println(&quot;SpringApplicationRunListener...contextLoaded...&quot;);
    }

    @Override
    public void finished(ConfigurableApplicationContext context, Throwable exception) {
        System.out.println(&quot;SpringApplicationRunListener...finished...&quot;);
    }
}
</code></pre>

<p>配置（META-INF/spring.factories）</p>
<pre><code>org.springframework.context.ApplicationContextInitializer=\
com.atguigu.springboot.listener.HelloApplicationContextInitializer

org.springframework.boot.SpringApplicationRunListener=\
com.atguigu.springboot.listener.HelloSpringApplicationRunListener
</code></pre>

<p>只需要放在ioc容器中</p>
<p><strong>ApplicationRunner</strong></p>
<pre><code>@Component
public class HelloApplicationRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(&quot;ApplicationRunner...run....&quot;);
    }
}
</code></pre>

<p><strong>CommandLineRunner</strong></p>
<pre><code>@Component
public class HelloCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;CommandLineRunner...run...&quot;+ Arrays.asList(args));
    }
}
</code></pre>

<h1>12，自定义starter(场景启动器)</h1>
<h2>starter：</h2>
<h3>1、这个场景需要使用到的依赖是什么？</h3>
<h3>2、如何编写自动配置</h3>
<pre><code>@Configuration  //指定这个类是一个配置类
@ConditionalOnXXX  //在指定条件成立的情况下自动配置类生效
@AutoConfigureAfter  //指定自动配置类的顺序
@Bean  //给容器中添加组件

@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置
@EnableConfigurationProperties //让xxxProperties生效加入到容器中

自动配置类要能加载
将需要启动就加载的自动配置类，配置在META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
</code></pre>

<h3>3、模式：</h3>
<p>启动器只用来做依赖导入；</p>
<p>专门来写一个自动配置模块；</p>
<p>启动器依赖自动配置；别人只需要引入启动器（starter）</p>
<p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p>
<h3>4、步骤</h3>
<ul>
<li>
<p>1）、启动器模块</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt;
    &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;!--启动器--&gt;
    &lt;dependencies&gt;

        &lt;!--引入自动配置模块--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt;
            &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt;
            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>

</li>
<li>
<p>2）、自动配置模块</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

   &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt;
   &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt;
   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
   &lt;packaging&gt;jar&lt;/packaging&gt;

   &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt;
   &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

   &lt;parent&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
      &lt;version&gt;1.5.10.RELEASE&lt;/version&gt;
      &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
   &lt;/parent&gt;

   &lt;properties&gt;
      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
      &lt;java.version&gt;1.8&lt;/java.version&gt;
   &lt;/properties&gt;

   &lt;dependencies&gt;

      &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
      &lt;/dependency&gt;

   &lt;/dependencies&gt;

&lt;/project&gt;




package com.atguigu.starter;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = &quot;atguigu.hello&quot;)
public class HelloProperties {

    private String prefix;
    private String suffix;

    public String getPrefix() {
        return prefix;
    }

    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }

    public String getSuffix() {
        return suffix;
    }

    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }
}


package com.atguigu.starter;

public class HelloService {

    HelloProperties helloProperties;

    public HelloProperties getHelloProperties() {
        return helloProperties;
    }

    public void setHelloProperties(HelloProperties helloProperties) {
        this.helloProperties = helloProperties;
    }

    public String sayHellAtguigu(String name){
        return helloProperties.getPrefix()+&quot;-&quot; +name + helloProperties.getSuffix();
    }
}

package com.atguigu.starter;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnWebApplication //web应用才生效
@EnableConfigurationProperties(HelloProperties.class)
public class HelloServiceAutoConfiguration {

    @Autowired
    HelloProperties helloProperties;
    @Bean
    public HelloService helloService(){
        HelloService service = new HelloService();
        service.setHelloProperties(helloProperties);
        return service;
    }
}
</code></pre>

</li>
</ul>
<h1><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples">更多SpringBoot整合示例</a></h1>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
