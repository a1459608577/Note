<!DOCTYPE html>
<html>
<head>
<title>rabbitMQ</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<base href=''/>
</head>
<body>
<h1>RabbitMQ笔记</h1>
<h2><a href="https://www.rabbitmq.com/#getstarted">rabbitMQ官网</a></h2>
<h2><a href="https://blog.csdn.net/hellozpc/article/details/81436980">rabbitMQ笔记</a></h2>
<h2>安装，启动</h2>
<h3>安装Erlang(类似rabbitmq开发环境)</h3>
<p><img src="./img/1.png" /></p>
<h3>启动</h3>
<ul>
<li>刚安装好进入安装rabbitMQ的目录，
<img src="./img/2.png" /></li>
<li>
输入启动命令就可以在127.0.0.1：15672进入官网，使用<strong>guest/guest</strong>登录： 
<blockquote>
<p>第一次启动命令： rabbitmq-plugins enable rabbitmq_management </p>
<p>停止：net stop RabbitMQ </p>
<p>启动：net start RabbitMQ</p>
</blockquote>
</li>
</ul>
<h2>添加用户</h2>
<h3>添加admin用户</h3>
<p><img src="./img/3.png" /></p>
<h3>用户角色</h3>
<ul>
<li>1、超级管理员(<strong>administrator</strong>):可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li>
<li>2、监控者(<strong>monitoring</strong>)
可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li>
<li>3、策略制定者(<strong>policymaker</strong>)
可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</li>
<li>4、普通管理者(<strong>management</strong>)
仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</li>
<li>5、其他
无法登陆管理控制台，通常就是普通的生产者和消费者。</li>
</ul>
<h3>创建Virtual Hosts(相当于mysql的db数据库)</h3>
<h2><img src="./img/4.png" /></h2>
<h2><img src="./img/5.png" /></h2>
<p><img src="./img/6.png" /></p>
<h3>管理界面中的功能</h3>
<h2><img src="./img/7.png" /></h2>
<p><img src="./img/8.png" /></p>
<h2>学习五种队列</h2>
<p><img src="./img/9.png" /></p>
<h3>新建maven项目，导入依赖</h3>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
    &lt;version&gt;5.2.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;2.0.0-alpha1&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;version&gt;2.0.0-alpha1&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h3>1.简单队列(simple queue)</h3>
<p><img src="./img/10.png" /></p>
<h5>导入依赖</h5>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
   &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
   &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h5>获取MQ的连接</h5>
<pre><code>public static Connection getConnection() throws IOException, TimeoutException {
    //创建连接工厂
    ConnectionFactory factory = new ConnectionFactory();
    //设置服务地址
    factory.setHost(&quot;127.0.0.1&quot;);
    //设置AMQP协议端口
    factory.setPort(5672);
    //设置vhost
    factory.setVirtualHost(&quot;testHost&quot;);
    //设置登录用户名密码
    factory.setUsername(&quot;admin&quot;);
    factory.setPassword(&quot;1234&quot;);
    //返回
    return factory.newConnection();
}
</code></pre>

<h5>生产者发送消息到队列</h5>
<pre><code>private static final  String QUEUE_NAME=&quot;test_queue&quot;;
public static void main(String[] args) throws IOException, TimeoutException {
    //获取连接
    Connection connection = RabbitMqUtils.getConnection();
    //从连接中获取一个通道
    Channel channel = connection.createChannel();
    //s声明一个队列,就是往哪个队列里发消息
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    String msg = &quot;hello world&quot;;
    //发送消息
    channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());
    System.out.println(&quot;发送消息&quot; + msg);
    channel.close();
    connection.close();
}
</code></pre>

<h5>管理工具中查看消息</h5>
<p><img src="./img/11.png" /></p>
<h5>消费者从队列中获取消息</h5>
<ul>
<li>
<p>java老的api</p>
<pre><code>private static final  String QUEUE_NAME=&quot;test_queue&quot;;
public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
    //获取连接
    Connection connection = RabbitMqUtils.getConnection();
    //创建频道
    Channel channel = connection.createChannel();
    //定义队列的消费者
    QueueingConsumer consumer = new QueueingConsumer(channel);
    //监听队列
    channel.basicConsume(QUEUE_NAME,true,  consumer);
    while (true) {
        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
        byte[] body = delivery.getBody();
        String s = new String(body);
        System.out.println(&quot;收到消息&quot; + s);
    }
}
</code></pre>

</li>
<li>
<p>java新的api</p>
<pre><code>private static final  String QUEUE_NAME=&quot;test_queue&quot;;
public static void main(String[] args) throws Exception {
    //获取连接
    Connection connection = RabbitMqUtils.getConnection();
    //创建频道
    Channel channel = connection.createChannel();
    //队列声明
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        //一旦有消息 就会触发这个方法
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
            String s = new String(body);
            System.out.println(&quot;接收的信息&quot; + s);
        }
    };
    //监听队列
    channel.basicConsume(QUEUE_NAME,true,  consumer);
}
</code></pre>

</li>
</ul>
<h3>2.工作队列(work queue)</h3>
<p><img src="./img/12.png" /></p>
<h5>消费者1</h5>
<pre><code>private static final String QUEUE_NAME = &quot;workQueue&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    Channel channel = connection.createChannel();
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope,
                                   AMQP.BasicProperties properties, byte[] body) throws IOException {
            String s = new String(body);
            System.out.println(&quot;[1] 接收到的数据&quot; + s);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println(&quot;[1] done&quot;);
            }
        }
    };
    boolean autoAsk = true;
    channel.basicConsume(QUEUE_NAME, autoAsk, consumer);
}
</code></pre>

<h5>消费者2</h5>
<pre><code>private static final String QUEUE_NAME = &quot;workQueue&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    Channel channel = connection.createChannel();
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope,
                                   AMQP.BasicProperties properties, byte[] body) throws IOException {
            String s = new String(body);
            System.out.println(&quot;[2] 接收到的数据&quot; + s);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println(&quot;[2] done&quot;);
            }
        }
    };
    boolean autoAsk = true;
    channel.basicConsume(QUEUE_NAME, autoAsk, consumer);
}
</code></pre>

<h5>生产者1</h5>
<pre><code>private static final String QUEUE_NAME = &quot;workQueue&quot;;
public static void main(String[] args) throws Exception {
    //获取连接
    Connection connection = RabbitMqUtils.getConnection();
    //获取channel
    Channel channel = connection.createChannel();
    //声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    for (int i = 0; i &lt; 40; i++) {
        String msg = &quot;发出信息&quot; + i;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());
        Thread.sleep(i * 20);
    }
    channel.close();
    connection.close();
}
</code></pre>

<h5>测试结果</h5>
<ul>
<li>1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。</li>
<li>
2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。
<ul>
<li>其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。
RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。</li>
<li>怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。
basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。</li>
<li><strong>轮询分发</strong> ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。</li>
<li><strong>公平分发(fair dipatch)</strong> ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。<strong>使用公平分发必须关闭自动应答ack，改成手动</strong></li>
</ul>
</li>
<li>为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。
还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。</li>
</ul>
<h5>解决方法:work queue的能者多劳模式</h5>
<ul>
<li><img src="./img/13.png" /></li>
<li>
<p>消费者</p>
<pre><code>private static final String QUEUE_NAME = &quot;workQueue&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    final Channel channel = connection.createChannel();
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    channel.basicQos(1);  //保证每次之分发一个消息
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope,
                                   AMQP.BasicProperties properties, byte[] body) throws IOException {
            String s = new String(body);
            System.out.println(&quot;[1] 接收到的数据&quot; + s);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println(&quot;[1] done&quot;);
                channel.basicAck(envelope.getDeliveryTag(), false);   //手动发送一个回执告诉队列完成了
            }
        }
    };

    boolean autoAsk = false;  //自动应答改成false
    channel.basicConsume(QUEUE_NAME, autoAsk, consumer);
}
</code></pre>

</li>
</ul>
<h3>消息应答与消息持久化</h3>
<h4>消息应答</h4>
<pre><code>boolean autoAsk = false;
channel.basicConsume(QUEUE_NAME, autoAsk, consumer);
</code></pre>

<ul>
<li>当boolean autoAsk = true(自动模式)，表示开启自动应答，一旦rabbitmq把消息发给消费者就立即删除，如果把正在处理消息的消费者杀死，就会丢失数据</li>
<li>当boolean autoAsk = false(手动模式)，如果消费者挂掉，则把消息发给另一个消费者，rabbitmq支持消息应答，消费者发送一个消息回执给rabbitmq，rabbitmq就把内存中的消息删掉</li>
<li><strong>消息应答默认是开启的，就是默认为false</strong></li>
</ul>
<h4>消息持久化</h4>
<pre><code>//声明队列
boolean durable = false; //消息持久化
channel.queueDeclare(QUEUE_NAME, durable, false, false, null);
</code></pre>

<ul>
<li>将程序中的durable改成true是不可以的，rabbitmq不允许修改一个已经声明的队列</li>
</ul>
<h3>3.订阅模式(publish/subscribe)</h3>
<ul>
<li><img src="./img/14.png" /></li>
<li>
解读:
<ol>
<li>一个生产者，多个消费者</li>
<li>每一个消费者都有自己的队列</li>
<li>生产者没有直接把消息发给队列，而是发到交换机exchange</li>
<li>每个队列都要绑定到交换机上</li>
<li>生产者发送的消息进过交换机，经过队列，就能实现一个消息被多个消费者消费</li>
</ol>
</li>
</ul>
<h5>生产者</h5>
<pre><code>private static final String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    Channel channel = connection.createChannel();
    //声明交换机
    channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);
    String msg = &quot;hello exchange&quot;;
    channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, msg.getBytes());
    System.out.println(&quot;Send &quot; + msg);
    channel.close();
    connection.close();
}
</code></pre>

<ul>
<li><img src="./img/15.png" /></li>
<li>交换机生成了，，但是数据丢失，原因是：交换机咩没有存储能力，只有队列才有，还没有把队列跟交换机绑定，所以消息没了</li>
</ul>
<h5>消费者1(消费者2同下)</h5>
<pre><code>private static final String QUEUE_NAME = &quot;test_queue_fanout_email&quot;;
private static final String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    final Channel channel = connection.createChannel();
    //声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    //绑定队列到交换机
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);
    channel.basicQos(1);
    DefaultConsumer defaultConsumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
            String s = new String(body);
            System.out.println(&quot;[1] 收到消息&quot; + s);
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
    };
    channel.basicConsume(QUEUE_NAME, false, defaultConsumer);
}
</code></pre>

<h5>测试结果：同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。</h5>
<h3>Exchange(交换机)</h3>
<ul>
<li>一方面接受生产者的消息，一方面把消息推送给队列</li>
<li><img src="./img/16.png" /></li>
</ul>
<h5>Fanout(不处理路由键)</h5>
<ul>
<li><img src="./img/17.png" /></li>
</ul>
<h5>Direct处理路由键)</h5>
<ul>
<li><img src="./img/18.png" /></li>
</ul>
<h3>4.路由模式</h3>
<ul>
<li><img src="./img/19.png" /></li>
</ul>
<h5>生产者</h5>
<pre><code>private static final String EXCHANGE_NAME = &quot;test_exchange_direct&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    Channel channel = connection.createChannel();
    //设置交换机类型
    channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);
    String msg = &quot;hello direct&quot;;
    String routeKey = &quot;info&quot;;
    channel.basicPublish(EXCHANGE_NAME, routeKey, null, msg.getBytes());
    channel.close();
    connection.close();
}
</code></pre>

<h5>消费者1(消费者2同下，改动数字位置)</h5>
<pre><code>private static final String QUEUE_NAME = &quot;test_queue_direct_1&quot;;
private static final String EXCHANGE_NAME = &quot;test_exchange_direct&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    final Channel channel = connection.createChannel();
    channel.basicQos(1);
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;error&quot;);
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
            String s = new String(body);
            System.out.println(&quot;[1] 接收信息&quot; + s);
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
    };
    channel.basicConsume(QUEUE_NAME, false, consumer);
}
</code></pre>

<h3>5. 主题模式（通配符模式）</h3>
<ul>
<li><img src="./img/20.png" /></li>
</ul>
<h5>topic exchange：将路由键与某模式匹配</h5>
<ul>
<li><strong>#：</strong>匹配一个或者多个，可以零个</li>
<li>*<strong>:</strong>匹配一个</li>
</ul>
<h5>生产者</h5>
<pre><code>private static final String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    Channel channel = connection.createChannel();
    channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);
    String msg  = &quot;hello topic&quot;;
    String routeKey = &quot;Goods.delete.add&quot;;
    channel.basicPublish(EXCHANGE_NAME, routeKey, null, msg.getBytes());
    System.out.println(&quot;---send---&quot; + msg);
    channel.close();
    connection.close();
}   
</code></pre>

<h5>消费者</h5>
<pre><code>private static final String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;
private static final String QUEUE_NAME = &quot;test_queue_topic_1&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    final Channel channel = connection.createChannel();
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;Goods.*&quot;);
    channel.basicQos(1);
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
            String s = new String(body);
            System.out.println(&quot;[1] 收到消息&quot; + s);
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
    };
    channel.basicConsume(QUEUE_NAME, false, consumer);
}
</code></pre>

<h3>rabbitmq中的消息确认机制(事务+confirm)</h3>
<ul>
<li>在rabbitmq中可以通过持久化数据解决rabbitmq服务器异常的数据丢失问题</li>
<li>
问题： 生产者将消息发出后，消息到底有没有到达rabbitmq服务器，默认情况下是不知道的
<ul>
<li>
解决方法： 
<ul>
<li>AMQP实现事务机制</li>
<li>Confirm模式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>事务机制(txSelect,txCommit, txRollback)</h4>
<ul>
<li><strong>txSelect:</strong>将当前的channel设置成transation模式</li>
<li><strong>txCommit：</strong>提交事务</li>
<li><strong>txRollback：</strong>回滚事务</li>
</ul>
<h5>生产者(消费者正常接收)</h5>
<pre><code>private static final String QUEUE_NAME = &quot;test_queue_tx&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    Channel channel = connection.createChannel();
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    String msg = &quot;hello tx&quot;;
    try {
        channel.txSelect();
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());
        int a = 1/0;
        channel.txCommit();
    } catch (Exception e) {
        e.printStackTrace();
        channel.txRollback();
        System.out.println(&quot;出现错误，回滚信息&quot;);
    }
    channel.close();
    connection.close();
}
</code></pre>

<h4>Confirm模式</h4>
<ul>
<li>
开启confirm模式： <strong>channel.confirmSelect()</strong>
<ul>
<li>
编程模式：
<ol>
<li>普通的 发一条 调用waitForConfirms()</li>
<li>批量的 发一批 调用waitForConfirms()</li>
<li>异步confirm模式： 提供一个回调方法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5>confirm普通模式(单条)</h5>
<pre><code>private static final String QUEUE_NAME = &quot;test_confirm01&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    Channel channel = connection.createChannel();
    //生产者调用confirmSelect() ，将channel设置成confirm模式
    channel.confirmSelect();
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    String msg = &quot;hello confirm&quot;;
    channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());

    if (!channel.waitForConfirms()) {
        System.out.println(&quot;发送失败&quot;);
    } else {
        System.out.println(&quot;发送成功&quot;);
    }
    channel.close();
    connection.close();
}
</code></pre>

<h5>confirm普通模式(批量)</h5>
<pre><code>private static final String QUEUE_NAME = &quot;test_confirm01&quot;;
public static void main(String[] args) throws Exception {
    Connection connection = RabbitMqUtils.getConnection();
    Channel channel = connection.createChannel();
    //生产者调用confirmSelect() ，将channel设置成confirm模式
    channel.confirmSelect();
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    for (int i=0; i &lt; 10; i++) {
        //批量发送
        String msg = &quot;hello confirm&quot; + i;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());
    }
    int i = 1/0;
    //确认消息
    if (!channel.waitForConfirms()) {
        System.out.println(&quot;发送失败&quot;);
    } else {
        System.out.println(&quot;发送成功&quot;);
    }
    channel.close();
    connection.close();
}
</code></pre>

<h5>confirm异步模式</h5>
<ul>
<li><img src="./img/22.png" /></li>
</ul>
<h4>生产者端Confirm模式的实现原理</h4>
<ul>
<li><img src="./img/21.png" /></li>
</ul>
<h2>spring整合rabbitMQ</h2>
<h4>配置文件</h4>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/rabbit
   http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd
   http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-4.1.xsd&quot;&gt;

    &lt;!-- 定义RabbitMQ的连接工厂 --&gt;
    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;127.0.0.1&quot; port=&quot;5672&quot;
                               username=&quot;admin&quot; password=&quot;1234&quot;
                               virtual-host=&quot;testHost&quot;
    &gt;&lt;/rabbit:connection-factory&gt;

    &lt;!-- 定义Rabbit模板，指定连接工厂以及定义exchange(exchange要和上面的一致) 发送到交换机就是exchange=&quot;&quot;，
    发送到队列就是Queue=&quot;&quot;, 可以使用route-key绑定key--&gt;
    &lt;rabbit:template id=&quot;amqpTemplate&quot; connection-factory=&quot;connectionFactory&quot; exchange=&quot;fanoutExchange&quot;&gt;&lt;/rabbit:template&gt;
    &lt;!--    &lt;rabbit:template id=&quot;amqpTemplate&quot; connection-factory=&quot;connectionFactory&quot; exchange=&quot;fanoutExchange&quot;&gt;&lt;/rabbit:template&gt;--&gt;
    &lt;!--    &lt;rabbit:template id=&quot;amqpTemplate&quot; connection-factory=&quot;connectionFactory&quot; exchange=&quot;topicExchange&quot;&gt;&lt;/rabbit:template&gt;--&gt;

    &lt;!-- MQ的管理，包括队列、交换器等 --&gt;
    &lt;rabbit:admin connection-factory=&quot;connectionFactory&quot;&gt;&lt;/rabbit:admin&gt;

    &lt;!-- 定义B系统需要监听的队列，自动声明 --&gt;
    &lt;rabbit:queue name=&quot;q_topic_testB&quot; auto-declare=&quot;true&quot;&gt;&lt;/rabbit:queue&gt;

    &lt;!-- 定义交换器，暂时不把Q绑定到交换机，在管理界面去绑定 --&gt;
&lt;!--    &lt;rabbit:topic-exchange name=&quot;topicExchange&quot; auto-declare=&quot;true&quot;&gt;&lt;/rabbit:topic-exchange&gt;--&gt;
    &lt;rabbit:fanout-exchange name=&quot;fanoutExchange&quot; auto-declare=&quot;true&quot;&gt;
        &lt;rabbit:bindings&gt;
            &lt;rabbit:binding queue=&quot;q_topic_testB&quot;&gt;&lt;/rabbit:binding&gt;
        &lt;/rabbit:bindings&gt;
    &lt;/rabbit:fanout-exchange&gt;
&lt;!--    &lt;rabbit:direct-exchange name=&quot;directExchange&quot; auto-declare=&quot;true&quot;&gt;&lt;/rabbit:direct-exchange&gt;--&gt;

&lt;!--定义消费者--&gt;
    &lt;bean id=&quot;recevie1&quot; class=&quot;com.hnguigu.rabbit.Recevie1&quot;&gt;&lt;/bean&gt;

&lt;!--监听--&gt;
    &lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot;&gt;
        &lt;rabbit:listener ref=&quot;recevie1&quot; method=&quot;listen&quot; queue-names=&quot;q_topic_testB&quot;&gt;&lt;/rabbit:listener&gt;
    &lt;/rabbit:listener-container&gt;

&lt;/beans&gt;
</code></pre>

<h4>生产者</h4>
<pre><code>public static void main(String[] args) throws Exception {
    //读取配置文件
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:rabbitContext.xml&quot;);
    //rabbit模板
    RabbitTemplate bean = context.getBean(RabbitTemplate.class);

    String format = new SimpleDateFormat(&quot;yyyy-mm-dd&quot;).format(new Date());
    //发送消息
    HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
    map.put(&quot;name&quot;, &quot;zhangsan&quot;);
    map.put(&quot;age&quot;, 1);
    map.put(&quot;date&quot;, format);
    bean.convertAndSend(JSON.toJSONString(map));
//        bean.convertAndSend(&quot;type2&quot;, JSON.toJSONString(map));
    Thread.sleep(1000);//休眠一秒
    context.destroy(); //销毁容器
}
</code></pre>

<h2>SpringBoot整合rabbitMQ</h2>
<h4>rabbitmqautoconfigure中的自动配置</h4>
<ul>
<li>自动配置连接工厂ConnectionFactory</li>
<li>Rabbitproperties封装了rabbit的配置</li>
<li>RabbitTemplate，给rabbitMQ发送和接收消息</li>
<li>
AmqpAdmin： rabbitmq系统管理功能组件
<ul>
<li>AmqpAdmin：创建和删除queue，exchange， bingding</li>
</ul>
</li>
<li>
@RabbitListener + @EnableRabbit
<ul>
<li><strong>@RabbitListener:</strong>表示监听队列，作用在方法上，一旦这个队收到消息就会调用方法</li>
<li><strong>@EnableRabbit：</strong>表示开启对rabbitmq注解的支持</li>
</ul>
</li>
</ul>
<h4>生产者(简单队列)</h4>
<pre><code>//    单播，点对点(发送)
    @Test
    void contextLoads() {
//        message需要自己构建，
//        rabbitTemplate.send(Exchange, routeKey, message)；
//        object默认当成消息体只需要传入要发送的对象，默认把obj当成消息体
//        rabbitTemplate.convertAndSend(Exchange, routeKey, Object);
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;age&quot;, 1);
        map.put(&quot;arr&quot;, Arrays.asList(&quot;asdf&quot;, 123, true));
        rabbitTemplate.convertAndSend(&quot;e_topic_testB&quot;, &quot;good&quot;, map);
    }
</code></pre>

<h4>生产者(广播模式)</h4>
<pre><code>//    广播模式
@Test
public void fanout() {
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;age&quot;, 1);
    map.put(&quot;arr&quot;, Arrays.asList(&quot;asdf&quot;, 123, true));
    rabbitTemplate.convertAndSend(&quot;e_fanout_testB&quot;, &quot;&quot;, map);
}
</code></pre>

<h4>消费者</h4>
<pre><code>//    (接收)
@Test
public void recevie1() {
    //用这个会把消息转成含有消息头和消息体的Message对象
//        rabbitTemplate.receive();

//        直接拿到收到的消息 会把消息体转成想要的对象
//        rabbitTemplate.receiveAndConvert();

    Object o = rabbitTemplate.receiveAndConvert(&quot;q_topic_testB&quot;);
    System.out.println(o.getClass());
    System.out.println(&quot;[1] 接收到的消息:&quot; + o);
}
</code></pre>

<h4>使用amqpadmin进行创建删除</h4>
<pre><code>//    使用amqpadmin创建删除queue，exchange
@Test   //创建exchange
public void amqoadmin1() {
    amqpAdmin.declareExchange(new DirectExchange(&quot;amqp.directExchange&quot;));
    System.out.println(&quot;创建exchange成功&quot;);
}

@Test  //创建queue
public void amqoadmin2() {
    amqpAdmin.declareQueue(new Queue(&quot;amqp_queue&quot;));
    System.out.println(&quot;创建queue成功&quot;);
}

@Test //创建绑定规则
public void amqoadmin3() {
    amqpAdmin.declareBinding(new Binding(&quot;amqp_queue&quot;, Binding.DestinationType.QUEUE, &quot;amqp.directExchange&quot;, &quot;good&quot;, null));
    System.out.println(&quot;binding成功&quot;);
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
