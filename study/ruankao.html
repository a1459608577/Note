<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>软考</title><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-require-zoom-fix foreignobject { font-size: var(--mermaid-font-zoom); }


:root {
  --mermaid-theme: night;
  --node-fill: #BDD5EA;
}

[lang='mermaid'] .label {
  color: #333;
}

/* CSS Document */

/** code highlight */

.cm-s-inner .cm-variable,
.cm-s-inner .cm-operator,
.cm-s-inner .cm-property {
    color: #b8bfc6;
}

.cm-s-inner .cm-keyword {
    color: #C88FD0;
}

.cm-s-inner .cm-tag {
    color: #7DF46A;
}

.cm-s-inner .cm-attribute {
    color: #7575E4;
}

.CodeMirror div.CodeMirror-cursor {
    border-left: 1px solid #b8bfc6;
    z-index: 3;
}

.cm-s-inner .cm-string {
    color: #D26B6B;
}

.cm-s-inner .cm-comment,
.cm-s-inner.cm-comment {
    color: #DA924A;
}

.cm-s-inner .cm-header,
.cm-s-inner .cm-def,
.cm-s-inner.cm-header,
.cm-s-inner.cm-def {
    color: #8d8df0;
}

.cm-s-inner .cm-quote,
.cm-s-inner.cm-quote {
    color: #57ac57;
}

.cm-s-inner .cm-hr {
    color: #d8d5d5;
}

.cm-s-inner .cm-link {
    color: #d3d3ef;
}

.cm-s-inner .cm-negative {
    color: #d95050;
}

.cm-s-inner .cm-positive {
    color: #50e650;
}

.cm-s-inner .cm-string-2 {
    color: #f50;
}

.cm-s-inner .cm-meta,
.cm-s-inner .cm-qualifier {
    color: #b7b3b3;
}

.cm-s-inner .cm-builtin {
    color: #f3b3f8;
}

.cm-s-inner .cm-bracket {
    color: #997;
}

.cm-s-inner .cm-atom,
.cm-s-inner.cm-atom {
    color: #84B6CB;
}

.cm-s-inner .cm-number {
    color: #64AB8F;
}

.cm-s-inner .cm-variable {
    color: #b8bfc6;
}

.cm-s-inner .cm-variable-2 {
    color: #9FBAD5;
}

.cm-s-inner .cm-variable-3 {
    color: #1cc685;
}

.CodeMirror-selectedtext,
.CodeMirror-selected {
    background: #4a89dc;
    color: #fff !important;
    text-shadow: none;
}

.CodeMirror-gutters {
    border-right: none;
}

/* CSS Document */

/** markdown source **/
.cm-s-typora-default .cm-header, 
.cm-s-typora-default .cm-property
{
    color: #cebcca;
}

.CodeMirror.cm-s-typora-default div.CodeMirror-cursor{
    border-left: 3px solid #b8bfc6;
}

.cm-s-typora-default .cm-comment {
    color: #9FB1FF;
}

.cm-s-typora-default .cm-string {
    color: #A7A7D9
}

.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number {
    color: #848695;
    font-style: italic;
}

.cm-s-typora-default .cm-link {
    color: #95B94B;
}

.cm-s-typora-default .CodeMirror-activeline-background {
    background: rgba(51, 51, 51, 0.72);
}

.cm-s-typora-default .cm-comment, .cm-s-typora-default .cm-code {
	color: #8aa1e1;
}@import "";
@import "";
@import "";

:root {
    --bg-color:  #363B40;
    --side-bar-bg-color: #2E3033;
    --text-color: #b8bfc6;

    --select-text-bg-color:#4a89dc;

    --item-hover-bg-color: #0a0d16;
    --control-text-color: #b7b7b7;
    --control-text-hover-color: #eee;
    --window-border: 1px solid #555;

    --active-file-bg-color: rgb(34, 34, 34);
    --active-file-border-color: #8d8df0;

    --primary-color: #a3d5fe;

    --active-file-text-color: white;
    --item-hover-bg-color: #70717d;
    --item-hover-text-color: white;
    --primary-color: #6dc1e7;

    --rawblock-edit-panel-bd: #333;

    --search-select-bg-color: #428bca;
}

html {
    font-size: 16px;
}

html,
body {
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
    background: #363B40;
    background: var(--bg-color);
    fill: currentColor;
    line-height: 1.625rem;
}

#write {
    max-width: 914px;
}


@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

html,
body,
button,
input,
select,
textarea,
div.code-tooltip-content {
    color: #b8bfc6;
    border-color: transparent;
}

div.code-tooltip,
.md-hover-tip .md-arrow:after {
    background: #333;
}

.popover.bottom > .arrow:after {
    border-bottom-color: #333;
}

html,
body,
button,
input,
select,
textarea {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

hr {
    height: 2px;
    border: 0;
    margin: 24px 0 !important;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: "Lucida Grande", "Corbel", sans-serif;
    font-weight: normal;
    clear: both;
    -ms-word-wrap: break-word;
    word-wrap: break-word;
    margin: 0;
    padding: 0;
    color: #DEDEDE
}

h1 {
    font-size: 2.5rem;
    /* 36px */
    line-height: 2.75rem;
    /* 40px */
    margin-bottom: 1.5rem;
    /* 24px */
    letter-spacing: -1.5px;
}

h2 {
    font-size: 1.63rem;
    /* 24px */
    line-height: 1.875rem;
    /* 30px */
    margin-bottom: 1.5rem;
    /* 24px */
    letter-spacing: -1px;
    font-weight: bold;
}

h3 {
    font-size: 1.17rem;
    /* 18px */
    line-height: 1.5rem;
    /* 24px */
    margin-bottom: 1.5rem;
    /* 24px */
    letter-spacing: -1px;
    font-weight: bold;
}

h4 {
    font-size: 1.12rem;
    /* 16px */
    line-height: 1.375rem;
    /* 22px */
    margin-bottom: 1.5rem;
    /* 24px */
    color: white;
}

h5 {
    font-size: 0.97rem;
    /* 16px */
    line-height: 1.25rem;
    /* 22px */
    margin-bottom: 1.5rem;
    /* 24px */
    font-weight: bold;
}

h6 {
    font-size: 0.93rem;
    /* 16px */
    line-height: 1rem;
    /* 16px */
    margin-bottom: 0.75rem;
    color: white;
}

@media (min-width: 980px) {
    h3.md-focus:before,
    h4.md-focus:before,
    h5.md-focus:before,
    h6.md-focus:before {
        color: #ddd;
        border: 1px solid #ddd;
        border-radius: 3px;
        position: absolute;
        left: -1.642857143rem;
        top: .357142857rem;
        float: left;
        font-size: 9px;
        padding-left: 2px;
        padding-right: 2px;
        vertical-align: bottom;
        font-weight: normal;
        line-height: normal;
    }

    h3.md-focus:before {
        content: 'h3';
    }

    h4.md-focus:before {
        content: 'h4';
    }

    h5.md-focus:before {
        content: 'h5';
        top: 0px;
    }

    h6.md-focus:before {
        content: 'h6';
        top: 0px;
    }
}

a {
    text-decoration: none;
    outline: 0;
}

a:hover {
    outline: 0;
}

a:focus {
    outline: thin dotted;
}

sup.md-footnote {
    background-color: #555;
    color: #ddd;
}

p {
    -ms-word-wrap: break-word;
    word-wrap: break-word;
}

p,
ul,
dd,
ol,
hr,
address,
pre,
table,
iframe,
.wp-caption,
.wp-audio-shortcode,
.wp-video-shortcode {
    margin-top: 0;
    margin-bottom: 1.5rem;
    /* 24px */
}

audio:not([controls]) {
    display: none;
}

[hidden] {
    display: none;
}

::-moz-selection {
    background: #4a89dc;
    color: #fff;
    text-shadow: none;
}

*.in-text-selection,
::selection {
    background: #4a89dc;
    color: #fff;
    text-shadow: none;
}

ul,
ol {
    padding: 0 0 0 1.875rem;
    /* 30px */
}

ul {
    list-style: square;
}

ol {
    list-style: decimal;
}

ul ul,
ol ol,
ul ol,
ol ul {
    margin: 0;
}

b,
th,
dt,
strong {
    font-weight: bold;
}

i,
em,
dfn,
cite {
    font-style: italic;
}

blockquote {
    padding-left: 1.875rem;
    margin: 0 0 1.875rem 1.875rem;
    border-left: solid 2px #474d54;
    padding-left: 30px;
    margin-top: 35px;
}

pre,
code,
kbd,
tt,
var {
    font-size: 0.875rem;
    font-family: Monaco, Consolas, "Andale Mono", "DejaVu Sans Mono", monospace;
}

code,
tt,
var {
    background: rgba(0, 0, 0, 0.05);
}

kbd {
    padding: 2px 4px;
    font-size: 90%;
    color: #fff;
    background-color: #333;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 rgba(0,0,0,.25);
}

pre.md-fences {
    padding: 10px 10px 10px 30px;
    margin-bottom: 20px;
    background: #333;
}

.CodeMirror-gutters {
    background: #333;
    border-right: 1px solid transparent;
}

.enable-diagrams pre.md-fences[lang="sequence"] .code-tooltip,
.enable-diagrams pre.md-fences[lang="flow"] .code-tooltip,
.enable-diagrams pre.md-fences[lang="mermaid"] .code-tooltip {
    bottom: -2.2em;
    right: 4px;
}

code,
kbd,
tt,
var {
    padding: 2px 5px;
}

table {
    max-width: 100%;
    width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
}

th,
td {
    padding: 5px 10px;
    vertical-align: top;
}

a {
    -webkit-transition: all .2s ease-in-out;
    transition: all .2s ease-in-out;
}

hr {
    background: #474d54;
    /* variable */
}

h1 {
    margin-top: 2em;
}

a {
    color: #e0e0e0;
    text-decoration: underline;
}

a:hover {
    color: #fff;
}

.md-inline-math script {
    color: #81b1db;
}

b,
th,
dt,
strong {
    color: #DEDEDE;
    /* variable */
}

mark {
    background: #D3D40E;
}

blockquote {
    color: #9DA2A6;
}

table a {
    color: #DEDEDE;
    /* variable */
}

th,
td {
    border: solid 1px #474d54;
    /* variable */
}

.task-list {
    padding-left: 0;
}

.md-task-list-item {
    padding-left: 1.25rem;
}

.md-task-list-item > input {
    top: auto;
}

.md-task-list-item > input:before {
    content: "";
    display: inline-block;
    width: 0.875rem;
    height: 0.875rem;
    vertical-align: middle;
    text-align: center;
    border: 1px solid #b8bfc6;
    background-color: #363B40;
    margin-top: -0.4rem;
}

.md-task-list-item > input:checked:before,
.md-task-list-item > input[checked]:before {
    content: '\221A';
    /*◘*/
    font-size: 0.625rem;
    line-height: 0.625rem;
    color: #DEDEDE;
}

/** quick open **/
.auto-suggest-container {
    border: 0px;
    background-color: #525C65;
}

#typora-quick-open {
    background-color: #525C65;
}

#typora-quick-open input{
    background-color: #525C65;
    border: 0;
    border-bottom: 1px solid grey;
}

.typora-quick-open-item {
    background-color: inherit;
    color: inherit;
}

.typora-quick-open-item.active,
.typora-quick-open-item:hover {
    background-color: #4D8BDB;
    color: white;
}

.typora-quick-open-item:hover {
    background-color: rgba(77, 139, 219, 0.8);
}

.typora-search-spinner > div {
  background-color: #fff;
}

#write pre.md-meta-block {
    border-bottom: 1px dashed #ccc;
    background: transparent;
    padding-bottom: 0.6em;
    line-height: 1.6em;
}

.btn,
.btn .btn-default {
    background: transparent;
    color: #b8bfc6;
}

.ty-table-edit {
    border-top: 1px solid gray;
    background-color: #363B40;
}

.popover-title {
    background: transparent;
}

.md-image>.md-meta {
    color: #BBBBBB;
    background: transparent;
}

.md-expand.md-image>.md-meta {
    color: #DDD;
}

#write>h3:before,
#write>h4:before,
#write>h5:before,
#write>h6:before {
    border: none;
    border-radius: 0px;
    color: #888;
    text-decoration: underline;
    left: -1.4rem;
    top: 0.2rem;
}

#write>h3.md-focus:before {
    top: 2px;
}

#write>h4.md-focus:before {
    top: 2px;
}

.md-toc-item {
    color: #A8C2DC;
}

#write div.md-toc-tooltip {
    background-color: #363B40;
}

.dropdown-menu .btn:hover,
.dropdown-menu .btn:focus,
.md-toc .btn:hover,
.md-toc .btn:focus {
    color: white;
    background: black;
}

#toc-dropmenu {
    background: rgba(50, 54, 59, 0.93);
    border: 1px solid rgba(253, 253, 253, 0.15);
}

#toc-dropmenu .divider {
    background-color: #9b9b9b;
}

.outline-expander:before {
    top: 2px;
}

#typora-sidebar {
    box-shadow: none;
    border-right: 1px dashed;
    border-right: none;
}

.sidebar-tabs {
    border-bottom:0;
}

#typora-sidebar:hover .outline-title-wrapper {
    border-left: 1px dashed;
}

.outline-title-wrapper .btn {
    color: inherit;
}

.outline-item:hover {
    border-color: #363B40;
    background-color: #363B40;
    color: white;
}

h1.md-focus .md-attr,
h2.md-focus .md-attr,
h3.md-focus .md-attr,
h4.md-focus .md-attr,
h5.md-focus .md-attr,
h6.md-focus .md-attr,
.md-header-span .md-attr {
    color: #8C8E92;
    display: inline;
}

.md-comment {
    color: #5a95e3;
    opacity: 1;
}

.md-inline-math svg {
    color: #b8bfc6;
}

#math-inline-preview .md-arrow:after {
    background: black;
}

.modal-content {
    background: var(--bg-color);
    border: 0;
}

.modal-title {
    font-size: 1.5em;
}

.modal-content input {
    background-color: rgba(26, 21, 21, 0.51);
    color: white;
}

.modal-content .input-group-addon {
    color: white;
}

.modal-backdrop {
    background-color: rgba(174, 174, 174, 0.7);
}

.modal-content .btn-primary {
    border-color: var(--primary-color);
}

.md-table-resize-popover {
    background-color: #333;
}

.form-inline .input-group .input-group-addon {
    color: white;
}

#md-searchpanel {
    border-bottom: 1px dashed grey;
}

/** UI for electron */

.context-menu,
#spell-check-panel,
#footer-word-count-info {
    background-color: #42464A;
}

.context-menu.dropdown-menu .divider,
.dropdown-menu .divider {
    background-color: #777777;
}

footer {
    color: inherit;
}

@media (max-width: 1000px) {
    footer {
        border-top: none;
    }
    footer:hover {
        color: inherit;
    }
}

#file-info-file-path .file-info-field-value:hover {
    background-color: #555;
    color: #dedede;
}

.megamenu-content,
.megamenu-opened header {
    background: var(--bg-color);
}

.megamenu-menu-panel h2,
.megamenu-menu-panel h1,
.long-btn {
    color: inherit;
}

.megamenu-menu-panel input[type='text'] {
    background: inherit;
    border: 0;
    border-bottom: 1px solid;
}

#recent-file-panel-action-btn {
    background: inherit;
    border: 1px grey solid;
}

.megamenu-menu-panel .dropdown-menu > li > a {
    color: inherit;
    background-color: #2F353A;
    text-decoration: none;
}

.megamenu-menu-panel table td:nth-child(1) {
    color: inherit;
    font-weight: bold;
}

.megamenu-menu-panel tbody tr:hover td:nth-child(1) {
    color: white;
}

.modal-footer .btn-default, 
.modal-footer .btn-primary,
.modal-footer .btn-default:not(:hover) {
    border: 1px solid;
    border-color: transparent;
}

.btn-primary {
    color: white;
}

.btn-default:hover, .btn-default:focus, .btn-default.focus, .btn-default:active, .btn-default.active, .open > .dropdown-toggle.btn-default {
    color: white;
    border: 1px solid #ddd;
    background-color: inherit;
}

.modal-header {
    border-bottom: 0;
}

.modal-footer {
    border-top: 0;
}

#recent-file-panel tbody tr:nth-child(2n-1) {
    background-color: transparent !important;
}

.megamenu-menu-panel tbody tr:hover td:nth-child(2) {
    color: inherit;
}

.megamenu-menu-panel .btn {
    border: 1px solid #eee;
    background: transparent;
}

.mouse-hover .toolbar-icon.btn:hover,
#w-full.mouse-hover,
#w-pin.mouse-hover {
    background-color: inherit;
}

.typora-node::-webkit-scrollbar {
    width: 5px;
}

.typora-node::-webkit-scrollbar-thumb:vertical {
    background: rgba(250, 250, 250, 0.3);
}

.typora-node::-webkit-scrollbar-thumb:vertical:active {
    background: rgba(250, 250, 250, 0.5);
}

#w-unpin {
    background-color: #4182c4;
}

#top-titlebar, #top-titlebar * {
    color: var(--item-hover-text-color);
}

.typora-sourceview-on #toggle-sourceview-btn,
#footer-word-count:hover,
.ty-show-word-count #footer-word-count {
    background: #333333;
}

#toggle-sourceview-btn:hover {
    color: #eee;
    background: #333333;
}

/** focus mode */
.on-focus-mode .md-end-block:not(.md-focus):not(.md-focus-container) * {
    color: #686868 !important;
}

.on-focus-mode .md-end-block:not(.md-focus) img,
.on-focus-mode .md-task-list-item:not(.md-focus-container)>input {
    opacity: #686868 !important;
}

.on-focus-mode li[cid]:not(.md-focus-container){
    color: #686868;
}

.on-focus-mode .md-fences.md-focus .CodeMirror-code>*:not(.CodeMirror-activeline) *,
.on-focus-mode .CodeMirror.cm-s-inner:not(.CodeMirror-focused) * {
    color: #686868 !important;
}

.on-focus-mode .md-focus,
.on-focus-mode .md-focus-container {
    color: #fff;
}

.on-focus-mode #typora-source .CodeMirror-code>*:not(.CodeMirror-activeline) * {
    color: #686868 !important;
}


/*diagrams*/
#write .md-focus .md-diagram-panel {
    border: 1px solid #ddd;
    margin-left: -1px;
    width: calc(100% + 2px);
}

/*diagrams*/
#write .md-focus.md-fences-with-lineno .md-diagram-panel {
    margin-left: auto;
}

.md-diagram-panel-error {
    color: #f1908e;
}

.active-tab-files #info-panel-tab-file,
.active-tab-files #info-panel-tab-file:hover,
.active-tab-outline #info-panel-tab-outline,
.active-tab-outline #info-panel-tab-outline:hover {
    color: #eee;
}

.sidebar-footer-item:hover,
.footer-item:hover {
    background: inherit;
    color: white;
}

.ty-side-sort-btn.active,
.ty-side-sort-btn:hover,
.selected-folder-menu-item a:after {
    color: white;
}

#sidebar-files-menu {
    border:solid 1px;
    box-shadow: 4px 4px 20px rgba(0, 0, 0, 0.79);
    background-color: var(--bg-color);
}

.file-list-item {
    border-bottom:none;
}

.file-list-item-summary {
    opacity: 1;
}

.file-list-item.active:first-child {
    border-top: none;
}

.file-node-background {
    height: 32px;
}

.file-library-node.active>.file-node-content,
.file-list-item.active {
    color: white;
    color: var(--active-file-text-color);
}

.file-library-node.active>.file-node-background{
    background-color: rgb(34, 34, 34);
    background-color: var(--active-file-bg-color);
}
.file-list-item.active {
    background-color: rgb(34, 34, 34);
    background-color: var(--active-file-bg-color);
}

#ty-tooltip {
    background-color: black;
    color: #eee;
}

.md-task-list-item>input {
    margin-left: -1.3em;
    margin-top: 0.3rem;
    -webkit-appearance: none;
}

.md-mathjax-midline {
    background-color: #57616b;
    border-bottom: none;
}

footer.ty-footer {
    border-color: #656565;
}

.ty-preferences .btn-default {
    background: transparent;
}
.ty-preferences .btn-default:hover {
    background: #57616b;
}

.ty-preferences select {
    border: 1px solid #989698;
    height: 21px;
}

.ty-preferences .nav-group-item.active {
    background: var(--item-hover-bg-color);
}

.ty-preferences input[type="search"] {
    border-color: #333;
    background: #333;
    line-height: 22px;
    border-radius: 6px;
    color: white;
}

.ty-preferences input[type="search"]:focus {
    box-shadow: none;
}

[data-is-directory="true"] .file-node-content {
    margin-bottom: 0;
}

.file-node-title {
    line-height: 22px;
}

.html-for-mac .file-node-open-state, .html-for-mac .file-node-icon {
    line-height: 26px;
}

::-webkit-scrollbar-thumb {
    background: rgba(230, 230, 230, 0.30);
}

::-webkit-scrollbar-thumb:active {
    background: rgba(230, 230, 230, 0.50);
}

#typora-sidebar:hover div.sidebar-content-content::-webkit-scrollbar-thumb:horizontal {
    background: rgba(230, 230, 230, 0.30);
}

.nav-group-item:active {
    background-color: #474d54;
}

.md-search-hit {
    background: rgba(199, 140, 60, 0.81);
    color: #eee;
}

.md-search-hit * {
    color: #eee;
}

#md-searchpanel input {
    color: white;
}

.export-detail,
.export-item.active,
.export-items-list-control {
    background: #d6d6d4
}

.modal-backdrop.in {
    opacity: 1;
    backdrop-filter: blur(1px);
}


</style>
</head>
<body class='typora-export os-windows'>
<div id='write'  class=''><h1><a name="系统分析师" class="md-header-anchor"></a><span>系统分析师</span></h1><p><img src="http://qn.qs520.mobi/image-20230208103704435.png" referrerpolicy="no-referrer" alt="image-20230208103704435"><span> </span></p><p><img src="http://qn.qs520.mobi/snipaste_20230417_195611.png" referrerpolicy="no-referrer" alt="image-20230321185832994"><span> </span></p><p><img src="http://qn.qs520.mobi/snipaste_20230505_213940.png" referrerpolicy="no-referrer"></p><p><img src="http://qn.qs520.mobi/image-20230314185237983.png" referrerpolicy="no-referrer"></p><p><span>案例分析：</span><a href='http://qn.qs520.mobi/%E6%96%87%E8%80%81%E5%B8%88-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E5%B8%88-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E6%80%BB%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99.pdf' target='_blank' class='url'>http://qn.qs520.mobi/%E6%96%87%E8%80%81%E5%B8%88-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E5%B8%88-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E6%80%BB%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99.pdf</a></p><p><a href='#span-id1计算机组成结构1计算机组成结构span'><span>1.计算机组成结构</span></a></p><ul><li><a href='#span-id计算机系统基础知识计算机系统基础知识span'><span>计算机系统基础知识</span></a></li><li><a href='#span-id计算机体系结构计算机体系结构span'><span>计算机体系结构</span></a></li><li><a href='#span-id计算机可靠性计算机可靠性span'><span>计算机可靠性</span></a></li></ul><p><a href='#span-id2系统配置与性能评价2系统配置与性能评价span'><span>2.系统配置与性能评价</span></a></p><ul><li><a href='#span-id性能指标性能指标span'><span>性能指标</span></a></li><li><a href='#span-id性能评价方法性能评价方法span'><span>性能评价方法</span></a></li><li><a href='#span-id阿姆达尔解决方案阿姆达尔解决方案span'><span>阿姆达尔解决方案</span></a></li></ul><p><a href='#span-id3操作系统知识3操作系统知识span'><span>3.操作系统知识</span></a></p><ul><li><a href='#span-id进程管理进程管理span'><span>进程管理</span></a></li><li><a href='#span-id存储管理存储管理span'><span>存储管理</span></a></li><li><a href='#span-id设备管理设备管理span'><span>设备管理</span></a></li><li><a href='#span-id文件管理文件管理span'><span>文件管理</span></a></li></ul><p><a href='#4.数据库技术基础'><span>4.数据库技术基础(案例分析考点4)</span></a></p><ul><li><p><a href='#span-id数据库基本概念数据库基本概念span'><span>数据库基本概念</span></a></p></li><li><p><a href='#规范化开发'><span>规范化和开发</span></a></p></li><li><p><a href='#span-id数据库新技术数据库新技术span'><span>数据库新技术</span></a></p></li><li><p><a href='#数据库系统1'><span>数据库系统</span></a></p><p><a href='#span-id5计算机网络5计算机网络span'><span>5.计算机网络</span></a></p></li><li><p><a href='#span-id网络功能和分类网络功能和分类span'><span>网络功能和分类</span></a></p></li></ul><p><a href='#span-id6多媒体技术6多媒体技术span'><span>6.多媒体技术</span></a></p><p><a href='#7.安全性知识(信息安全和网络安全)'><span>7.安全性知识(信息安全和网络安全)</span></a></p><p><a href='#8.知识产权标准化'><span>8.知识产权标准化</span></a></p><p><a href='#span-id9企业信息化战略与实施考点9企业信息化战略与实施考点span'><span>9.企业信息化战略与实施(考点)</span></a></p><p><a href='#span-id10软件工程10软件工程span'><span>10.软件工程</span></a></p><p><a href='#11.系统规划'><span>11.系统规划(案例分析考点1)</span></a></p><p><a href='#12.系统分析及需求工程'><span>12.系统分析及需求工程(案例分析考点2)</span></a></p><p><a href='#span-id13系统设计13系统设计span'><span>13.系统设计</span></a></p><p><a href='#14.系统实施与维护'><span>14.系统实施与维护(案例分析考点3-2)</span></a></p><p><a href='#15.项目管理'><span>15.项目管理(案例分析考点3-1)</span></a></p><p><a href='#16.嵌入式技术'><span>16.嵌入式技术(案例分析考点5)</span></a></p><ul><li><a href='#span-id嵌入式微处理器嵌入式微处理器span'><span>嵌入式微处理器</span></a></li><li><a href='#span-id嵌入式软件与操作系统嵌入式软件与操作系统span'><span>嵌入式软件与操作系统</span></a></li><li><a href='#span-id嵌入式开发嵌入式开发span'><span>嵌入式开发</span></a></li><li><a href='#span-id嵌入式系统案例分析嵌入式系统案例分析span'><span>嵌入式系统案例分析</span></a></li></ul><p><a href='#span-id17web应用开发案例分析考点617web应用开发案例分析考点6span'><span>17.Web应用开发(案例分析考点6)</span></a></p><p><a href='#span-id18数字与经济管理18数字与经济管理span'><span>18.数字与经济管理</span></a></p><h2><a name="span-id1计算机组成结构1计算机组成结构span" class="md-header-anchor"></a><span id="1.计算机组成结构"><span>1.计算机组成结构</span></span></h2><h3><a name="span-id计算机系统基础知识计算机系统基础知识span" class="md-header-anchor"></a><span id="计算机系统基础知识"><span>计算机系统基础知识</span></span></h3><h4><a name="计算机硬件组成" class="md-header-anchor"></a><span>计算机硬件组成</span></h4><ul><li><p><strong><span>运算器</span></strong><span>:</span><code>算数逻辑单元ALU(实现对数据的算术和逻辑运算)，累加寄存器AC(运算结果或源操作数的存放区), 数据缓冲寄存器DR(暂时存放内存的指令或数据), 状态条件寄存器PSW(保存指令运行结果的条件码内容，如溢出标志等)，</code></p><ul><li><strong><span>数据处理</span></strong><span>：算数运算 逻辑运算</span></li></ul></li><li><p><strong><span>控制器</span></strong><span>(和运算器统称为cpu)：</span><code>指令寄存器DR(暂存cpu执行命令),程序计数器PC(存放指令执行地址)，地址寄存器AR(保存cpu所访问的内存地址)， 指令译码器ID(分析指令操作码)</code></p><ul><li><strong><span>程序控制</span></strong><span>：cpu通过执行指令来控制程序的执行顺序，这是CPU的重要功能</span></li><li><strong><span>操作控制</span></strong><span>：一条指令功能的实现需要若干操作信号配合来完成，CPU产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作</span></li><li><strong><span>时间控制</span></strong><span>：CPU对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。</span></li></ul></li><li><p><strong><span>存储器</span></strong></p><ul><li><span>内部存储器(内存)</span></li><li><span>外部存储器(磁盘)</span></li></ul></li><li><p><span>输入设备</span></p></li><li><p><span>输出设备</span></p></li><li><h4><a name="中央处理单元-运算器和控制器" class="md-header-anchor"></a><span>中央处理单元: 运算器和控制器</span></h4></li><li><h4><a name="数据表示所有进制之间不能直接转换要通过十进制但是下面两种除外" class="md-header-anchor"></a><span>数据表示(所有进制之间不能直接转换，要通过十进制。但是下面两种除外)</span></h4><ul><li><p><span>二进制转八进制：每三位二进制数转换为一位八进制数，二进制数位个数不是三的倍数，则在前面补0(原则是数值不变)如二进制数01101有五位，前面补一个0就有六位，为001 101，每三位转换为一位八进制数001=1,101=1+4=5，也即01101=15。</span></p></li><li><p><span>二进制转十六进制：每四位二进制数转换为一位十六进制数，二进制数位个数不是四的倍数，则在前面补0，如二进制数101101有六位，前面补两个0就有八位，为00101101，每四位转换为一位十六进制数，0010=2,1101=13=D，也即101101=2D。</span></p></li><li><p><span>机器数：使用二进制存放，正数负数的区别是</span><mark><span>正数符号位是0，负数是1</span></mark></p></li><li><p><span>带符号数有下列编码方式，当真值为-45时:</span></p><ul><li><span>原码:一个数的正常二进制表示，最高位表示符号，数值0的源码有两种形式+0(0 0000000)和-0 (10000000) 。-45对应原码为10101101</span></li><li><span>反码:</span><mark><span>正数的反码即原码</span></mark><span>，负数的反码是在原码的基础上，</span><mark><span>除符号位外，其他各位按位取反</span></mark><span>。数值0的反码也有两种形式:+(0 0000000)-0(11111111)。-45对应反码为11010010</span></li><li><span>补码:</span><mark><span>正数的补码即原码</span></mark><span>，负数的补码是在原码的基础上，</span><mark><span>除符号位外，其他各位按位取反，而后末位+1</span></mark><span>，若有进位则产生进位。因此数值0的补码只有一种形式+0=-0=00000000。-45对应补码为11010011</span></li><li><span>移码:用作浮点运算的阶码，</span><mark><span>无论正数负数，都是将该原码的补码的首位(符号位)取反</span></mark><span>得到移码。-45对应移码为01010011</span></li></ul></li><li><p><span>机器字长为n时各种码制表示的带符号数的取值范围(差别在于0的表示，原码和反码分+0和-0，补码只有一个0，因此可以多表示一个。) :</span></p><ul><li><figure><table><thead><tr><th><span>码制</span></th><th><span>定点整数</span></th><th><span>定点小数</span></th></tr></thead><tbody><tr><td><span>原码</span></td><td><span>-(2^n-1 - 1)  ~  +(2^n-1 - 1)</span></td><td><span>-(1 - 2^-(n-1))  ~  +(1 - 2^-(n-1))</span></td></tr><tr><td><span>反码</span></td><td><span>-(2^n-1 - 1)  ~  +(2^n-1 - 1)</span></td><td><span>-(1 - 2^-(n-1))  ~  +(1 - 2^-(n-1))</span></td></tr><tr><td><span>补码</span></td><td><span>-2^n-1 ~  +(2^n-1 - 1)</span></td><td><span>-1 ~  +(1 - 2^-(n-1))</span></td></tr><tr><td><span>移码</span></td><td><span>-2^n-1 ~  +(2^n-1 - 1)</span></td><td><span>-1 ~  +(1 - 2^-(n-1))</span></td></tr></tbody></table></figure></li></ul></li><li><p><span>浮点数</span></p></li><li><p><img src="http://qn.qs520.mobi/image-20230203155056442.png" referrerpolicy="no-referrer" alt="image-20230203155056442"><span> </span></p></li></ul></li><li><h4><a name="校验码" class="md-header-anchor"></a><span>校验码</span></h4></li><li><p><span>码距：单个编码A: 00码距为1，因为其只需要改变一位就变成另个编码。</span><strong><span>在两个编码中，从A码到B码转换所需要改变的位数称为码距</span></strong><span>，如A:00要转换为B:11，码距为2。一般来说，码距越大，越利于纠错和检错。</span></p></li><li><p><strong><span>奇偶校验码</span></strong><span>: </span><mark><span>在编码中增加1位校验位来使编码中1的个数为奇数 (奇校验或者偶数(偶校验)</span></mark><span>，从而使码距变为2。例如:</span></p><ul><li><span>奇校验:编码中，</span><mark><span>含有奇数个1</span></mark><span>，发送给接收方，接收方收到后，会计算收到的编码有多少个1，如果是奇数个，则无误，是偶数个，则有误。</span></li><li><span>偶校验同理，</span><mark><span>只是编码中有偶数个1</span></mark><span>，由上述，奇偶校验只能检1位错，并且无法纠错。</span></li></ul></li><li><p><strong><span>循环冗余校验码(CRC)</span></strong><span>：</span><mark><span>CRC只能检错，不能纠错</span></mark><span>。使用CRC 编码，需要先约定一个生成多项式G(x).生成多项式的最高位和最低位必须是1。假设原始信息有m位，则对应多项式M(x)。生成校验码思想就是在原始信息位后追加若干校验位，使得追加的信息能被G(x)整除。接收方接收到带校验位的信息，然后用G(x)整除。余数为0，则没有错误;反之则发生错误。</span></p></li><li><p><span>例:假设原始信息串为10110，CRC的生成多项式为G(x)=x4+x+1，求CRC校验码</span></p><ul><li><span>在原始信息位后面添0，假设生成多项式的阶为r，则在原始信息位后添加r个0，本题中，G(x)阶为4，则在原始信息串后加4个0，得到的新串为101100000作为被除数。</span></li><li><span>(2)由多项式得到除数，多项中x的幂指数存在的位置1，不存在的位置0。本题中，x的幂指数为0,1,4的变量都存在，而幂指数为2,3的不存在，因此得到串10011</span></li><li><span>(3)生成CRC校验码，将前两步得出的被除数和除数进行模2除法运算 (即不进位也不借位的除法运算)。除法过程如下图所示。</span></li><li><img src="http://qn.qs520.mobi/image-20230203175247425.png" referrerpolicy="no-referrer" alt="image-20230203175247425"><span> </span></li></ul></li><li><p><strong><span>海明码</span></strong><span>:本质也是利用</span><mark><span>奇偶性</span></mark><span>来检错和纠错的检验方法，构成方法是在数据位之间的确定位置上插入k个校验位，通过扩大码距实现检错和纠错设</span><mark><span>数据位是n位，校验位是k位，则n和k必须满足以下关系: 2^k-1&gt;=n+k。</span></mark></p></li><li><p><img src="http://qn.qs520.mobi/image-20230203181224459.png" referrerpolicy="no-referrer" alt="image-20230203181224459"><span> </span></p></li><li><p><img src="http://qn.qs520.mobi/image-20230203181349586.png" referrerpolicy="no-referrer" alt="image-20230203181349586"><span> </span></p></li></ul><h3><a name="span-id计算机体系结构计算机体系结构span" class="md-header-anchor"></a><span id="计算机体系结构"><span>计算机体系结构</span></span></h3><h4><a name="体系结构分类" class="md-header-anchor"></a><span>体系结构分类</span></h4><ul><li><p><strong><span>按处理机的数量进行分类</span></strong><span>:</span></p><ul><li><span>单处理系统(一个处理单和其他设备集成)</span></li><li><span>并行处理系统(两个以上的处理机互联)</span></li><li><span>分布式处理系统((物理上远距离且松耦合的多计算机系统)</span></li></ul></li><li><p><strong><span>Flynn分类法</span></strong><span>:分类有两个因素，即</span><mark><span>指令流和数据流</span></mark><span>，</span><mark><span>指令流由控制部分处理</span></mark><span>，每一个控制部分处理一条指令流，多指令流就有多个控制部分;</span><mark><span>数据流由处理器来处理</span></mark><span>，每一个处理器处理一条数据流，多数据流就有多个处理器;至于</span><mark><span>主存模块，是用来存储的，存储指令流或者数据流</span></mark><span>，因此，无论是多指令流还是多数据流，都需要多个主存模块来存储，对于主存模块，指令和数据都一样。</span></p></li><li><p><strong><span>依据计算机特性</span></strong><span>：是由指令来控制数据的传输，因此，一条指令可以控制一条或多条数据流，但一条数据流不能被多条指令控制，否则会出错，就如同上级命令太多还互相冲突不知道该执行哪个，因此多指令单数据MISD不可能</span></p></li><li><figure><table><thead><tr><th><span>体系结构类型</span></th><th><span>结构</span></th><th><span>关键特性</span></th><th><span>代表</span></th></tr></thead><tbody><tr><td><span>单指令流单数据流SISD</span></td><td><span>控制部分:一个   处理器:一个         主存模块:一个</span></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><span>单指令流多数据流SIMD</span></td><td><span>控制部分:一个   处理器:多个         主存模块:多个</span></td><td><span>各处理器以异步的形式执行同一条指令</span></td><td><span>1并行处理机   2阵列处理机   3超级向量处理机</span></td></tr><tr><td><span>多指令流单数据流MISD</span></td><td><span>控制部分:多个   处理器:一个         主存模块:多个</span></td><td><span>被证明不可能至少是不实际</span></td><td><span>目前没有，有文献称流水线计算机为此类</span></td></tr><tr><td><span>多指令流多数据流MIMD</span></td><td><span>控制部分:多个   处理器:多个         主存模块:多个</span></td><td><span>能够实现作业、任务、指令等各级全面并行</span></td><td><span>1多处理机系统   2多计算机</span></td></tr></tbody></table></figure></li></ul><h4><a name="指令系统" class="md-header-anchor"></a><span>指令系统</span></h4><ul><li><p><strong><span>计算机指令的组成</span></strong><span>:一条指令由</span><mark><span>操作码和操作数</span></mark><span>两部分组成，操作码决定要完成的操作，操作数指参加运算的数据及其所在的单元地址。在计算机中，操作要求和操作数地址都由二进制数码表示，分别称作</span><strong><span>操作码和地址码</span></strong><span>，整条指令以二进制编码的形式存放在存储器中。</span></p></li><li><p><strong><span>计算机指令执行过程</span></strong><span>: </span><mark><span>取指令-一分析指令-一执行指令</span></mark><span>三个步骤，首先将程序计数器PC中的指令地址取出，送入地址总线，CPU依据指令地址去内存中取出指令内容存入指令寄存器IR，而后由指令译码器进行分析，分析指令操作码;最后执行指令，取出指令执行所需的源操作数。</span></p></li><li><p><mark><span>指令寻址方式</span></mark></p><ul><li><strong><span>顺序寻址方式</span></strong><span>:当执行一段程序时，是一条指令接着一条指令地顺序执行。</span></li><li><strong><span>跳跃寻址方式</span></strong><span>:指下一条指令的地址码不是由程序计数器给出，而是由本条指令直接给出。程序跳跃后，按新的指令地址开始顺序执行。因此，程序计数器的内容也必须相应改变，以便及时跟踪新的指令地址。</span></li></ul></li><li><p><mark><span>指令操作数的寻址方式：</span></mark></p><ul><li><strong><span>立即寻址方式</span></strong><span>:指令的地址码字段指出的不是地址，而是操作数本身</span></li><li><strong><span>直接寻址方式</span></strong><span>:在指令的地址字段中直接指出操作数在主存中的地址。</span></li><li><strong><span>间接寻址方式</span></strong><span>:指令地址码字段所指向的存储单元中存储的是操作数的地址。</span></li><li><strong><span>寄存器寻址方式</span></strong><span>:指令中的地址码是寄存器的编号。</span></li><li><span>基址寻址方式:将基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址，其优点是可以扩大寻址能力。</span></li><li><span>变址寻址方式:变址寻址方式计算有效地址的方法与基址寻址方式很相似，它是将变址寄存器的内容加上指令中的形式地址而形成操作数的有效地址。</span></li></ul></li><li><p><strong><span>CISC</span></strong><span>是</span><mark><span>复杂指令系统</span></mark><span>兼容性强，指令繁多、长度可变，由微程序实现;</span></p></li><li><p><strong><span>RISC</span></strong><span>是</span><mark><span>精简指令系统</span></mark><span>指令少，使用频率接近，主要依靠硬件实现(通用寄存器硬布线逻辑控制),区别如下：</span></p></li></ul><figure><table><thead><tr><th><span>指令系统类型</span></th><th><span>指令</span></th><th><span>寻址方式</span></th><th><span>实现方式</span></th><th><span>其他</span></th></tr></thead><tbody><tr><td><span>CISC(复杂)</span></td><td><span>数量多，使用频率差别大可变长格式</span></td><td><span>支持多种</span></td><td><strong><span>微程序控制技术(微码)</span></strong></td><td><span>研制周期长</span></td></tr><tr><td><span>RISC(精简)</span></td><td><span>数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存</span></td><td><span>支持方式少</span></td><td><strong><span>增加了通用寄存器，硬布线逻辑控制为主，适合采用流水线</span></strong></td><td><span>优化编译，有效支持高级语言</span></td></tr></tbody></table></figure><ul><li><p><strong><span>指令流水线原理</span></strong><span>: 将</span><mark><span>指令分成不同段，每段由不同的部分去处理</span></mark><span>，因此可以产生叠加的效果，所有的部件去处理指令的不同段</span></p></li><li><p><span>RISC中的流水线技术:</span></p><ol start='' ><li><mark><span>超流水线 (Super Pipe Line) 技术</span></mark><span>。它通过细化流水、增加级数和提高主频，使得在每个机器周期内能完成一个甚至两个浮点操作。其实质是以</span><mark><span>时间换取空间。</span></mark></li><li><mark><span>超标量 (super Scalar) 技术</span></mark><span>。它通过内装多条流水线来同时执行多个处理，其时钟频率虽然与一般流水接近，却有更小的CPI。其实质是以</span><mark><span>空间换取时间</span></mark><span>。</span></li><li><mark><span>超长指令字 (Very Long Instruction Word，VLIW) 技术</span></mark><span>VLIW 和超标量都是20 世纪80 年代出现的概念，其共同点是要同时执行多条指令，其不同在于超标量依靠硬件来实现并行处理的调度，VLIW 则充分发挥</span><mark><span>软件的作用</span></mark><span>，而使硬件简化性能提高。</span></li></ol><p><img src="http://qn.qs520.mobi/image-20230206112638624.png" referrerpolicy="no-referrer" alt="image-20230206112638624"><span> </span></p></li><li><p><mark><span>流水线时间计算(考点)</span></mark></p><ul><li><p><strong><span>流水线周期</span></strong><span>:指令分成不同执行段，其中执行时间最长的段为流水线周期</span></p></li><li><p><strong><span>流水线执行时间:</span></strong><span>1条指令总执行时间+ (总指令条数-1)*流水线周期</span></p></li><li><p><strong><span>流水线吞吐率计算</span></strong><span>:吞吐率即单位时间内执行的指令条数。</span></p><blockquote><p><mark><span>公式: 指令条数/流水线执行时间。</span></mark></p></blockquote></li><li><p><strong><span>流水线的加速比计算</span></strong><span>:加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高，</span></p><blockquote><p><mark><span>公式:不使用流水线执行时间/使用流水线执行时间</span></mark></p></blockquote></li></ul></li></ul><h4><a name="存储系统cache" class="md-header-anchor"></a><span>存储系统(cache)</span></h4><ul><li><p><span>计算机采用分级存储体系的主要目的是为了解决存储容量、成本和速度之间的矛盾问题。</span></p><p><img src="http://qn.qs520.mobi/image-20230206121708114.png" referrerpolicy="no-referrer" alt="image-20230206121708114"><span> </span></p></li><li><p><span>两级存储: Cache-主存、主存-辅存(虚拟存储体系)</span></p></li><li><p><span>局部性原理:总的来说，在CPU运行时，所访问的数据会趋向于一个较小的局部空间地址内，包括下面两个方面:</span></p><ul><li><strong><span>时间局部性原理</span></strong><span>:如果一个数据项正在被访问，那么在近期它很可能会被再次访问，即在</span><mark><span>相邻的时间里会访问同一个数据项</span></mark></li><li><strong><span>空间局部性原理</span></strong><span>:在最近的将来会用到的数据的地址和现在正在访问的数据地址很可能是相近的，</span><mark><span>即相邻的空间地址会被连续访问</span></mark></li></ul></li><li><p><span>高速缓存Cache用来存储当前最活跃的程序和数据，</span><mark><span>直接与CPU交互，位于CPU和主存之间</span></mark><span>，容量小，速度为内存的5-10倍，由半导体材料构成。其内容是主存内存的副本拷贝，对于程序员来说是透明的。</span></p></li><li><p><span>Cache由</span><mark><span>控制部分和存储器组成</span></mark><span>，存储器存储数据，控制部分判断CPU要访问的数据是否在Cache中，在则命中，不在则依据一定的算法从主存中替换。</span></p></li><li><p><span>地址映射:在CPU工作时，送出的是主存单元的地址，而应从Cache存储器中读/写信息。这就需要将主存地址转换为Cache存储器地址，这种地址的转换称为地址映像，由</span><mark><span>硬件自动完成映射</span></mark><span>，分为下列三种方法:</span></p><ul><li><p><span>直接映像: </span><mark><span>将Cache存储器等分成块，主存也等分成块并编号</span></mark><span>, 主存中的块与Cache中的块的对应关系是固定的，也即</span><mark><span>二者块号相同才能命中</span></mark><span>。地址变换简单但不灵活，容易造成资源浪费。 (如图所示)</span></p><p><img src="http://qn.qs520.mobi/image-20230206142606135.png" referrerpolicy="no-referrer" alt="image-20230206142606135"><span> </span></p></li><li><p><span>全相联映像: 同样都等分成块并编号。</span><mark><span>主存中任意一块都与Cache中任意一块对应</span></mark><span>。因此可以随意调入Cache任意位置，但地址变换复杂，速度较慢。因为主存可以随意调入Cache任意块，只有当Cache满了才会发生块冲突，</span><mark><span>是最不容易发生块冲突的映像方式</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230206142622296.png" referrerpolicy="no-referrer" alt="image-20230206142622296"><span> </span></p></li><li><p><span>组组相连映像:</span><mark><span>前面两种方式的结合</span></mark><span>，将Cache存储器先分块再分组，主存也同样先分块再分组，</span><mark><span>组间采用直接映像，即主存中组号与Cache中组号相同的组才能命中，但是组内全相联映像，也即组号相同的两个组内的所有块可以任意调换</span></mark><span>。</span></p></li></ul></li><li><p><strong><span>替换算法</span></strong><span>的目标就是使</span><mark><span>Cache 获得尽可能高的命中率</span></mark><span>。常用算法有如下几种。</span></p><ul><li><mark><strong><span>随机替换算法</span></strong></mark><span>：就是用随机数发生器产生一个要替换的块号，将该块替换出去</span></li><li><mark><strong><span>先进先出算法</span></strong></mark><span>：就是将最先进入Cache 的信息块替换出去</span></li><li><mark><strong><span>近期最少使用算法</span></strong></mark><span>：这种方法是将近期最少使用的Cache 中的信息块替换出去</span></li><li><mark><strong><span>优化替换算法</span></strong></mark><span>：这种方法必须先执行一次程序，统计Cache 的替换情况有了这样的先验信息，在第二次执行该程序时便可以用最有效的方式来替换。</span></li></ul></li><li><p><span>命中率及平均时间</span></p><ul><li><p><span>Cache有一个命中率的概念，即当</span><mark><span>CPU所访问的数据在Cache中时，命中，直接从Cache中读取数据</span></mark><span>，设读取一次Cache时间为1ns，若CPU访问的数据</span><mark><span>不在Cache中则需要从内存中读取</span></mark><span>，设读取一次内存的时间为1000ns，若在CPU多次读取数据过程中，有90%命中Cache，则CPU读取一次的平均时间为(90%</span><em><span>1 +10%</span></em><span>1000)ns  就是90% x 1ns 加上10% x 1000ns</span></p><p><img src="http://qn.qs520.mobi/image-20230206143314200.png" referrerpolicy="no-referrer" alt="image-20230206143314200"><span> </span></p></li></ul></li><li><p><strong><span>四种存取方式：</span></strong></p><ol start='' ><li><strong><span>顺序存取：</span></strong><span>对数据的存取是按照顺序来的</span></li><li><strong><span>直接存取：</span></strong><span>按块进行顺序存取，典型代表是磁盘</span></li><li><strong><span>随机存取：</span></strong><span>存取的数据跟访问地址没有关系，是随机的。典型代表是主存</span></li><li><strong><span>相联存取：</span></strong><span>按照所访问的内容来访问的，典型代表是cache</span></li></ol></li></ul><h4><a name="存储系统磁盘" class="md-header-anchor"></a><span>存储系统(磁盘)</span></h4><ul><li><p><span>磁盘结构和参数</span></p><ul><li><mark><span>磁盘有正反两个盘面，每个盘面有多个同心圆每个同心圆是一个磁道，每个同心圆又被划分为多个扇区，数据就被存放在一个个扇区中</span></mark><span>。</span></li><li><mark><span>磁头首先要寻找到对应的磁道</span></mark><span>，然后等待磁盘进行周期旋转，旋转到指定的扇区，才能读取到对应的数据，因此，会产生寻道时间和等待时间。公式为:</span><strong><span>存取时间=寻道时间+等待时间 (平均定位时间+转动延迟)</span></strong></li><li><span>注意:</span><strong><span>寻道时间是指磁头移动到磁道所需的时间:等待时间为等待读写的扇区转到磁头下方所用的时间</span></strong></li></ul></li><li><p><span>磁盘调度算法，之前已经说过，磁盘数据的读取时间分为寻道时间+旋转时间，也即先找到对应的磁道，而后再旋转到对应的扇区才能读取数据，其中</span><mark><span>寻道时间耗时最长</span></mark><span>，需要重点调度，有如下调度算法:</span></p><ul><li><mark><span>先来先服务FCFS</span></mark><span>:根据进程请求访问磁盘的先后顺序进行调度。</span></li><li><mark><span>最短寻道时间优先SSTF</span></mark><span>: 请求访问的磁道与当前磁道最近的进程优先调度，使得每次的寻道时间最短。会产生“饥饿”现象，即远处进程可能永远无法访问。</span></li><li><mark><span>扫描算法SCAN:又称“电梯算法</span></mark><span>: 磁头在磁盘上双向移动，其会选择离磁头当前所在磁道最近的请求访问的磁道，并且与磁头移动方向一致，磁头永远都是从里向外或者从外向里一直移动完才掉头，与电梯类似。</span></li><li><mark><span>单向扫描调度算法CSCAN</span></mark><span>: 与SCAN不同的是，其只做单向移动，即只能从里向外或者从外向里。</span></li></ul></li></ul><h4><a name="输入输出技术io技术" class="md-header-anchor"></a><span>输入/输出技术(I/O技术)</span></h4><ul><li><p><span>计算机系统中存在多种内存与接口地址的编址方法，常见的是下面两种:</span></p><ol start='' ><li><mark><span>内存与接口地址</span><strong><span>独立</span></strong><span>编址方法</span></mark><span>: 内存地址和接口地址是</span><strong><span>完全独立的两个地址空间</span></strong><span>。访问数据时所使用的指令也完全不同，用于接口的指令只用于接口的读/写，其余的指令全都是用于内存的因此，在编程序或读程序时很易使用和辨认。这种编址方法的</span><mark><span>缺点是用于接口的指令太少、功能太弱。</span></mark></li><li><mark><span>内存与接口地址</span><strong><span>统一</span></strong><span>编址方法</span></mark><span>: 内存地址和接口地址</span><strong><span>统一在一个公共的地址空间里</span></strong><span>，即内存单元和接口共用地址空间。</span><mark><span>优点是原则上用于内存的指令全都可以用于接口</span></mark><span>，这就大大地增强了对接口的操作功能，而且在指令上也不再区分内存或接口指令。该编址方法的</span><mark><span>缺点就在于整个地址空间被分成两部分</span></mark><span>，其中一部分分配给接口使用，剩余的为内存所用，这经常会导致内存地址不连续。</span></li></ol></li><li><p><span>计算机和外设间的数据交互方式:</span></p><ul><li><p><strong><span>程序控制(查询)方式</span></strong><mark><span>: CPU主动查询外设是否完成数据传输，效率极低</span></mark></p></li><li><p><strong><span>程序中断方式</span></strong><span>:外设完成数据传输后，</span><mark><span>向CPU发送中断</span></mark><span>，等待CPU处理数据效率相对较高。中断响应时间指的是从发出中断请求到开始进入中断处理程序中断处理时间指的是从中断处理开始到中断处理结束。中断向量提供中断服务程序的入口地址。多级中断嵌套，使用堆栈来保护断点和现场。</span></p></li><li><p><strong><span>DMA方式(直接主存存取)</span></strong><span> : </span><mark><span>CPU只需完成必要的初始化等操作，数据传输的整个过程都由DMA控制器来完成，在</span><strong><span>主存和外设</span></strong><span>之间建立直接的数据通路效率很高。</span></mark></p></li><li><p><mark><span>在一个总线周期结束后，CPU会响应DMA请求开始读取数据;CPU响应程序中断方式请求是在一条指令执行结束时</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230206173006650.png" referrerpolicy="no-referrer" alt="image-20230206173006650"><span> </span></p></li></ul></li></ul><h4><a name="总线结构" class="md-header-anchor"></a><span>总线结构</span></h4><ul><li><p><span>总线 (Bus)，是指</span><mark><span>计算机设备和设备之间传输信息的公共数据通道</span></mark><span>。总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是由总线上的所有设备共享，因此可以将计算机系统内的多种设备连接到总线上</span></p></li><li><p><span>从广义上讲，任何连接两个以上电子元器件的导线都可以称为总线，通常分为以下三类:</span></p><ul><li><span>内部总线:内部芯片级别的总线，芯片与处理器之间通信的总线。</span></li><li><span>系统总线:是板级总线，用于计算机内各部分之间的连接，具体分为</span><mark><span>数据总线(并行数据传输位数)，地址总线(系统可管理的内存空间的大小)、控制总线 (传送控制命令)</span></mark><span>。代表的有ISA总线、EISA总线、PCI总线。</span></li><li><span>外部总线:设备一级的总线，微机和外部设备的总线。代表的有RS232(串行总线)、SCS!(并行总线)、USB (通用串行总线，即插即用，支持热插拔)</span></li></ul></li></ul><h3><a name="span-id计算机可靠性计算机可靠性span" class="md-header-anchor"></a><span id="计算机可靠性"><span>计算机可靠性</span></span></h3><h4><a name="可靠性指标" class="md-header-anchor"></a><span>可靠性指标：</span></h4><ul><li><span>平均无故障时间MTTF=1/失效率。</span></li><li><span>平均故障修复时间MTTR=1/修复率。</span></li><li><span>平均故障间隔时间MTBF=MTTF+MTTR。</span></li><li><span>系统可用性=MTTF/(MTTF+MTTR)</span><em><span>100%。</span></em></li></ul><h4><a name="串并联系统可靠性" class="md-header-anchor"></a><span>串并联系统可靠性</span></h4><ul><li><p><span>无论什么系统，都是由多个设备组成的,协同工作，而这多个设备的组合方式假设每个设备的可靠性为R1，R2.....Rn,可以是串联、并联，也可以是混合模式则不同的系统的可靠性公式如下:</span></p><blockquote><p><span>串联系统，一个设备不可靠，整个系统崩溃，整个系统可靠性</span><mark><span>R=R1 *  R2</span><em><span>。。。</span></em><span>Rn</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230206175803095.png" referrerpolicy="no-referrer" alt="image-20230206175803095"><span> </span></p><p><span>并联系统，所有设备都不可靠，整个系统才崩溃，整个系统可靠性</span><mark><span>R=1-(1-R1) * (1-R2) *(1-Rn)</span></mark><span>， 如下图左1</span></p><p><img src="http://qn.qs520.mobi/image-20230206175936764.png" referrerpolicy="no-referrer" alt="image-20230206175936764"><span> </span></p><p><span>N模冗余系统: N 模余系统由</span><mark><span>N 个 (N=2n+1)</span></mark><span> </span><mark><span>相同的子系统和一个表决器组成</span></mark><span>，表决器把N 个子系统中占多数相同结果的输出作为输出系统的输出，如上图右所示。在N 个子系统中，只要有</span><mark><span>n+1 个或n+1个以上</span></mark><span>子系统能正常工作，系统就能正常工作，输出正确的结果。</span></p></blockquote></li></ul><h2><a name="span-id2系统配置与性能评价2系统配置与性能评价span" class="md-header-anchor"></a><span id="2.系统配置与性能评价"><span>2.系统配置与性能评价</span></span></h2><h3><a name="span-id性能指标性能指标span" class="md-header-anchor"></a><span id="性能指标"><span>性能指标</span></span></h3><h4><a name="计算机" class="md-header-anchor"></a><span>计算机</span></h4><ul><li><span>对计算机评价的主要性能指标有: </span><mark><span>时钟频率(主频) ;运算速度，运算精度，内存的存储容量;存储器的存取周期;数据处理速率PDR (processingdatarate)吞吐率;各种响应时间;各种利用率RASIS特性 (即: 可靠性Reliability、可用性Availability、可维护性Sericeability、完整性和安全性Integraity and Security)平均故障响应时间;兼容性，可扩充性;性能价格比</span></mark><span>。</span></li></ul><h4><a name="路由器" class="md-header-anchor"></a><span>路由器</span></h4><ul><li><span>对路由器评价的主要性能指标有:</span><mark><span>设备吞吐量、端口吞吐量</span></mark><span>全双工线速转发能力、背靠背帧数、路由表能力、背板能力、</span><mark><span>丢包率、时延、时延抖动</span></mark><span>、VPN支持能力、内部时钟精度、队列管理机制、端口硬件队列数、分类业务带宽保证.RSVP、IP Diff Serv、CAR支持、几余、热插拔组件、路由器余协议、网管、基于Web的管理、网管类型、带外网管支持、网管粒度、计费能力/协议、分组语音支持方式、协议支持、语音压缩能力、端口密度、信令支持。</span></li></ul><h4><a name="交换机" class="md-header-anchor"></a><span>交换机</span></h4><ul><li><span>对交换机评价的主要性能指标有:交换机类型、配置、支持的网络类型、最大ATM端口数、最大SONET端口数、最大FDDI端口数、背板吞吐量、缓冲区大小最大MAC地址表大小、最大电源数、支持协议和标准、路由信息协议RIP、RIP2开放式最短路径优先第2版、边界网关协议BGP、 无类域间路由CIDR、互联网成组管理协议IGMP、距离矢量多播路由协议DVMRP、开放式最短路径优先多播路由协议MOSPF、协议无关的多播协议PIM、资源预留协议RSVP、802.1p优先级标记，多队列、路由、支持第3层交换、支持多层 (4到7层交换、支持多协议路由支持路由缓存、可支持 最大路由表数、VLAN、最大VLAN数量、网管、支持网管类型、支持端口镜像、Qos、支持基于策 略的第2层交换、每端口最大优先级队列数、支持基于策略的第3层交换、支持基于策略的应用级 Qos、支持最小/最大带宽分配、冗余、热交换组件 (管理卡，交换结构，接口模块，电源，冷却系统、支持端口链路聚集协议、负载均衡。</span></li></ul><h4><a name="网络" class="md-header-anchor"></a><span>网络</span></h4><ul><li><span>评价网络的性能指标有: </span><mark><span>设备级性能指标，网络级性能指标;应用级性能指标用户级性能指标; 吞吐量。</span></mark></li></ul><h4><a name="操作系统" class="md-header-anchor"></a><span>操作系统</span></h4><ul><li><span>评价操作系统的性能指标有: </span><mark><span>系统的可靠性、系统响应系统的吞吐率 (量)时间、系统资源利用率、可移植性</span></mark></li></ul><h4><a name="数据库管理系统" class="md-header-anchor"></a><span>数据库管理系统</span></h4><ul><li><span>衡量数据库管理系统的主要性能指标包括</span><mark><span>数据库本身和管理系统</span></mark><span>两部分，有:</span><mark><span>数据库的大小、数据库中表的数量、单个表的大小、表中允许的记录 (行)数量、单个记录 (行) 的大小、表上所允许的索引数量、数据库所允许的索引数量、最大并发事务处理能力、!负载均衡能力、最大连接数等等</span></mark></li></ul><h4><a name="web服务器" class="md-header-anchor"></a><span>WEB服务器</span></h4><ul><li><span>评价Web服务器的主要性能指标有: </span><mark><span>最大并发连接数、响应延迟、吞吐量</span></mark></li></ul><h3><a name="span-id性能评价方法性能评价方法span" class="md-header-anchor"></a><span id="性能评价方法"><span>性能评价方法</span></span></h3><h4><a name="性能评测的常用方法" class="md-header-anchor"></a><span>性能评测的常用方法</span></h4><ul><li><p><span>时钟频率一般来讲，主频越高，速度越快。</span></p></li><li><p><span>指令执行速度。计量单位KIPS、MIPS</span></p></li><li><p><span>等效指令速度法。统计各类指令在程序中所占比例，并进行折算，是一种固定比例法。</span></p></li><li><p><span>综合理论性能法：CTP 用 MTOPS(每秒百万次理论运算)表示。CTP 的估算方法是,首先算出处理部件每个计算单元(例如，定点加法单元、定点乘法单元、浮点加单元、浮点乘法单元等)的有效计算率，再按不同字长加以调整，得出该计算单元的理论性能，所有组成该处理部件的计算单元的理论性能之和即为 CTP。</span></p></li><li><p><span>数据处理速率(Processing Data Rate，PDR) 法。采用计算PDR 值的方法来衡量机器性能，PDR 值越大，机器性能越好。PDR 与每条指令和每个操作数的平均位数以及每条指令的平均运算速度有关。</span></p></li><li><p><strong><span>基准程序法 (Benchmark)</span></strong><span>: </span><mark><span>把应用程序中用得最多最频繁的那部分核心程序作为评价计算机性能的标准程序，称为基准测试程序</span></mark><span>是目前被(benchmark)用户一致承认的测试性能的较好方法，有多种多样的基准程序，包括:</span></p><ul><li><mark><span>整数测试程序</span></mark><span>：同厂家的机器，采用相同的体系结构，用相同的基准程序测试，得到的MIPS 值越大，一般说明机器速度越快。</span></li><li><mark><span>浮点测试程序</span></mark><span>：指标MFLOPS (理论峰值浮点速度)</span></li><li><mark><span>SPEC 基准程序(SPEC Benchmark)</span></mark><span>：重点面向处理器性能的基准程序集，将被测计算机的执行时间标准化，即将被测计算机的执行时间除以一个参考处理器的执行时间</span></li><li><mark><span>TPC 基准程序</span></mark><span>：用于评测计算机在事务处理、数据库处理、企业管理与决策支持系统等方面的性能。其中，</span><mark><span>TPC-C 是在线事务处理 (On-line TransactionProcessing，OLTP) 的基准程序，TPC-D 是决策支持的基准程序。TPC-E 作为大型企业信息服务的基准程序</span></mark></li></ul></li><li><p><span>大多数情况下，为测试新系统的性能，用户必须依靠评价程序来评价机器的性能。下面列出了4种评价程序，它们评测的</span><mark><span>准确程度依次递减: 真实的程序、核心程序、小型基准程序、合成基准程序</span></mark></p></li></ul><h3><a name="span-id阿姆达尔解决方案阿姆达尔解决方案span" class="md-header-anchor"></a><span id="阿姆达尔解决方案"><span>阿姆达尔解决方案</span></span></h3><ul><li><p><span>阿姆达尔(Amdahl)定律主要用于系统性能改进的计算中。阿姆达尔定律是指</span><mark><span>计算机系统中对某一部件采用某种更快的执行方式所获得的系统性能改变程度取决于这种方式被使用的频率，或所占总执行时间的比例。</span></mark>
<span>阿姆达尔定律定义了采用特定部件所取得的加速比。假定我们使用某种增强部件，计算机的性能就会得到提高，那么加速比就是下式所定义的比率:</span></p><p><img src="http://qn.qs520.mobi/image-20230207114440684.png" referrerpolicy="no-referrer" alt="image-20230207114440684"><span> </span></p></li></ul><h2><a name="span-id3操作系统知识3操作系统知识span" class="md-header-anchor"></a><span id="3.操作系统知识"><span>3.操作系统知识</span></span></h2><h4><a name="操作系统概述" class="md-header-anchor"></a><span>操作系统概述</span></h4><ul><li><p><span>定义：</span></p><ul><li><span>操作系统定义:能有效地组织和管理系统中的各种软/硬件资源，合理地组织计算机系统工作流程，控制程序的执行，并且向用户提供一个良好的工作环境和友好的接口。</span></li><li><span>操作系统有两个重要的作用:</span><mark><span>第一，通过资源管理提高计算机系统的效率第二，改善人机界面向用户提供友好的工作环境</span></mark><span>。</span></li><li><span>操作系统的4 个特征是</span><mark><span>并发性、共享性、虚拟性和不确定性</span></mark></li></ul></li><li><p><span>操作系统的功能：</span></p><ul><li><mark><span>进程管理</span></mark><span>：实质上是对处理机的执行“时间”进行管理，采用多道程序等技术将CPU的时间合理地分配给每个任务，主要包括进程控制、进程同步、进程通信和进程调度。</span></li><li><mark><span>文件管理</span></mark><span>：主要包括文件存储空间管理、目录管理、文件的读/写管理和存取控制。</span></li><li><mark><span>存储管理</span></mark><span>：存储管理是对主存储器“空间”进行管理，主要包括存储分配与回收、存储保护、地址映射(变换) 和主存扩充。</span></li><li><mark><span>设备管理</span></mark><span>：实质是对硬件设备的管理，包括对输入/输出设备的分配、启动、完成和回收。</span></li><li><mark><span>作业管理</span></mark><span>：包括任务、界面管理、人机交互、图形界面、语音控制和虚拟现实等。</span></li></ul></li><li><p><span>操作系统的分类</span></p><ul><li><mark><span>批处理操作系统</span></mark><span>：单道批处理和多道批处理 (主机与外设可并行)</span></li><li><mark><span>分时操作系统</span></mark><span>：一个计算机系统与多个终端设备连接。将CPU 的工作时间划分为许多很短的时间片，轮流为各个终端的用户服务。</span></li><li><mark><span>实时操作系统</span></mark><span>：实时是指计算机对于外来信息能够以足够快的速度进行处理并在被控对象允许的时间范围内做出快速反应。实时系统对交互能力要求不高但要求可靠性有保障。</span></li><li><mark><span>网络操作系统</span></mark><span>：是使联网计算机能方便而有效地共享网络资源，为网络用户提供各种服务的软件和有关协议的集合。三种模式:集中模式、客户端/服务器模式、对等模式。</span></li><li><mark><span>分布式操作系统</span></mark><span>：分布式计算机系统是由多个分散的计算机经连接而成的计算机系统，系统中的计算机无主、次之分，任意两台计算机可以通过通信交换信息。</span></li><li><mark><span>微型计算机操作系统</span></mark><span>：简称微机操作系统，常用的有Windows、Mac os.，linux。</span></li></ul></li><li><p><span>嵌入式操作系统特点</span></p><ul><li><mark><span>微型化</span></mark><span>：从性能和成本角度考虑，希望占用的资源和系统代码量少，如内存少、字长短、运行速度有限、能源少 (用微小型电池)</span></li><li><mark><span>可定制</span></mark><span>：从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的微处理器平台上，能针对硬件变化进行结构与功能上的配置，以满足不同应用需要。</span></li><li><mark><span>实时性</span></mark><span>：嵌入式操作系统主要应用于过程控制、数据采集、传输通信、多媒体信息及关键要害领域需要迅速响应的场合，所以对实时性要求较高。</span></li><li><mark><span>可靠性</span></mark><span>：系统构件、模块和体系结构必须达到应有的可靠性，对关键要害应用还要提供容错和防故障措施。</span></li><li><mark><span>易移植性</span></mark><span>：为了提高系统的易移植性，通常采用硬件抽象层和板级支撑包的底层设计技术</span></li></ul></li><li><p><span>嵌入式系统初始化过程按照自底向上、从硬件到软件的次序依次为:</span><mark><span>片级初始化&gt;板级初始化&gt;系统初始化</span></mark></p></li><li><p><span>计算机启动的基本流程为: </span><mark><span>BIOS-&gt;主引导记录-&gt;操作系统</span></mark></p></li></ul><h3><a name="span-id进程管理进程管理span" class="md-header-anchor"></a><span id="进程管理"><span>进程管理</span></span></h3><h4><a name="进程组成和状态" class="md-header-anchor"></a><span>进程组成和状态</span></h4><ul><li><p><strong><span>进程的组成</span></strong><span>: 进程控制块PCB(唯一标志)、程序(描述进程要做什么)、数据(存放进程执行时所需数据)</span></p></li><li><p><span>进程基础的状态是下左图中的三态图。需要熟练掌握下图中的进程三态之间的转换</span></p><p><img src="http://qn.qs520.mobi/image-20230207150137955.png" referrerpolicy="no-referrer" alt="image-20230207150137955"><span> </span></p></li></ul><h4><a name="前趋图" class="md-header-anchor"></a><span>前趋图</span></h4><ul><li><p><span>用来表示哪些任务可以并行执行，哪些任务之间有顺序关系，具体如下图:可知，A B C可以并行执行，但是必须A B C都执行完后，才能执行D，这就确定了两点: </span><mark><span>任务间的并行、任务间的先后顺序</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230207151359315.png" referrerpolicy="no-referrer" alt="image-20230207151359315"><span> </span></p></li></ul><h5><a name="进程资源图" class="md-header-anchor"></a><span>进程资源图</span></h5><ul><li><p><span>用来表示</span><mark><span>进程和资源之间的分配和请求关系</span></mark><span>如下图所示:</span></p><p><img src="http://qn.qs520.mobi/image-20230207151806577.png" referrerpolicy="no-referrer" alt="image-20230207151806577"><span> </span></p></li><li><p><mark><span>P代表进程，R代表资源</span></mark><span>，R方框中有几个圆球就表示有几个这种资源，在上图中，R1指向P1，表示R1有一个资源已经分配给了P1，P1指向R2，表示P1还需要请求一个R2资源才能执行。</span></p></li><li><p><strong><span>阻塞节点</span></strong><span>:某进程</span><mark><span>所请求的资源已经全部分配完毕</span></mark><span>，无法获取所需资源，该进程被阻塞了无法继续。如上图中P2。</span><strong><span>非阻寨节点</span></strong><span>: </span><mark><span>某进程所请求的资源还有剩余</span></mark><span>，可以分配给该进程继续运行如上图中P1、P3。</span></p></li><li><p><span>当一个进程资源图中</span><mark><span>所有进程都是阻寨节点时，即陷入死锁状态</span></mark></p></li></ul><h4><a name="进程同步与互斥" class="md-header-anchor"></a><span>进程同步与互斥</span></h4><ul><li><p><span>临界资源: </span><mark><span>各进程间需要以互斥方式</span></mark><span>对其进行访问的资源。</span></p></li><li><p><span>临界区: 指进程中对临界资源实施操作的那段程序。本质是一段程序代码</span></p></li><li><p><span>互斥: 某资源(即临界资源) </span><mark><span>在同一时间内只能由一个任务单独使用</span></mark><span>，使用时需要加锁，使用完后解锁才能被其他任务使用;如打印机。</span></p></li><li><p><span>同步: </span><mark><span>多个任务可以并发执行，只不过有速度上的差异</span></mark><span>, 在一定情况下停下等待, 不存在资源是否单独或共享的问题;如自行车和汽车。</span></p></li><li><p><span>互斥信号量: 对临界资源采用互斥访问，使用互斥信号量后其他进程无法访问，</span><mark><span>初值为1</span></mark><span>。</span></p></li><li><p><span>同步信号量: 对共享资源的访问控制，</span><mark><span>初值一般是共享资源的数量</span></mark></p></li><li><p><span>P</span><mark><span>操作: 申请资源S=S-1</span></mark><span>，若S&gt;=0，则执行P操作的进程继续执行;若S&lt;0，则置该进程为阻塞状态(因为无可用资源)，并将其插入阻塞队列。</span></p></li><li><p><mark><span>V操作: 释放资源，S=S+1</span></mark><span>，若S&gt;0，则执行V操作的进程继续执行;若S&lt;=0则从阻塞状态唤醒一个进程，并将其插入就绪队列(此时因为缺少资源被P操作阻塞的进程可以继续执行)，然后执行V操作的进程继续</span></p><p><img src="http://qn.qs520.mobi/image-20230207154254344.png" referrerpolicy="no-referrer" alt="image-20230207154254344"><span> </span></p></li></ul><h4><a name="进程调度" class="md-header-anchor"></a><span>进程调度</span></h4><ul><li><p><span>进程调度方式是指</span><mark><span>当有更高优先级的进程到来时如何分配CPU</span></mark><span>。</span><mark><span>分为可剥夺和不可剥夺两种</span></mark><span>，可剥夺指当有更高优先级进程到来时，强行将正在运行进程的CPU分配给高优先级进程;不可剥夺是指高优先级进程必须等待当前进程自动释放CPU。</span></p></li><li><p><strong><span>在某些操作系统中，一个作业从提交到完成需要经历高、中、低三级调度</span></strong></p><ul><li><span>高级调度。高级调度又称“长调度”“作业调度”或“接纳调度”，它决定</span><mark><span>处于输入池中的哪个后备作业可以调入主系统做好运行的准备</span></mark><span>，成为一个或组就绪进程。在系统中一个作业只需经过一次高级调度。</span></li><li><span>中级调度。中级调度又称“中程调度”或“对换调度”，它决定</span><mark><span>处于交换区中的哪个就绪进程可以调入内存</span></mark><span>，以便直接参与对CPU 的竞争。</span></li><li><span>低级调度。低级调度又称“短程调度”或“进程调度”，它决定</span><mark><span>处于内存中的哪个就绪进程可以占用CPU</span></mark><span>。低级调度是操作系统中最活跃、最重要的调度程序，对系统的影响很大。</span></li></ul></li><li><p><strong><span>调度算法</span></strong></p><ul><li><p><mark><span>先来先服务FCFS</span></mark><span>:先到达的进程优先分配CPU。用于宏观调度。</span></p></li><li><p><mark><span>时间片轮转</span></mark><span>:分配给每个进程CPU时间片，轮流使用CPU，每个进程时间片大小相同，很公平，用于微观调度。</span></p></li><li><p><mark><span>优先级调度</span></mark><span>:每个进程都拥有一个优先级，优先级大的先分配CPU。</span></p></li><li><p><mark><span>多级反馈调度</span></mark><span>:时间片轮转和优先级调度结合而成，设置多个就绪队列1,2,3...n，每个队列分别赋予不同的优先级，分配不同的时间片长度:新进程先进入队列1的末尾，按FCFS原则，执行队列1的时间片;若未能执行完进程，则转入队列2的末尾，如此重复。</span></p><p><img src="http://qn.qs520.mobi/image-20230207171622813.png" referrerpolicy="no-referrer" alt="image-20230207171622813"><span> </span></p></li></ul></li></ul><h4><a name="死锁" class="md-header-anchor"></a><span>死锁</span></h4><ul><li><span>当一个进程在等待永远不可能发生的事件时，就会产生死锁，若系统中有多个进程处于死锁状态，就会造成系统死锁。死锁产生的四个必要条件: </span><mark><span>资源互斥、每个进程占有资源并等待其他资源系统不能剥夺进程资源、进程资源图是一个环路</span></mark></li><li><span>死锁产生后，解决措施是打破四大条件，有下列方法:</span></li><li><strong><span>死锁预防</span></strong><span>:采用某种策略限制并发进程对于资源的请求，破坏死锁产生的四个条件之一，使系统任何时刻都不满足死锁的条件。</span></li><li><strong><span>死锁避免</span></strong><span>:一般采用银行家算法来避免，银行家算法，就是提前计算出一条不会死锁的资源分配方法，才分配资源，否则不分配资源，相当于借贷，考虑对方还得起才借钱，提前考虑好以后，就可以避免死锁。</span></li><li><strong><span>死锁检测</span></strong><span>:允许死锁产生，但系统定时运行一个检测死锁的程序，若检测到系统中发生死锁，则设法加以解除。</span></li><li><strong><span>死锁解除</span></strong><span>:即死锁发生后的解除方法，如强制剥夺资源，撤销进程等。</span></li><li><mark><span>死锁资源计算</span></mark><span>:系统内有n个进程，每个进程都需要R个资源，那么其</span><mark><span>发生死锁的最大资源数为n</span><em><span>(R-1)。其不发生死锁的最小资源数为n</span></em><span>(R-1)+1.</span></mark></li></ul><h4><a name="线程" class="md-header-anchor"></a><span>线程</span></h4><ul><li><span>传统的进程有两个属性: </span><mark><span>可拥有资源的独立单位;可独立调度和分配的基本单位</span></mark><span>。</span></li><li><span>引入线程的原因是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，故在系统中设置的</span><mark><span>进程数目不宜过多</span></mark><span>，进程切换的频率不宜太高，这就限制了并发程度的提高。引入线程后，将传统进程的两个基本属性分开，</span><mark><span>线程作为调度和分配的基本单位，进程作为独立分配资源的单位</span></mark><span>。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。</span></li><li><span>线程是进程中的一个实体，是被系统独立分配和调度的基本单位。</span><mark><span>线程基本上不拥有资源，只拥有一点运行中必不可少的资源(如程序计数器、一组寄存器和栈)，它可与同属一个进程的其他线程共享进程所拥有的全部资源</span></mark><span>，例如进程的公共数据、全局变量、代码、文件等资源，但</span><mark><span>不能共享线程独有的资源</span></mark><span>如线程的栈指针等标识数据。</span></li></ul><h3><a name="span-id存储管理存储管理span" class="md-header-anchor"></a><span id="存储管理"><span>存储管理</span></span></h3><h4><a name="分区存储管理" class="md-header-anchor"></a><span>分区存储管理</span></h4><ul><li><p><span>所谓分区存储组织，就是</span><mark><span>整存，将某进程运行所需的内存整体一起分配</span></mark><span>给它，然后再执行。有三种分区方式:</span></p></li><li><p><strong><span>固定分区</span></strong><span>:静态分区方法，将主存分为若千个固定的分区，将要运行的作业装配进去，由于分区固定，大小和作业需要的大小不同，会产生内部碎片</span></p></li><li><p><strong><span>可变分区</span></strong><span>:动态分区方法，主存空间的分区是在作业转入时划分，正好划分为作业需要的大小，这样就不存在内部碎片，但容易将整片主存空间切割成许多块，会产生外部碎片。可变分区的算法如下:系统分配内存的算法有很多，如下图所示，根据分配前的内存情况，还需要分配9K空间，对不同算法的结果介绍如下:</span></p><ul><li><p><span>首次适应法:按内存地址顺序从头查找，找到第一个&gt;=9K空间的空闲块，即切割9K空间分配给进程。</span></p></li><li><p><span>最佳适应法:将内存中所有空闲内存块按从小到大排序，找到第一个&gt;=9K空间的空闲块，切割分配，这个将会找到与9K空间大小最相近的空闲块。</span></p></li><li><p><span>最差适应法:和最佳适应法相反，将内存中空闲块空间最大的，切割9K空间分配给进程，这是为了预防系统中产生过多的细小空闲块。</span></p></li><li><p><span>循环首次适应法: 按内存地址顺序查找，找到第一个&gt;=9K空间的空闲块，而后若还需分配，则找下一个，不用每次都从头查找，这是与首次适应法不同的</span></p><p><img src="http://qn.qs520.mobi/image-20230207194709272.png" referrerpolicy="no-referrer" alt="image-20230207194709272"><span> </span></p></li></ul></li><li><p><strong><span>可重定位分区</span></strong><span>:可以解决碎片问题，移动所有已经分配好的区域，使其成为一个连续的区域，这样其他外部细小的分区碎片可以合并为大的分区，满足作业要求。只在外部作业请求空间得不到满足时进行。</span></p></li></ul><h4><a name="分页存储管理" class="md-header-anchor"></a><span>分页存储管理</span></h4><ul><li><p><mark><span>逻辑页分为页号和页内地址</span></mark><span>，页内地址就是物理偏移地址，而页号与物理块号并非按序对应的，需要查询页表，才能得知页号对应的物理块号，再用物理块号加上偏移地址才得出了真正运行时的物理地址。优点:利用率高，碎片小，分配及管理简单缺点:增加了系统开销，可能产生抖动现象</span></p><p><img src="http://qn.qs520.mobi/image-20230207195500403.png" referrerpolicy="no-referrer" alt="image-20230207195500403"><span> </span></p></li><li><p><strong><span>页面置换算法</span></strong></p><ul><li><strong><span>最优算法</span></strong><span>:OPT，理论上的算法，无法实现，是在进程执行完后进行的最佳效率计算，用来让其他算法比较差距。原理是选择未来最长时间内不被访问的页面置换，这样可以保证未来执行的都是马上要访问的。</span></li><li><strong><span>先进先出算法</span></strong><span>:FIFO，先调入内存的页先被置换淘汰，会产生</span><strong><span>抖动现象</span></strong><span>，即分配的页数越多，缺页率可能越多 (即效率越低)</span></li><li><strong><span>最近最少使用</span></strong><span>:LRU，在最近的过去，进程执行过程中，过去最少使用的页面被置换淘汰，根据局部性原理，这种方式效率高，且不会产生抖动现象，使用大量计数器，但是没有LFU多。</span></li><li><strong><span>淘汰原则</span></strong><span>:优先淘汰最近未访问的，而后淘汰最近未被修改的页面</span></li></ul></li><li><p><span>快表(快速页表，存放在cache中)</span></p></li><li><p><span>是</span><mark><span>一块小容量的相联存储器</span></mark><span>，由快速存储器组成，</span><mark><span>按内容访问，速度快</span></mark><span>，并且可以从硬件上保证按内容并行查找，一般用来</span><mark><span>存放当前访问最频繁的少数活动页面的页号</span></mark></p></li><li><p><span>快表是将页表</span><mark><span>存于Cache</span></mark><span>中;慢表是将页表存于内存上。慢表需要访问两次内存才能取出页，而快表是访问一次Cache和一次内存，因此更快。</span></p></li></ul><h4><a name="分段存储管理" class="md-header-anchor"></a><span>分段存储管理</span></h4><ul><li><p><span>将进程空间分为一个个段，</span><mark><span>每段也有段号和段内地址</span></mark><span>,与页式存储不同的是</span><mark><span>每段物理大小不同，分段是根据逻辑整体分段的</span></mark><span>，因此，段表也与页表的内容不同，页表中直接是逻辑页号对应物理块号，而下图所示，</span><mark><span>段表有段长和基址两个属性</span></mark><span>，才能确定一个逻辑段在物理段中的位置。</span></p><p><img src="http://qn.qs520.mobi/image-20230207201820654.png" referrerpolicy="no-referrer" alt="image-20230207201820654"><span> </span></p></li></ul><h4><a name="段页式存储管理" class="md-header-anchor"></a><span>段页式存储管理</span></h4><ul><li><p><span>对进程空间</span><mark><span>先分段，后分页</span></mark><span>，具体原理图和优缺点如下:优点:空间浪费小、存储共享容易、存储保护容易、能动态链接。缺点:由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加，使得执行速度大大下降</span></p><p><img src="http://qn.qs520.mobi/image-20230207202333191.png" referrerpolicy="no-referrer" alt="image-20230207202333191"><span> </span></p></li></ul><h3><a name="span-id设备管理设备管理span" class="md-header-anchor"></a><span id="设备管理"><span>设备管理</span></span></h3><h4><a name="设备管理概述" class="md-header-anchor"></a><span>设备管理概述</span></h4><ul><li><p><span>设备是</span><mark><span>计算机系统与外界交互的工具，具体负责计算机与外部的输入/输出工作.所以常称为外部设备 (简称外设)</span></mark><span> 。在计算机系统中，将负责管理设备和输入/输出的机构称为I/0 系统。因此，I/0 系统由设备、控制器、通道(具有通道的计算机系统)、总线和I/0 软件组成。</span></p></li><li><p><span>设备的分类:</span></p><ul><li><mark><span>按数据组织分类</span></mark><span>: 块设备、字符设备。</span></li><li><mark><span>按照设备功能分类</span></mark><span>: 输入设备、输出设备、存储设备、网络联网设备、供电设备。</span></li><li><mark><span>资源分配角度分类</span></mark><span>: 独占设备、共享设备和虚拟设备。</span></li><li><mark><span>数据传输速率分类</span></mark><span>: 低速设备、中速设备、高速设备。</span></li></ul></li><li><p><span>设备管理的任务是保证在多道程序环境下，当多个进程竞争使用设备时，按一定的策略</span><mark><span>分配和管理</span></mark><span>各种设备，控制设备的各种操作，完成I/0 设备与主存之间的数据交换。</span></p></li><li><p><span>设备管理的主要功能是</span><mark><span>动态地掌握并记录设备的状态</span></mark><span>、设备分配和释放、缓冲区管理、实现物理I/0 设备的操作、提供设备使用的用户接口及设备的访问和控制</span></p></li></ul><h4><a name="io软件考点）" class="md-header-anchor"></a><span>I/O软件（考点）</span></h4><ul><li><p><span>I/0设备管理软件的所有层次及每一层功能如下图:</span></p></li><li><p><span>实例:当用户程序试图读一个硬盘文件时，需要通过操作系统实现这一操作.</span><mark><span>与设备无关软件检查高速缓存中有无要读的数据块</span></mark><span>，若没有，则</span><mark><span>调用设备驱动程序</span></mark><span>，</span><mark><span>向I/0 硬件发出一个请求</span></mark><span>。然后，用户进程阻塞并等待磁盘操作的完成</span><mark><span>当磁盘操作完成时，硬件产生一个中断，转入中断处理程序</span></mark><span>。中断处理程序检查中断的原因，</span><mark><span>认识到这时磁盘读取操作已经完成，于是唤醒用户进程取回从磁盘读取的信息，从而结束此次I/0 请求</span></mark><span>。用户进程在得到了所需的硬盘文件内容之，后继续运行。</span></p><p><img src="http://qn.qs520.mobi/image-20230208110215329.png" referrerpolicy="no-referrer" alt="image-20230208110215329"><span> </span></p></li></ul><h4><a name="设备管理技术" class="md-header-anchor"></a><span>设备管理技术</span></h4><ul><li><p><span>一台独占设备，在同一时间只能由一个进程使用，其他进程只能等待，且不知道什么时候打印机空闲，此时，极大的浪费了外设的工作效率。</span></p></li><li><p><span>引入</span><mark><span>SPOOLING(外围设备联机操作) 技术</span></mark><span>，就是在外设上建立两个数据缓冲区，分别称为输入井和输出井，这样，无论多少进程，都可以共用这一台打印机，只需要将打印命令发出，数据就会排队存储在缓冲区中，打印机会自动按顺序打印，实现了物理外设的共享，</span><mark><span>使得每个进程都感觉在使用一个打印机，这就是物理设备的虚拟化</span></mark><span>。如下图所示</span></p><p><img src="http://qn.qs520.mobi/image-20230208110320197.png" referrerpolicy="no-referrer" alt="image-20230208110320197"><span> </span></p></li></ul><h3><a name="span-id文件管理文件管理span" class="md-header-anchor"></a><span id="文件管理"><span>文件管理</span></span></h3><h4><a name="文件管理概述" class="md-header-anchor"></a><span>文件管理概述</span></h4><ul><li><p><span>文件是</span><mark><span>具有符号名的、在逻辑上具有完整意义的一组相关信息项的集合</span></mark></p></li><li><p><strong><span>信息项是构成文件内容的基本单位</span></strong><span>，可以是一个字符，也可以是一个记录记录可以等长，也可以不等长。一个文件包括</span><mark><span>文件体和文件说明</span></mark><span>。文件体是文件真实的内容。文件说明是操作系统为了管理文件所用到的信息，包括文件名文件内部标识、文件的类型、文件存储地址、文件的长度、访问权限、建立时间和访问时间等。</span></p></li><li><p><span>文件管理系统，就是</span><mark><span>操作系统中实现文件统一管理的一组软件和相关数据的集合，专门负责管理和存取文件信息的软件机构</span></mark><span>，简称文件系统。文件系统的功能包括按名存取;统一的用户接口;并发访问和控制;安全性控制;优化性能;差错恢复。</span></p></li><li><p><span>文件的类型</span></p><ul><li><span>按文件性质和用途可将文件分为系统文件、库文件和用户文件</span></li><li><span>按信息保存期限分类可将文件分为临时文件、档案文件和永久文件。</span></li><li><span>按文件的保护方式分类可将文件分为只读文件、读/写文件、可执行文件和不保护文件。</span></li><li><span>UNIX 系统将文件分为普通文件、目录文件和设备文件 (特殊文件)</span></li></ul></li><li><p><span>文件的逻辑结构可分为两大类: </span><mark><span>有结构的记录式文件，无结构的流式文件</span></mark></p></li><li><p><span>文件的物理结构是指文件</span><mark><span>在物理存储设备上的存放方法</span></mark><span>，包括:</span></p><ul><li><span>(1)连续结构。连续结构也称顺序结构，</span><mark><span>它将逻辑上连续的文件信息(如记录依次存放在连续编号的物理块上</span></mark><span>。</span></li><li><span>(2)链接结构。链接结构也称串联结构，</span><mark><span>它是将逻辑上连续的文件信息 (如记录)存放在不连续的物理块上</span></mark><span>，</span><mark><span>每个物理块设有一个指针指向下一个物理块</span></mark></li><li><span>(3)索引结构。</span><mark><span>将逻辑上连续的文件信息 (如记录)存放在不连续的物理块</span></mark><span>中系统为每个文件建立一张索引表。</span><mark><span>索引表记录了文件信息所在的逻辑块号对应的物理块号</span></mark><span>，并将索引表的起始地址放在与文件对应的文件目录项中。</span></li><li><span>(4)多个物理块的索引表。</span><mark><span>索引表是在文件创建时由系统自动建立的</span></mark><span>，并与文件一起存放在同一文件卷上。根据一个文件大小的不同，其索引表占用物理块的个数不等，一般占一个或几个物理块。</span></li></ul></li></ul><h4><a name="索引文件结构" class="md-header-anchor"></a><span>索引文件结构</span></h4><ul><li><p><span>如图所示，系统中有13个索引节点，0-9为</span><mark><span>直接索引，即每个索引节点存放的是内容</span></mark><span>，假设每个物理盘大小为4KB，共可存</span><code>4KB* 10=40KB</code><span>数据:*</span></p></li><li><p><span>10号索引节点为</span><mark><span>一级间接索引节点，大小为4KB，存放的并非直接数据，而是链接到直接物理盘块的地址</span></mark><span>，假设每个地址占4B，则共有1024个地址，对应1024个物理盘，可存</span><code>1024*4KB=4096KB</code><span>数据。</span></p></li><li><p><mark><span>二级索引节点类似，直接盘存放一级地址，一级地址再存放物理盘快地址，而后链接到存放数据的物理盘块</span></mark><span>，容量又扩大了一个数量级，为1024 * 1024 * 4KB数据。</span></p><p><img src="http://qn.qs520.mobi/image-20230208145531038.png" referrerpolicy="no-referrer" alt="image-20230208145531038"><span> </span></p></li></ul><h4><a name="文件目录" class="md-header-anchor"></a><span>文件目录</span></h4><ul><li><p><span>文件控制块中包含以下三类信息:基本信息类、存取控制信息类和使用信息类。</span></p><ul><li><span>(1)基本信息类。例如文件名、文件的物理地址、文件长度和文件块数等。</span></li><li><span>(2)存取控制信息类。文件的存取权限，像UNIX 用户分成文件主、同组用户和一般用户三类，这三类用户的读/写执行</span>
<span>RWX权限。</span></li><li><span>(3)使用信息类。文件建立日期、最后一次修改日期、最后一次访问的日期、当前使用的信息(如打开文件的进程数在文件上的等待队列)等。</span></li></ul></li><li><p><mark><span>文件控制块的有序集合称为文件目录</span></mark></p><ul><li><span>相对路径: 是从</span><mark><span>当前路径</span></mark><span>开始的路径</span></li><li><span>绝对路径: 是从</span><mark><span>根目录开始</span></mark><span>的路径。</span></li><li><mark><span>全文件名=绝对路径+文件名</span></mark><span>。要注意，绝对路径和相对路径是不加最后的文件名的，只是单纯的路径序列。</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230208165008204.png" referrerpolicy="no-referrer" alt="image-20230208165008204"><span> </span></p></li></ul><h4><a name="文件存储空间管理" class="md-header-anchor"></a><span>文件存储空间管理</span></h4><ul><li><p><span>文件的存取方法是</span><mark><span>指读/写文件存储器上的一个物理块的方法</span></mark><span>。通常有</span><mark><span>顺序存取和随机存取</span></mark><span>两种方法。顺序存取方法是指对文件中的信息按顺序依次进行读写;随机存取方法是指对文件中的信息可以按任意的次序随机地读/写。</span></p></li><li><p><span>文件存储空间的管理:</span></p><ul><li><p><span>(1)空闲区表。将外存空间上的一个连续的未分配区域称为“空闲区”。操作系统为磁盘外存上的所有空闲区建立一张空闲表，每个表项对应一个空闲区，适用于连续文件结构。</span></p><p><img src="http://qn.qs520.mobi/image-20230208165121545.png" referrerpolicy="no-referrer" alt="image-20230208165121545"><span> </span></p></li><li><p><span>(2)位示图。这种方法是在外存上建立一张位示图 (Bitmap)记录文件存储器的使用情况。</span><mark><span>每一位对应文件存储器上的一个物理块，取值0 和1 分别表示空闲和占用</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230208165230093.png" referrerpolicy="no-referrer" alt="image-20230208165230093"><span> </span></p></li><li><p><span>(3)空闲块链。每个空闲物理块中有指向下一个空闲物理块的指针，所有空闲物理块构成一个链表，链表的头指针放在文件存储器的特定位置上(如管理块中)，不需要磁盘分配表，节省空间。</span></p></li><li><p><span>(4)成组链接法。例如，在实现时系统将空闲块分成若干组，每100个空闲块为一组，每组的第一个空闲块登记了下一组空闲块的物理盘块号和空闲块总数。假如某个组的第一个空闲块号等于0，意味着该组是最后一组，无下一组空闲块。</span></p></li></ul></li></ul><h2><a name="span-id4数据库技术基础4数据库技术基础案例分析考点4span" class="md-header-anchor"></a><span id="4.数据库技术基础"><span>4.数据库技术基础(案例分析考点4)</span></span></h2><p><mark><span>通读教材：第五章 数据库系统</span></mark></p><h3><a name="span-id数据库基本概念数据库基本概念span" class="md-header-anchor"></a><span id="数据库基本概念"><span>数据库基本概念</span></span></h3><h4><a name="数据库系统" class="md-header-anchor"></a><span>数据库系统</span></h4><ul><li><p><span>数据:是数据库中存储的基本对象，是描述事物的符号记录数据的种类:文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等。</span></p></li><li><p><span>数据库DB: 是长期存储在计算机内、有组织的、可共享的大量数据的集合。</span></p></li><li><p><span>数据库的基本特征:</span></p><ul><li><span>数据按一定的数据模型组织、描述和存储;可为各种用户共享;</span></li><li><span>元余度较小;</span></li><li><span>数据独立性较高;</span></li><li><span>易扩展。</span></li></ul></li><li><p><span>数据库系统DBS:是一个采用了数据库技术，有组织地、动态地存储大量相关数据，方便多用户访问的计算机系统。其由下面四个部分组成:</span></p><ul><li><span>数据库(统一管理、长期存储在计算机内的，有组织的相关数据的集合)</span></li><li><span>硬件(构成计算机系统包括存储数据所需的外部设备)</span></li><li><span>软件(操作系统、数据库管理系统及应用程序)</span></li><li><span>人员(系统分析和数据库设计人员、应用程序员、最终用户、数据库管理员DBA</span></li></ul></li><li><p><span>数据库管理系统DBMS的功能</span></p><ul><li><span>实现对共享数据有效的组织、管理和存取。包括数据定义、数据库操作、数据库运行管理、数据的存储管理、数据库的建立和维护等。</span></li></ul></li></ul><h4><a name="三级模式-两级映像考点" class="md-header-anchor"></a><span>三级模式-两级映像(考点)</span></h4><ul><li><p><mark><span>内模式</span></mark><span>: 管理如何存储物理的数据，对应具体物理存储文件</span></p></li><li><p><mark><span>模式:</span></mark><span> 又称为概念模式，就是我们通常使用的基本表，根据应用、需求将物理数据划分成一张张表。</span></p></li><li><p><mark><span>外模式</span></mark><span>: 对应数据库中的视图这个级别，将表进行一定的处理后再提供给用户使用</span></p></li><li><p><mark><span>外模式一模式映像</span></mark><span>: 是表和视图之间的映射，存在于概念级和外部级之间，若表中数据发生了修改，只需要修改此映射，而无需修改应用程序。</span></p></li><li><p><mark><span>模式一内模式映像</span></mark><span>: 是表和数据的物理存储之间的映射，存在于概念级和内部级之间，若修改了数据存储方式，只需要修改此映射，而不需要去修改应用程序。</span></p><p><img src="http://qn.qs520.mobi/image-20230208204153776.png" referrerpolicy="no-referrer" alt="image-20230208204153776"><span> </span></p></li></ul><h4><a name="数据库设计" class="md-header-anchor"></a><span>数据库设计</span></h4><ul><li><p><mark><span>需求分析</span></mark><span>: 即分析数据存储的要求，</span><mark><span>产出物有数据流图，数据字典、需求说明书</span></mark></p></li><li><p><mark><span>概念结构设计</span></mark><span>: 就是设计</span><mark><span>E-R图</span></mark><span>，也即实体-联系图，与物理实现无关，说明有哪些实体，实体有哪些属性。</span></p><ul><li><span>步骤：</span><mark><span>抽象数据一设计局部视图一合并取消冲突一修改重构消除冗余</span></mark></li></ul></li><li><p><mark><span>逻辑结构设计</span></mark><span>: </span><mark><span>将E-R图，转换成关系模式</span></mark><span>，也即转换成实际的表和表中的列属性，这里要考虑很多</span><mark><span>规范化的东西。先转换再规范</span></mark></p><ul><li><span>任务：是将E-R图</span><strong><span>转成数据模式(</span></strong><span>如:关系模式)，然后通过</span><strong><span>规范化</span></strong><span>将其结构调整好，并做相应的</span><strong><span>优化</span></strong><span>，最后是</span><strong><span>形成用户模式</span></strong><span>。</span></li></ul></li><li><p><mark><span>物理设计</span></mark><span>: 根据生成的表等概念，</span><mark><span>生成物理数据库</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230208204312860.png" referrerpolicy="no-referrer" alt="image-20230208204312860"><span> </span></p></li></ul><h4><a name="数据模型" class="md-header-anchor"></a><span>数据模型</span></h4><ul><li><p><mark><span>关系模型是二维表的形式表示的实体-联系模型</span></mark><span>，是将实体-联系模型转换而来的，经过开发人员设计的;</span></p></li><li><p><mark><span>概念模型是从用户的角度进行建模的</span></mark><span>，是现实世界到信息世界的第一抽象，是真正的实体-联系模型。</span></p></li><li><p><span>网状模型表示实体类型及其实体之间的联系，一个事物和另外几个都有联系形成一张网。</span></p></li><li><p><span>面向对象模型是采用面向对象的方法设计数据库，以对象为单位，每个对象包括属性和方法，具有类和继承等特点，</span></p><ul><li><mark><span>对象三要素：属性(数据)、方法(操作)、对象 ID(标识)。</span></mark></li></ul></li><li><p><span>数据模型三要素:</span></p><ul><li><mark><span>数据结构</span></mark><span>(所研究的对象类型的集合)、</span></li><li><mark><span>数据操作</span></mark><span>(对数据库中各种对象的实例允许执行的操作的集合)、</span></li><li><mark><span>数据的约束条件</span></mark><span> (一组完整性规则的集合)。</span></li></ul></li><li><p><span>用E-R图来描述概念数据模型，世界是由一组称作实体的基本对象和这些对象之间的联系构成的。</span></p></li><li><p><span>在E-R模型中，使用</span><mark><span>椭圆表示属性 (一般没有) 、长方形表示实体、萎形表示联系，联系的两端要填写联系类型</span></mark><span>示例如下图:</span></p><p><img src="http://qn.qs520.mobi/image-20230208210708944.png" referrerpolicy="no-referrer" alt="image-20230208210708944"><span> </span></p></li><li><p><span>实体:客观存在并可相互区别的事物。可以是具体的人、事、物或抽象概念。如人、汽车、图书、账户、贷款。</span></p></li><li><p><span>弱实体和强实体:弱实体(</span><strong><span>两边有竖线的长方形</span></strong><span>)依赖于强实体的存在而存在。</span></p></li><li><p><span>实体集:具有相同类型和共享相同属性的实体的集合，如学生、课程</span></p></li><li><p><span>属性:</span><mark><span>实体所具有的特性</span></mark></p></li><li><p><span>属性分类:简单属性和复合属性;单值属性和多值属性; NULL属性;派生属性</span></p></li><li><p><span>域:属性的取值范围称为该属性的域</span></p></li><li><p><span>码 (key):唯一标识实体的属性集</span></p></li><li><p><span>联系:</span><mark><span>现实世界中事物内部以及事物之间的联系，在E-R图中反映为实体内部的联系和实体之间的联系</span></mark></p></li><li><p><span>联系类型:</span><mark><span>一对一1:1、一对多1:N、多对多M:N</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230208211011663.png" referrerpolicy="no-referrer" alt="image-20230208211011663"><span> </span></p></li><li><p><span>关系模型中数据的逻辑结构是一张</span><mark><span>二维表</span></mark><span>，由行列组成。用表格结构表达实体集，用外键标识实体间的联系。如下图:</span></p><p><img src="http://qn.qs520.mobi/image-20230208211059067.png" referrerpolicy="no-referrer" alt="image-20230208211059067"><span> </span></p><ul><li><span>优点:建立在严格的数学概念基础上;概念单一、结构简单、清晰，用户易懂易用，存取路径对用户透明，从而数据独立性、安全性好，简化数据库开发工作。</span></li><li><span>缺点:由于存取路径透明，查询效率往往不如非关系数据模型</span></li></ul></li><li><p><span>E-R模型转换为关系模型:</span><mark><span>每个实体都对应一个关系模式</span></mark><span>;联系分为三种:</span></p><ul><li><span>1:1联系中，联系可以</span><mark><span>放到任意的两端实体中，作为一个属性</span></mark><span>(要保证1:1的两端关联)，也可以转换为一个单独的关系模式;</span></li><li><span>1:N的联系中，联系可以单独作为一个关系模式，也可以</span><mark><span>在N端中加入1端实体的主键</span></mark><span>;</span></li><li><span>M:N的联系中，联系</span><mark><span>必须作为一个单独的关系模式，其主键是M和N端的联合主键。</span></mark></li></ul></li></ul><h4><a name="关系代数" class="md-header-anchor"></a><span>关系代数</span></h4><ul><li><p><span>并:结果是两张表中所有记录数合并，相同记录只显示一次。</span></p></li><li><p><span>交:结果是两张表中相同的记录。</span></p></li><li><p><span>差:S1-S2，结果是S1表中有而S2表中没有的那些记录</span></p><p><img src="http://qn.qs520.mobi/image-20230209095409006.png" referrerpolicy="no-referrer" alt="image-20230209095409006"><span> </span></p></li><li><p><mark><span>笛卡尔积(考点)</span></mark><span>: S1 * S2，产生的结果包括S1和S2的所有属性列，并且S1中每条记录依次和S2中所有记录组合成一条记录，最终属性列为S1+S2属性列，记录数为S1*S2记录数。</span></p></li><li><p><mark><span>投影(符号为π)</span></mark><span>:实际是按条件选择某关系模式中的某列，列也可以用数字表示</span></p></li><li><p><mark><span>选择</span></mark><span>:实际是按条件选择某关系模式中的某条记录。</span></p><p><img src="http://qn.qs520.mobi/image-20230209095526411.png" referrerpolicy="no-referrer" alt="image-20230209095526411"><span> </span></p></li><li><p><mark><span>自然连接(考点)</span></mark><span>的结果</span><mark><span>显示全部的属性列，但是相同属性列只显示一次，显示两个关系模式中属性相同且值相同的记录</span></mark><span>。设有关系R、S如下左图所示，自然连接结果如下右图所示:</span></p><p><img src="http://qn.qs520.mobi/image-20230209095637956.png" referrerpolicy="no-referrer" alt="image-20230209095637956"><span> </span></p></li></ul><h3><a name="span-id规范化和开发规范化和开发span" class="md-header-anchor"></a><span id="规范化和开发"><span>规范化和开发</span></span></h3><h4><a name="函数依赖" class="md-header-anchor"></a><span>函数依赖</span></h4><ul><li><p><span>给定一个X，能唯一确定一个Y，就称X确定Y，或者说Y依赖于X，例如Y=X*X函数。</span></p></li><li><p><span>函数依赖又可扩展以下两种规则:</span></p><ul><li><p><strong><span>部分函数依赖</span></strong><span>: A可确定C，(A,B)也可确定C，</span><mark><span>(A,B)中的一部分 (即A) 可以确定C，称为部分函数依赖</span></mark><span>。</span></p></li><li><p><strong><span>传递函数依赖</span></strong><span>:当A和B不等价时，</span><mark><span>A可确定B，B可确定C，则A可确定C</span></mark><span>，是传递函数依赖;若A和B等价，则不存在传递，直接就可确定C。</span></p><p><img src="http://qn.qs520.mobi/image-20230209104103273.png" referrerpolicy="no-referrer" alt="image-20230209104103273"><span> </span></p></li></ul></li></ul><h4><a name="键与约束" class="md-header-anchor"></a><span>键与约束</span></h4><ul><li><span>超键: 能</span><mark><span>唯一标识</span></mark><span>此表的属性的组合。</span></li><li><span>候选键: 超键中</span><mark><span>去掉冗余的属性</span></mark><span>，剩余的属性就是候选键</span></li><li><span>主键:</span><mark><span>任选一个候选键</span></mark><span>，即可作为主键。</span></li><li><span>外键:</span><mark><span>其他表中的主键</span></mark><span>。</span></li><li><span>主属性:</span><mark><span>候选键内的属性为主属性</span></mark><span>，其他属性为非主属性</span></li><li><span>实体完整性约束:</span><mark><span>即主键约束主键值不能为空，也不能重复</span></mark></li><li><span>参照完整性约束:即外键约束，</span><mark><span>外键必须是其他表中已经存在的主键的值</span></mark>
<mark><span>或者为空。</span></mark></li><li><span>用户自定义完整性约束:  </span><mark><span>自定义表达式约束</span></mark><span>，如设定年龄属性的值必须在0到150之间。</span></li></ul><h4><a name="范式难点" class="md-header-anchor"></a><span>范式(难点)</span></h4><ul><li><p><mark><span>第一范式1NF</span></mark><span>: 关系中的</span><mark><span>每一个分量必须是一个不可分的数据项</span></mark><span>。通俗地说，第一范式就是表中不允许有小表的存在。比如，对于如下的员工表，就不属于第一范式:</span></p><p><img src="http://qn.qs520.mobi/image-20230209104632138.png" referrerpolicy="no-referrer" alt="image-20230209104632138"><span> </span></p></li><li><p><span>实例:用一个单一的关系模式学生来描述学校的教务系统:学生(学号,学生姓名,系号,系主任姓名,课程号,成绩)</span></p></li><li><p><mark><span>依赖关系</span></mark><span> (学号-&gt;学生姓名，学号-&gt;系号，系号-&gt;系主任姓名，学号-&gt;课程号，(学号，课程号)&#39;-&gt;成绩)</span></p><p><img src="http://qn.qs520.mobi/image-20230209104733061.png" referrerpolicy="no-referrer" alt="image-20230209104733061"><span> </span></p></li><li><p><span>第二范式</span></p><ul><li><p><span>如果</span><mark><span>关系R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码</span></mark><span>，则R属于2NF。非主属性对主属性的部分函数依赖，如果依赖集中有主键的一部分决定其他非主属性就说明存在非主属性的函数依赖，就不符合2NF</span></p></li><li><p><span>通俗地说，2NF就是在1NF的基础上，</span><mark><span>表中的每一个非主属性不会依赖复合主键中的某一个列</span></mark><span>。按照定义，上面的学生表就不满足2NF，因为学号不能完全确定课程号和成绩(每个学生可以选多门课)。</span></p></li><li><p><span>将学生表分解为如下表后，每张表均属于2NF。</span></p><ul><li><span>学生(学号,学生姓名,系编号,系名,系主任)</span></li><li><span>选课(学号,课程号,成绩) 。</span></li></ul></li></ul></li><li><p><span>第三范式</span></p><ul><li><p><mark><span>在满足1NF的基础上，表中不存在非主属性对码的传递依赖</span></mark></p></li><li><p><span>继续上面的实例，学生关系模式就不属于3NF，因为学生无法直接决定系主任和系名，是由学号-&gt;系编号，再由系编号-&gt;系主任，系编号-&gt;系名，因此存在非主属性对主属性的传递依赖，</span></p></li><li><p><span>将学生表进一步分解为下表后，每张表都属于3NF</span></p><ul><li><span>学生(学号，学生姓名，系编号)</span></li><li><span>系(系编号，系名，系主任)</span></li><li><span>选课(学号,课程号,成绩)</span></li></ul></li></ul></li><li><p><span>BC范式BCNF，是指</span><mark><span>在第三范式的基础上进一步除主属性对于码的部分函数依赖和传递依赖</span></mark><span>。通俗的来说，就是在</span><mark><span>每一种情况下，每一个依赖的左边决定因素都必然包含候选键</span></mark><span>，如下图</span></p><p><img src="http://qn.qs520.mobi/image-20230209105241265.png" referrerpolicy="no-referrer" alt="image-20230209105241265"><span> </span></p></li><li><p><span>上图中，候选键有两种情况: 组合键(S,T)或者(S,J)，依赖集为SJ-T，T一J，可知，STJ三个属性都是主属性，因此其达到了3NF (无非主属性)，然而第二种情况，即(S,J)为候选键的时候，对于依赖T-&gt;J，T在这种情况不是候选键，即T-J的决定因素不包含任意候选码，因此上图不是BCNF</span></p></li><li><p><span>要使上图关系模式转换为BCNF也很简单，只需要将依赖T-&gt;J变为TS-&gt;J即可这样其左边决定因素就包含了候选键之一S</span></p></li><li><p><img src="http://qn.qs520.mobi/image-20230314185237982.png" referrerpolicy="no-referrer" alt="image-20230314185237982"><span> </span></p></li><li><p><strong><span>不规范化带来的四大问题</span></strong></p></li><li><p><span>设有一个关系模式R(SNAME，CNAME，TNAME，TADDRESS)，其属性分别表示学生姓名、选修的课程名、任课教师姓名和任课教师地址。仔细分析一下，就会发现这个模式存在下列存储异常的问题:</span></p><ul><li><mark><span>(1)数据冗余</span></mark><span>: 数据被重复存储，如某门课程有100个学生选修，那么在R的关系中就要出现100个元组，这门课程的任课教师姓名和地址也随之重复出现100次。</span></li><li><mark><span>(2)修改异常</span></mark><span>: 修改导致数据不一致，如由于上述几余问题，当需要修改这个教师的地址时，就要修改100个元组中的地址值，否则就会出现地址值不一致的现象。</span></li><li><mark><span>(3)插入异常</span></mark><span>: 插入时异常，如不知道听课学生名单，这个教师的任课情况和家庭地址就无法讲入数据库。</span></li><li><mark><span>(4)删除异常</span></mark><span>: 删除了不该删除的数据，如当只有一条记录时，要删除这个学生选课信息，会将课程名、教师名和教师地址都给删除了。</span></li></ul></li></ul><h4><a name="模式分解难点）" class="md-header-anchor"></a><span>模式分解（难点）</span></h4><ul><li><p><span>范式之间的转换一般都是通过拆分属性，即模式分解，将具有部分函数依赖和传递依赖的属性分离出来，来达到一步步优化，一般分为以下两种:</span></p></li><li><p><span>(1)</span><strong><span>保持函数依赖分解</span></strong><span>：对于关系模式R，有依赖集F，若对R进行分解，</span><mark><span>分解出来的多个关系模式，保持原来的依赖集不变</span></mark><span>，则为保持函数依赖的分解。另外，注意要消除掉冗余依赖(如传递依赖)</span></p></li><li><p><span>实例:设原关系模式R(A,B,C)，依赖集F(A-&gt;B,B-&gt;C,A-&gt;C)，将其分解为两个关系模式R1(A,B)和R2(B,C)，此时R1中保持依赖A-B，R2保持依赖B-&gt;C，说明分解后的R1和R2是保持函数依赖的分解，因为A-&gt;C这个函数依赖实际是一个冗余依赖，可以由前两个依赖传递得到，因此不需要管。</span></p><p><img src="http://qn.qs520.mobi/image-20230209115545297.png" referrerpolicy="no-referrer" alt="image-20230209115545297"><span> </span></p></li><li><p><strong><span>无损分解</span></strong><span>:分解后的关系模式能够还原出原关系模式，就是无损分解，不能还原就是有损。</span></p></li><li><p><span>当分解为</span><mark><span>两个关系模式</span></mark><span>，可以通过以下定理判断是否无损分解:</span></p><ul><li><p><span>定理:如果R的分解为p={R1，R2}，F为R所满足的函数依赖集合，分解p具有无损连接性的</span><mark><span>充分必要条件是R1 ∩ R2-&gt;(R1 - R2)或者R1 ∩ R2 -&gt; (R2-R1)。解释：R1 ∩ R2根据依赖关系推出(R2-R1) 或(R1 - R2)</span></mark><span>。</span><mark><span>当分解为三个及以上关系模式时，可以通过表格法求解</span></mark><span>，如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230209115746655.png" referrerpolicy="no-referrer" alt="image-20230209115746655"><span> </span></p></li></ul></li></ul><h4><a name="并发控制" class="md-header-anchor"></a><span>并发控制</span></h4><ul><li><p><span>事务:由一系列操作组成，这些操作，要么全做，要么全不做，拥有四种特性，详解如下:</span></p><ul><li><span>(操作) </span><mark><span>原子性</span></mark><span>:要么全做，要么全不做。</span></li><li><span>(数据)</span><mark><span>一致性</span></mark><span>:事务发生后数据是一致的，例如银行转账，不会存在A账户转出，但是B账户没收到的情况。</span></li><li><span>(执行)</span><mark><span>隔离性</span></mark><span>:任一事务的更新操作直到其成功提交的整个过程对其他事务都是不可见的，不同事务之间是隔离的，互不干涉。</span></li><li><span>(改变)</span><mark><span>持续性</span></mark><span>:事务操作的结果是持续性的。</span></li></ul></li><li><p><span>事务是并发控制的前提条件，并发控制就是</span><mark><span>控制不同的事务并发执行</span></mark><span>，提高系统效率，但是并发控制中</span><mark><span>存在下面三个问题</span></mark><span>:</span></p><ul><li><p><mark><span>丢失更新</span></mark><span>:事务1对数据A进行了修改并写回，事务2也对A进行了修改并写回此时事务2写回的数据会覆盖事务1写回的数据，就丢失了事务1对A的更新。即对数据A的更新会被覆盖。</span></p></li><li><p><mark><span>不可重复读</span></mark><span>:事务2读A，而后事务1对数据A进行了修改并写回，此时若事务2再读A，发现数据不对。即一个事务重复读A两次，会发现数据A有误。</span></p></li><li><p><mark><span>读脏数据:</span></mark><span>事务1对数据A进行了修改后，事务2读数据A，而后事务1回滚，数据A恢复了原来的值，那么事务2对数据A做的事是无效的，读到了脏数据。</span></p><p><img src="http://qn.qs520.mobi/image-20230209120137876.png" referrerpolicy="no-referrer" alt="image-20230209120137876"><span> </span></p></li></ul></li></ul><h4><a name="封锁协议" class="md-header-anchor"></a><span>封锁协议</span></h4><ul><li><p><mark><span>x锁是排它锁(写锁)</span></mark><span>。若事务T对数据对象A加上X锁，则只允许T读取和修改，</span><mark><span>其他事务都不能再对A加任何类型的锁</span></mark><span>，直到T释放A上的锁。</span></p></li><li><p><mark><span>s锁是共享锁(读锁)</span></mark><span>。若事务T对数据对象A加上S锁，则只允许T读取A，但不能修改A，</span><mark><span>其他事务只能再对A加S锁</span></mark><span> (也即能读不能修改)，直到T释放A上的S锁。</span></p></li><li><p><span>共分为三级封锁协议，如下</span></p><ul><li><p><span>一级封锁协议: </span><mark><span>事务在修改数据R之前必须先对其加X锁</span></mark><span>直到事务结束才释放。</span><mark><span>可解决丢失更新问题</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230209120326769.png" referrerpolicy="no-referrer" alt="image-20230209120326769"><span> </span></p></li><li><p><span>二级封锁协议: 一级封锁协议的基础上加上事务T</span><mark><span>在读数据R之前必须先对其加S锁，读完后即可释放S锁可解决丢失更新、读脏数据问题</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230209120442297.png" referrerpolicy="no-referrer" alt="image-20230209120442297"><span> </span></p></li><li><p><span>三级封锁协议: 一级封锁协议加上事务T在读取数据R之前先对其加S锁，</span><mark><span>直到事务结束才释放可解决丢失更新、读脏数据、数据重复读问题</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230209120545134.png" referrerpolicy="no-referrer" alt="image-20230209120545134"><span> </span></p></li></ul></li></ul><h3><a name="span-id数据库新技术数据库新技术span" class="md-header-anchor"></a><span id="数据库新技术"><span>数据库新技术</span></span></h3><h4><a name="数据库安全" class="md-header-anchor"></a><span>数据库安全</span></h4><p><img src="http://qn.qs520.mobi/image-20230209150756563.png" referrerpolicy="no-referrer" alt="image-20230209150756563"><span> </span></p><ul><li><span>静态转储:即</span><mark><span>冷备份</span></mark><span>，指在转储期间不允许对数据库进行任何存取、修改操作;优点是非常快速的备份方法、容易归档 (直接物理复制操作);缺点是只能提供到某一时间点上的恢复，不能做其他工作，不能按表或按用户恢复。</span></li><li><span>动态转储:即</span><mark><span>热备份</span></mark><span>，在转储期间允许对数据库进行存取、修改操作，因此，转储和用户事务可并发执行;/优点是可在表空间或数据库文件级备份，数据库扔可使用，可达到秒级恢复;缺点是不能出错，否则后果严重，若热备份不成功，所得结果几乎全部无效。</span></li><li><span>完全备份:备份所有数据。</span></li><li><span>差量备份:仅备份上一次完全备份之后变化的数据</span></li><li><span>增量备份:备份上一次备份之后变化的数据。</span></li><li><mark><span>日志文件</span></mark><span>: 在事务处理过程中，DBMS把事务开始、事务结束以及对数据库的插入、删除和修改的每一次操作写入日志文件。一旦发生故障，DBMS的恢复子系统利用日志文件撤销事务对数据库的改变，回退到事务的初始状态。</span></li></ul><h4><a name="分布式数据库" class="md-header-anchor"></a><span>分布式数据库</span></h4><ul><li><p><span>局部数据库位于不同的物理位置，使用一个全局DBMS将所有局部数据库联网管理，这就是分布式数据库。</span></p><ul><li><strong><span>分布式数据库</span></strong><span>是由一组数据组成的，</span><mark><span>这组数据分布在计算机网络的不同计算机上</span></mark><span>，网络中的</span><mark><span>每个节点具有独立处理的能力(称为场地自治)</span></mark><span>，它可以执行局部应用，同时，</span><mark><span>每个节点也能通过网络通信子系统执行全局应用</span></mark><span>。分布式数据库系统是在集中式数据库系统技术的基础上发展起来的具有如下特点:</span><span>	</span></li></ul><ol start='' ><li><mark><span>数据独立性</span></mark><span>。在分布式数据库系统中，数据独立性这一特性更加重要，并具有更多的内容。</span><mark><span>除了数据的逻辑独立性与物理独立性外，还有数据分布独立性 (分布透明性)。</span></mark></li><li><mark><span>集中与自治共享结合的控制结构</span></mark><span>。各局部的DBMS可以独立地管理局部数据库，具有自治的功能。同时，系统又设有集中控制机制，协调各局部DBMS的工作，执行全局应用。</span></li><li><mark><span>适当增加数据冗余度</span></mark><span>。在不同的场地存储同一数据的多个副本，这样，可以提高系统的可靠性和可用性，同时也能提高系统性能。</span></li><li><mark><span>全局的一致性、可串行性和可恢复性</span></mark></li></ol></li><li><p><span>分布式数据库的优点：</span></p><ol start='' ><li><span>分布式数据库可以解决</span><mark><span>企业部门分散而数据需要相互联系</span></mark><span>的问题</span></li><li><span>如果企业需要</span><mark><span>增加新的相对自主的部门来扩充机构</span></mark><span>，则分布式数据库系统可以在对当前机构影响最小的情况下进行扩充。</span><mark><span>可扩展性好</span></mark></li><li><span>分布式数据库可以</span><mark><span>满足均衡负载的需要</span></mark></li><li><span>当企业已存在几个数据库系统，而且</span><mark><span>实现全局应用的必要性</span></mark><span>增加时，就可以由这些数据库自下而上构成分布式数据库系统</span></li><li><span>相等规模的分布式数据库系统在出现故障的概率上不会比集中式数据库系统低，</span><mark><span>但由于其故障的影响仅限于局部数据应用</span></mark><span>，因此，就整个系统来说，它的</span><mark><span>可靠性是比较高的</span></mark><span>。</span></li></ol></li><li><p><span>分片模式</span></p><ul><li><span>水平分片: 将表中</span><mark><span>水平的记录</span></mark><span>分别存放在不同的地方</span></li><li><span>垂直分片:将表中的</span><mark><span>垂直的列值</span></mark><span>分别存放在不同的地方</span></li></ul></li><li><p><span>分布透明性</span></p><ul><li><p><span>分片透明性:用户或应用程序</span><mark><span>不需要知道逻辑上访问的表具体是如何分块存储</span></mark><span>的。</span></p></li><li><p><span>位置透明性:应用程序不关心</span><mark><span>数据存储物理位置的改变</span></mark></p></li><li><p><span>逻辑透明性:用户或应用程序</span><mark><span>无需知道局部使用的是哪种数据模型</span></mark></p></li><li><p><span>复制透明性:用户或应用程序</span><mark><span>不关心复制的数据从何而来</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230209151055069.png" referrerpolicy="no-referrer" alt="image-20230209151055069"><span> </span></p></li></ul></li><li><p><strong><span>分布式数据库查询优化</span></strong><span>:</span></p><ul><li><span>全局查询树的变换:例如，在做笛卡尔积之前，先进行投影和选择运算。</span></li><li><span>副本的选择与多副本的更新策略:多个副本存在于不同的节点，如何选择</span></li><li><span>查询树的分解:对所有节点采取后续遍历法，直到所有叶节点均被成功地遍历为止。</span></li><li><span>半连接与直接连接等:不需要传递整个关系，只要传送连接时与对方匹配的元组即可</span></li></ul></li></ul><h4><a name="数据仓库" class="md-header-anchor"></a><span>数据仓库</span></h4><ul><li><p><span>数据仓库是一个</span><mark><span>面向主题的、集成的、非易失的、且随时间变化的</span></mark><span>数据集合，用于支持管理决策。</span></p></li><li><p><strong><span>数据仓库集成</span></strong><span>是把多种来源的数据集中在一起，建立数据仓库，所有数据都驻留在单个数据库服务器上，配置大型处理器和存储容量。数据仓库主要用于决策支持，在数据处理过程中强调分析其特点是:</span></p><ul><li><mark><span>面向主题</span></mark><span>:按照一定的主题域进行组织的</span></li><li><mark><span>集成的数据</span></mark><span>: 仓库中的数据是在对原有分散的数据库数据抽取、清理的基础上经过系统加工、汇总和整理得到的，必须消除源数据中的不一致性，以保证数据仓库内的信息是关于整个企业的一致的全局信息。</span></li><li><mark><span>数据相对稳定的</span></mark><span>: 数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一旦某个数据进入数据仓库以后，一般情况下将被长期保留，也就是数据仓库中一般有大量的查询操作，但修改和删除操作很少，通常只需要定期的加载、刷新。</span></li><li><mark><span>反映历史变化</span></mark><span>: 数据仓库中的数据通常包含历史信息，系统记录了企业从过去某一时点(如开始应用数据仓库的时点)到目前的各个阶段的信息，通过这些信息，可以对企业的发展历程和未来趋势做出定量分析和预测。</span></li></ul></li><li><p><span>数据仓库的结构通常包含四个层次如下图所示:(考点)</span></p><ol start='' ><li><p><mark><span>数据源</span></mark><span>:是数据仓库系统的基础，是整个系统的数据源泉。</span></p></li><li><p><mark><span>数据的存储与管理</span></mark><span>:是整个数据仓库系统的核心。</span></p></li><li><p><mark><span>OLAP(联机分析处理) 服务器</span></mark><span>:对分析需要OLAP的数据进行有效集成，按</span><mark><span>多维模型</span></mark><span>组织，以便进行多角度、多层次的分析，并发现趋势。</span></p></li><li><p><mark><span>前端工具</span></mark><span>:主要包括各种报表工具、查询工具、数据分析工具、数据挖掘工具以及各种基于数据仓库或数据集市的应用开发工具。</span></p><p><img src="http://qn.qs520.mobi/image-20230209153216863.png" referrerpolicy="no-referrer" alt="image-20230209153216863"><span> </span></p></li></ol></li><li><p><span>BI(商业智能)系统主要包括</span><mark><span>数据预处理、建立数据仓库、数据分析和数据展现</span></mark><span>四个主要阶段。</span></p><ul><li><p><span>数据预处理是整合企业原始数据的第一步，它包括数据的</span><mark><span>抽取(Extraction)、转换 (Transformation)和加载(Load)</span></mark><span>三个过程(ETL过程);</span></p></li><li><p><mark><span>建立数据仓库</span></mark><span>则是处理海量数据的基础;</span></p></li><li><p><span>数据分析是体现系统智能的关键，一般采用</span><mark><span>联机分析处理(OLAP)和数据挖掘</span></mark><span>两大技术。联机分析处理不仅进行数据汇总/聚集，同时还提供切片、切块下钻、上卷和旋转等数据分析功能，用户可以方便地对海量数据进行多维分析。数据挖掘的目标则是挖掘数据背后隐藏的知识，通过</span><mark><span>关联分析、序列，聚类和分类</span></mark><span>等方法建立分析模型，预测企业未来发展趋势和将要面临的问题;</span></p><ul><li><span>关联分析。关联分析主要用于发现不同事件之间的关联性，</span></li><li><span>序列分析。序列分析主要用于发现一定时间间隔内接连发生的事件，这些事件构成一个序列，</span></li><li><span>分类分析。分类分析通过分析具有类别的样本特点，得到决定样本属于各种类别的规则或方法。</span></li><li><span>聚类分析。聚类分析是根据“物以类聚”的原理，将本身没有类别的样本聚集成不同的组，并且对每个这样的组进行描述的过程</span></li></ul></li><li><p><span>在海量数据和分析手段增多的情况下，数据展现则主要保障系统分析结果的可视化。</span></p></li><li><p><span>商业智能的实现有三个层次: </span><mark><span>数据报表、多维数据分析(OLAP)和数据挖掘</span></mark><span>。</span></p></li></ul></li></ul><h4><a name="反规范化技术" class="md-header-anchor"></a><span>反规范化技术</span></h4><ul><li><p><strong><span>反规范化技术</span></strong><span>: 规范化设计后，数据库设计者希望</span><mark><span>牺牲部分规范化来提高性能</span></mark></p><ul><li><span>采用反规范化技术的益处: </span><mark><span>降低连接操作的需求、降低外码和索引的数目，还可能减少表的数目能够提高查询效率</span></mark><span>。</span></li><li><span>可能带来的问题: </span><mark><span>数据的重复存储</span></mark><span>，浪费了磁盘空间;可能出现数据的</span><mark><span>完整性问题</span></mark><span>，为了保障数据的一致性，增加了数据维护的复杂性，</span><mark><span>会降低修改速度</span></mark></li></ul></li><li><p><span>具体方法:</span></p><ol start='' ><li><strong><span>增加冗余列</span></strong><span>: </span><mark><span>在多个表中保留相同的列</span></mark><span>，通过增加数据冗余减少或避免查询时的连接操作。</span></li><li><strong><span>增加派生列</span></strong><span>: 在表中增加可以</span><mark><span>由本表或其它表中数据计算生成的列</span></mark><span>，减少查询时的连接操作并避免计算或使用集合函数。</span></li><li><strong><span>重新组表</span></strong><span>: 如果许多用户需要查看两个表连接出来的结果数据，则</span><mark><span>把这两个表重新组成一个表来减少连接而提高性能。</span></mark></li><li><strong><span>水平分割表</span></strong><span>:根据一列或多列数据的值，把</span><mark><span>数据放到多个独立的表</span></mark><span>中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。</span></li><li><strong><span>垂直分割表</span></strong><span>:对表进行分割，将</span><mark><span>主键与部分列放到一个表中</span></mark><span>，主键与其它列放到另一个表中，在查询时减少I/0次数。</span></li></ol></li></ul><h4><a name="大数据" class="md-header-anchor"></a><span>大数据</span></h4><ul><li><p><span>特点:大量化、多样化、价值密度低、快速化。大数据和传统数据的比较如下:</span></p><figure><table><thead><tr><th><span>比较维度</span></th><th><span>传统数据</span></th><th><span>大数据</span></th></tr></thead><tbody><tr><td><span>数据量</span></td><td><span>GB or TB级别</span></td><td><span>PB级以上</span></td></tr><tr><td><span>数据分析需求</span></td><td><span>现有数据的分析与检测</span></td><td><span>深度分析( 关联分析、回归分析 )</span></td></tr><tr><td><span>硬件平台</span></td><td><span>高端服务器</span></td><td><span>集群平台</span></td></tr></tbody></table></figure></li><li><p><span>要处理大数据一般使用集成平台，称为大数据处理系统，其特征为:高度可扩展性、高性能、高度容错、支持异构环境、较短的分析延迟、易用且开放的接口、较低成本、向下兼容性</span></p></li></ul><h4><a name="sql语言" class="md-header-anchor"></a><span>SQL语言</span></h4><p><img src="http://qn.qs520.mobi/image-20230209153900105.png" referrerpolicy="no-referrer" alt="image-20230209153900105"><span> </span></p><ul><li><span>DISTINCT:过滤重复的选项，只保留一条记录</span></li><li><span>UNION:出现在两个SQL语句之间，将两个SQL语句的查询结果取或运算，即值存在于第一句或第二句都会被选出。</span></li><li><span>INTERSECT:对两个SQL语句的查询结果做与运算，即值同时存在于两个语句才被选出。</span></li><li><span>MIN、AVG、MAX: 分组查询时的聚合函数</span></li></ul><h3><a name="span-id数据库系统1数据库系统&nbsp;span" class="md-header-anchor"></a><span id="数据库系统1"><span>数据库系统 </span></span></h3><h4><a name="orm" class="md-header-anchor"></a><span>ORM</span></h4><ul><li><p><span>ORM，即Object-Relationl Mapping，它</span><mark><span>在关系型数据库和对象之间作一个映射</span></mark><span>，这样，我们在具体的操作数据库的时候，就</span><mark><span>不需要再去和复杂的SQL语句打交道</span></mark><span>，只要像平时操作对象一样操作即可。</span></p></li><li><p><span>面向对象编程</span><mark><span>把所有实体看成对象 (obiect)</span></mark><span>，关系型数据库则是</span><mark><span>采用实体之间的关系 (relation</span></mark><span>连接数据。很早就有人提出，</span><mark><span>关系也可以用对象表达</span></mark><span>，这样的话，就能使用面向对象编程，来操作关系型数据库。</span></p></li><li><p><span>ORM把数据库映射成对象。如:</span></p><ul><li><span>数据库的表(table) --&gt;类(class)</span></li><li><span>记录 (record，行数据)--&gt;对象 (object)</span></li><li><span>字段 (field)--&gt;对象的属性 (attribute)</span></li></ul></li><li><p><span>ORM优点:</span></p><ol start='' ><li><span>使用ORM可以大大降低学习和开发成本</span></li><li><span>程序员不用再写SQL来进行数据库操作</span></li><li><span>减少程序的代码量。</span></li><li><span>降低由于SQL代码质量差而带来的影响</span></li></ol></li><li><p><span>ORM缺点</span></p><ol start='' ><li><span>不太容易处理复杂查询语句。</span></li><li><span>性能较直接用SQL差。</span></li></ol></li></ul><h4><a name="数据库分类比较" class="md-header-anchor"></a><span>数据库分类比较</span></h4><ul><li><span>关系型数据库: </span><mark><span>关系数据库</span></mark><span>，是建立在关系模型基础上的数据库，借助集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。简单说，</span><mark><span>关系型数据库是由多张能互相联接的二维行列表格组成的数据库</span></mark></li><li><span>NoSQL: 泛指</span><mark><span>非关系型的数据库</span></mark><span>。随着互联网的兴起，传统的关系数据库在应付超大规模和高并发的纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NOSQL数据库的产生就是</span><mark><span>为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储</span></mark></li><li><span>内存数据库: </span><mark><span>将数据库整体存储在内存中，提高性能。</span></mark></li></ul><h4><a name="缓存技术" class="md-header-anchor"></a><span>缓存技术</span></h4><ul><li><p><span>MemCache: Memcache</span><mark><span>是一个高性能的分布式的内存对象缓存系统</span></mark><span>，用于动态Web应用以减轻数据库负载。Memcache通过</span><mark><span>在内存里维护一个统一的巨大的hash表</span></mark><span>，</span><mark><span>它能够用来存储各种格式的数据</span></mark><span>，包括图像、规频、文件以及数据库检索的结果等。</span></p></li><li><p><span>Redis: Redis</span><mark><span>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型Key-Value数据库，并提供多种语言的API。</span></mark></p></li><li><p><span>Redis与Memcache的差异</span></p><ul><li><span>Redis和Memcache都是将</span><mark><span>数据存放在内存中，都是内存数据库</span></mark><span>。他们</span><mark><span>都支持key-value数据类型</span></mark><span>。同时</span><mark><span>Memcache还可用于缓存其他东西</span></mark><span>，例如图片、现频等等，</span><mark><span>Redis还支持list、set、hash等数据结构的存储</span></mark><span>。</span></li><li><span>在Redis中，</span><mark><span>并不是所有的数据都一直存储在内存中的。这是和Memcache相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘</span></mark><span>。</span></li><li><mark><span>Redis在很多方面支持数据库的特性，可以这样说他就是一个数据库系统，而Memcache只是简单地K/V缓存</span></mark></li></ul><p><img src="http://qn.qs520.mobi/image-20230301165633476.png" referrerpolicy="no-referrer" alt="image-20230301165633476"><span> </span></p></li></ul><h2><a name="span-id5计算机网络5计算机网络span" class="md-header-anchor"></a><span id="5.计算机网络"><span>5.计算机网络</span></span></h2><h3><a name="span-id网络功能和分类网络功能和分类span" class="md-header-anchor"></a><span id="网络功能和分类"><span>网络功能和分类</span></span></h3><h4><a name="概述" class="md-header-anchor"></a><span>概述</span></h4><ul><li><p><span>计算机网络是计算机技术与通信技术相结合的产物，它实现了远程通信、远程信息处理和资源共享.计算机网络的功能: </span><mark><span>数据通信、资源共享、负载均衡、高可靠性</span></mark></p></li><li><p><span>计算机网络</span><mark><span>按分布范围和拓扑结构划分</span></mark><span>如下图所示:</span></p><p><img src="http://qn.qs520.mobi/image-20230209201741423.png" referrerpolicy="no-referrer" alt="image-20230209201741423"><span> </span></p></li><li><p><span>总线型(利用率低、干扰大、价格低)、星型(交换机形成的局域网、中央单元负荷大)、环型树型(总线型的扩充、分级结构)、分布式(任意节点连接(流动方向固定、效率低扩充难)、管理难成本高)</span></p><p><img src="http://qn.qs520.mobi/image-20230209201818708.png" referrerpolicy="no-referrer" alt="image-20230209201818708"><span> </span></p></li></ul><h4><a name="osi七层模型重点" class="md-header-anchor"></a><span>OSI七层模型(重点)</span></h4><p><img src="http://qn.qs520.mobi/image-20230209201840301.png" referrerpolicy="no-referrer" alt="image-20230209201840301"><span> </span></p><h4><a name="局域网和广域网协议" class="md-header-anchor"></a><span>局域网和广域网协议</span></h4><ul><li><p><mark><span>以太网规范IEEE 802.3</span></mark><span> 是重要的有线局域网协议(局域网是存在数据链路层的)，包括:</span></p><figure><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th><span>速率</span></th><th><span>传输介质</span></th></tr></thead><tbody><tr><td><span>IEEE 802.3</span></td><td><span>标准以太网</span></td><td><span>10Mb/s</span></td><td><span>细同轴电缆</span></td></tr><tr><td><span>IEEE 802.3u</span></td><td><span>快速以太网</span></td><td><span>100Mb/s</span></td><td><span>双绞线</span></td></tr><tr><td><span>IEEE 802.3z</span></td><td><span>千兆以太网</span></td><td><span>1000Mb/s</span></td><td><span>光纤或双绞线</span></td></tr><tr><td><span>IEEE 802.3ae</span></td><td><span>万兆以太网</span></td><td><span>10Gb/s</span></td><td><span>光纤</span></td></tr></tbody></table></figure></li><li><p><span>无线局域网WLAN技术标准: </span><mark><span>IEEE 802.11</span></mark></p></li><li><p><span>广域网协议包括:PPP 点对点协议、ISDN 综合业务数字网、XDSL (DSL 数字用户线路的统称HDSL、SDSL、MVL、ADSL)、DDN 数字专线、x.25 、FR中继、ATM异步传输模式。</span></p></li><li><p><span>以太网帧长范围是 </span><mark><span>64-1518.</span></mark><span>是基于 </span><mark><span>CSMA/CD</span></mark><span>，载波监听冲突检测协议，是</span><mark><span>网络中检测冲突的最长时间</span></mark><span>。</span></p></li></ul><h4><a name="tcpip协议" class="md-header-anchor"></a><span>TCP/IP协议</span></h4><ul><li><p><span>网络协议三要素: </span><mark><span>语法、语义、时序</span></mark><span>。其中</span><mark><span>语法部分规定传输数据的格式，语义部分规定所要完成的功能，时序部分规定执行各种操作的条件、顺序关系等</span></mark><span>。</span></p><p><img src="http://qn.qs520.mobi/image-20230209202420146.png" referrerpolicy="no-referrer" alt="image-20230209202420146"><span> </span></p></li><li><p><span>网络层协议:</span></p><ul><li><strong><span>IP</span></strong><span>:网络层最重要的核心协议，</span><mark><span>在源地址和目的地址之间传送数据报，无连接、不可靠</span></mark><span>。</span></li><li><strong><span>ICMP</span></strong><span>:因特网控制报文协议，</span><mark><span>用于在IP主机、路由器之间传递控制消息</span></mark><span>。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。</span></li><li><strong><span>ARP和RARP</span></strong><span>:</span><mark><span>地址解析协议，ARP是将IP地址转换为物理地址，RARP是将物理地址转换为IP地址</span></mark><span>。IGMP:网络组管理协议，允许因特网中的计算机参加多播，是计算机用做向相邻多目路由器报告多目组成员的协议，支持组播。</span></li><li><strong><span>IGMP</span></strong><span>: 网络组管理协议，允许因特网中的计算机参加多播，是计算机用做向相邻多目路由器报告多目组成员的协议，</span><mark><span>支持组播。</span></mark></li></ul></li><li><p><span>传输层协议:</span></p><ul><li><strong><span>TCP</span></strong><span>:整个TCP/IP协议族中最重要的协议之一，在IP协议提供的不可靠数据数据基础上，采用了重发技术，为应用程序提供了一个</span><mark><span>可靠的、面向连接的、全双工的数据传输服务</span></mark><span>。一般用于传输数据量比较少，且对可靠性要求高的场合。</span></li><li><strong><span>UDP</span></strong><span>: </span><mark><span>基于IP协议，是一种不可靠、无连接的协议</span></mark><span>，有助于提高传输速率，一般用于传输数据量大，对可靠性要求不高，但要求速度快的场合。</span></li></ul></li><li><p><span>应用层协议: </span><mark><span>基于TCP的FTP、HTTP等都是可靠传输。基于UDP的DHCP、DNS等都是不可靠传输</span></mark><span>，上面四个是基于TCP可靠的，下面四个是基于UDP，不可靠的</span></p><ul><li><strong><span>FTP</span></strong><span>: </span><mark><span>可靠的文件传输协议</span></mark><span>，用于因特网上的控制文件的双向传输。</span></li><li><strong><span>HTTP</span></strong><span>: </span><mark><span>超文本传输协议，</span></mark><span>用于从WWW服务器传输超文本到本地浏览器的传输协议。使用SSL加密后的安全网页协议为HTTPS。</span></li><li><strong><span>SMTP和POP3</span></strong><span>: </span><mark><span>简单邮件传输协议，前者用来发送，后者用来接收</span></mark><span>，是一组用于由源地址到目的地址传送邮件的规则，邮件报文采用ASCII格式表示。</span></li><li><strong><span>Telnet</span></strong><span>: </span><mark><span>远程连接协议</span></mark><span>，是因特网远程登录服务的标准协议和主要方式</span></li><li><strong><span>TFTP</span></strong><span>:不可靠的、开销不大的</span><mark><span>小文件传输协议</span></mark><span>。</span></li><li><strong><span>SNMP</span></strong><span>: </span><mark><span>简单网络管理协议</span></mark><span>，由一组网络管理的标准协议，包含一个应用层协议、数据库模型和一组资源对象。该协议能够支持网络管理系统，泳衣监测连接到网络上的设备是否有任何引起管理师行关注的情况。</span></li><li><strong><span>DHCP</span></strong><span>: </span><mark><span>动态主机配置协议</span></mark><span>，基于UDP，基于C/S模型，为主机动态分配IP地址，有三种方式固定分配、动态分配、自动分配。</span></li><li><strong><span>DNS</span></strong><span>: </span><mark><span>域名解析协议</span></mark><span>，通过域名解析出IP地址。</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230209202722775.png" referrerpolicy="no-referrer" alt="image-20230209202722775"><span> </span></p></li></ul><h4><a name="传输介质" class="md-header-anchor"></a><span>传输介质</span></h4><ul><li><p><span>双绞线:将多根铜线按规则缠绕在一起，能够减少干扰;分为</span><mark><span>无屏蔽双绞线UTP和屏蔽双绞线都</span></mark><span>是由一对铜线簇组成。也即我们常说的</span><mark><span>网线:</span></mark><mark><span>双绞线的传输距离在100m以内</span></mark></p><p><span>	</span><img src="http://qn.qs520.mobi/image-20230210152209770.png" referrerpolicy="no-referrer" alt="image-20230210152209770"><span> </span></p><ul><li><mark><span>无屏蔽双绞线UTP</span></mark><span>:价格低，安装简单，但可靠性相对较低，分为CAT3 (3类UTP，速率为</span>
<span>10Mbps)、CAT4 (4类UTP，与3类差不多，无应用)、CAT5 (5类UTP，速率为100Mbps，用于快速以太网)、CAT5E(超5类UTP，速率为1000Mbps)、CAT6 (6类UTP，用来替代CAT5E，速率也是1000Mbps)</span></li><li><mark><span>屏蔽双绞线STP</span></mark><span>:比之UTP增加了一层屏蔽层，可以有效的提高可靠性，但对应的价格高，安装麻烦，一般用于对传输可靠性要求很高的场合。</span></li></ul></li><li><p><span>网线有如下两种安装标准:都是八根不同颜色的网线，按照不同的顺序排序，插入水晶头中</span><mark><span>区分在第1236四根网线的位置不同</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230210152338324.png" referrerpolicy="no-referrer" alt="image-20230210152338324"><span> </span></p></li><li><p><span>光纤:由纤芯和包层组成，传输的光信号在纤芯中传输，然而从PC端出来的信号都是电信号，要经过光纤传输的话，就必须将电信号转换为光信号。</span></p></li><li><p><mark><span>多模光纤MMF</span></mark><span>: 纤芯半径较大，因此可以</span><mark><span>同时传输多种不同的信号</span></mark><span>，光信号在光纤中以全反射的形式传输，采用</span><mark><span>发光二极管LED为光源，成本低，但是传输的效率和可靠性都较低，适合于短距离传输</span></mark><span>其传输距离与传输速率相关，速率为100Mbps时为2KM，速率为1000Mbps时为550m。</span></p><p><img src="http://qn.qs520.mobi/image-20230210152539057.png" referrerpolicy="no-referrer" alt="image-20230210152539057"><span> </span></p></li><li><p><span>单模光纤SMF：纤芯半径很小，</span><mark><span>一般只能传输一种信号，采用激光二极管LED作为光源，并且只支持激光信号的传播</span></mark><span>，同样是以</span><mark><span>全反射形式</span></mark><span>传播，只不过反射角很大，看起来像一条直线，</span><mark><span>成本高，但是传输距离远，可靠性高。传输距离可达5KM</span></mark><span>。</span></p><p><img src="http://qn.qs520.mobi/image-20230210152735297.png" referrerpolicy="no-referrer" alt="image-20230210152735297"><span> </span></p></li><li><p><span>无线信道：分为无线电波和红外光波</span></p><p><img src="http://qn.qs520.mobi/image-20230210152852774.png" referrerpolicy="no-referrer" alt="image-20230210152852774"><span> </span></p></li></ul><h4><a name="通信方式和交换方式" class="md-header-anchor"></a><span>通信方式和交换方式</span></h4><ul><li><p><span>通信方向:数据通信是指发送方发送数据到接收方，这个传输过程可以分类如下:</span></p><ul><li><mark><span>单工</span></mark><span>:只能由设备A发给设备B，即数据流只能单向流动。</span></li><li><mark><span>半双工</span></mark><span>:设备A和设备B可以互相通信，但是同一时刻数据流只能单向流动。</span></li><li><mark><span>全双工</span></mark><span>:设备A和设备B在任意时刻都能互相通信。</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230210152956954.png" referrerpolicy="no-referrer" alt="image-20230210152956954"><span> </span></p></li><li><p><span>同步方式:</span></p><ul><li><strong><span>异步传输</span></strong><span>:发送方每发送一个字符，需要约定一个起始位和停止位插入到字符的起始和结尾处这样当接收方接收到该字符时能够识别，但是这样会造成资源浪费，传输效率降低。</span></li><li><strong><span>同步传输</span></strong><span>:以数据块为单位进行传输，当</span><mark><span>发送方要发送数据时，先发送一个同步帧</span></mark><span>，接收方收到后做好接收准备，开始接收数据块，</span><mark><span>结束后又会有结束帧确认</span></mark><span>，这样一次传输一个数据块，效率高。</span></li><li><strong><span>串行传输</span></strong><span>: </span><mark><span>只有一根数据线</span></mark><span>，数据只能1bit挨个排队传送，适合低速设备、远距离的传送，般用于广域网中。</span></li><li><strong><span>并行传输</span></strong><span>: </span><mark><span>有多根数据线</span></mark><span>，可以同时传输多个bit数据，适合高速设备的传送，常用语计算机内部各硬件模块之间。</span></li></ul></li><li><p><span>交换方式（考点）</span></p><ul><li><p><mark><span>电路交换</span></mark><span>:通信一方进行呼叫，另一方接收后，在</span><mark><span>二者之间会建立一个专用电路</span></mark><span>，特点为</span><mark><span>面向连接、实时性高、链路利用率低，一般用于语音视频通信。</span></mark></p></li><li><p><mark><span>报文交换</span></mark><span> :以</span><mark><span>报文为单位，存储转发模式(先存储再转发)</span></mark><span>，接收到数据后先存储，进行差错校验，没有错误则转发，有错误则丢弃，因此会</span><mark><span>有延时，但可靠性高，是面向无连接的</span></mark><span>。</span></p></li><li><p><mark><span>分组交换</span></mark><span>: </span><mark><span>以分组为单位，也是存储转发模式</span></mark><span>，因为分组的长度比报文小，所以时延小于报文交</span>
<span>换，又可分为三种方式:</span></p><ul><li><mark><span>数据报</span></mark><span>: 是现在</span><mark><span>主流</span></mark><span>的交换方式，</span><mark><span>各个分组携带地址信息，自由的选择不同的路由路径</span></mark><span>传送到接收方，接收方接收到分组后再根据地址信息重新组装成原数据，是面向无连接的，但是不可靠的</span></li><li><mark><span>虚电路</span></mark><span>: 发送方发送一个分组，接收方收到后</span><mark><span>二者之间就建立了一个虚拟的通信线路</span></mark><span>，二者之间的分组数据交互都通过这条线路传送，在空闲的时候这条线路也可以传输其他数据，是面向连接的，可靠的。</span></li><li><mark><span>信元交换: 异步传输模式ATM采用的交换方式</span></mark><span>，本质是按照虚电路方式进行转发，只不过</span><mark><span>信元是固定长度的分组</span></mark><span>，共53B，其中5B为头部，48B为数据域，也是面向连接的，可靠的。</span></li></ul></li></ul></li></ul><h4><a name="ip地址" class="md-header-anchor"></a><span>IP地址</span></h4><ul><li><p><span>机器中存放的</span><mark><span>IP地址是32位的二进制代码，每隔8位</span></mark><span>插入一个空格，可提高可读性，为了便于理解和设置，一般会采用</span><mark><span>点分十进制方法</span></mark><span>来表示:将32位二进制代码</span><mark><span>每8位二进制转换成十进制</span></mark><span>，</span><mark><span>就变成了4个十进制数</span></mark><span>，而后在每个十进制数间隔中插入.，如下所示，最终为128.11.3.31:</span></p><p><img src="http://qn.qs520.mobi/image-20230210154137423.png" referrerpolicy="no-referrer" alt="image-20230210154137423"><span> </span></p></li><li><p><span>因为每个十进制数都是由8个二进制数转换而来，因此</span><mark><span>每个十进制数的取值范围为0-255</span></mark><span>(掌握二进制转十进制的快速计算方法，牢记2的幂指数值，实现快速转换)。</span></p></li><li><p><mark><span>分类IP地址（考点）</span></mark><span>: IP地址分四段，每段八位，共32位二进制数组成。在逻辑上，这32位IP地址分为</span><mark><span>网络号和主机号</span></mark><span>，依据网络号位数的不同，可以将IP地址分为以下几类:</span></p><p><img src="http://qn.qs520.mobi/image-20230210154253899.png" referrerpolicy="no-referrer" alt="image-20230210154253899"><span> </span></p></li><li><p><mark><span>无分类编址</span></mark><span>: 即不按照A B C类规则，自动规定网络号，无分类编址格式为:IP地址/网络号，示例:28.168.0.11/20表示的IP地址为128.168.0.11，其网络号占20位，因此主机号占32-20=12位，也可以划分子网。</span></p></li><li><p><span>特殊IP地址</span></p><ul><li><mark><span>公有地址:通过它直接访问因特网。是全网唯一的IP地址</span></mark></li><li><mark><span>私有地址:属于非注册地址，专门为组织机构内部使用</span></mark><span>，不能直接访问因特网，下表所示为私有地址范围以及特殊地址：</span></li><li><img src="http://qn.qs520.mobi/image-20230210155302672.png" referrerpolicy="no-referrer" alt="image-20230210155302672"><span> </span></li></ul></li></ul><h4><a name="子网划分" class="md-header-anchor"></a><span>子网划分</span></h4><ul><li><span>子网划分:一般公司在申请网络时，会直接获得一个范围很大的网络，如一个B类地址，因为</span><mark><span>主机数之间相差的太大了，不利于分配，</span></mark><span>我们一般</span><mark><span>采用子网划分的方法来划分网络，即自定义网络号位数</span></mark><span>，就能自定义主机号位数，就能根据主机个数来划分出最适合的方案，不会造成资源的浪费。</span></li><li><span>因此就有子网的概念，一般的IP地址按标准划分为A B C类后，可以进行再-步的划分，将主机号拿出几位作为子网号，就可以划分出多个子网，此时IP地址组成为: </span><mark><span>网络号+子网号+主机号</span></mark></li><li><mark><span>网络号和子网号都为1，主机号都为0，这样的地址为子网掩码</span></mark></li><li><span>要注意的是:</span><mark><span>子网号可以为全0和全1，主机号不能为全0或全1，因此，主机数需要-2</span></mark><span>，而子网数不用。</span></li><li><span>还可以</span><mark><span>聚合网络为超网</span></mark><span>，就是划分子网的逆过程，</span><mark><span>将网络号取出几位作为主机号</span></mark><span>，此时，这个网络内的主机数量就变多了，成为一个更大的网络。</span></li></ul><h4><a name="ipv6" class="md-header-anchor"></a><span>IPv6</span></h4><ul><li><p><span>主要是为了解决IPv4地址数不够用的情况而提出的设计方案，IPv6具有以下特性:</span></p><ul><li><span>IPv6地址长度为</span><mark><span>128位</span></mark><span>，地址空间增大了2~96倍;</span></li><li><span>灵活的IP报文头部格式，使用一系列固定格式的扩展头部取代了iPv4中可变长度的选项字段。IPv6中选项部分的出现方式也有所变化，使路由器可以简单撸过选项而不做任何处理，加快了报文处理速度;</span></li><li><span>IPv6简化了报文头部格式，加快报文转发，提高了吞吐量:提高安全性，</span><mark><span>身份认证和隐私权</span></mark><span>是IPv6的关键特性;</span></li><li><span>支持更多的服务类型:允许协议继续演变，增加新的功能，使之适应未来技术的发展。</span></li></ul></li><li><p><span>IPv4和IPv6的过渡期间，主要采用三种基本技术:</span></p><ol start='' ><li><mark><span>双协议栈</span></mark><span>:主机同时运行IPv4和IPv6两套协议栈，</span><mark><span>同时支持两套协议</span></mark><span>，一般来说IPv4和IPv6地址之间存在某种转换关系，如IPv6的低32位可以直接转换为IPv4地址，实现互相通信。</span></li><li><mark><span>隧道技术</span></mark><span>: 这种机制用来</span><mark><span>在!P4网络之上建立一条能够传输IPv6数据报的隧道</span></mark><span>，例如可以将IPv6数据报当做IPv4数据报的数据部分加以封装，只需要加一个IPv4的首部，就能在IPv4网络中传输IPV6报文</span></li><li><mark><span>翻译技术</span></mark><span>:利用一台专门的翻译设备 (如转换网关)，</span><mark><span>在纯IP4和纯IPv6网络之间转换IP报头的地址</span></mark><span>，同时根据协议不同对分组做相应的语义翻译，从而使纯IPv4和纯IPv6站点之间能够透明通信。</span></li></ol></li><li><p><span>三层模型将网络划分为</span><mark><span>核心层、汇聚层和接入层</span></mark><span>，每一层都有着特定的作用。</span></p><ul><li><p><strong><span>核心层</span></strong><span>提供不同区域之间的</span><mark><span>最佳路由和高速数据传送</span></mark><span>;</span></p></li><li><p><strong><span>汇聚层</span></strong><span>将</span><mark><span>网络业务连接到接入层，并且实施与安全、流量、负载和路由相关的策略</span></mark></p></li><li><p><strong><span>接入层</span></strong><span>为用户提供了</span><mark><span>在本地网段访问应用系统的能力</span></mark><span>，还要解决相邻用户之间的互访需要，接入层要负责一些用户信息(例如用户IP地址、MAC地址和访问 日志等的收集工作和用户管理功能(包括认证和计费等)。</span></p><p><img src="http://qn.qs520.mobi/image-20230210174456794.png" referrerpolicy="no-referrer" alt="image-20230210174456794"><span> </span></p></li></ul></li></ul><h4><a name="网络规划和设计" class="md-header-anchor"></a><span>网络规划和设计</span></h4><ul><li><p><mark><span>建筑物综合布线系统(结构化布线系统)PDS</span></mark><span>:</span></p><ol start='' ><li><mark><span>工作区子系统:实现工作区终端设备到水平子系统的信息插座之间的互联。</span></mark></li><li><mark><span>水平布线子系统:实现信息插座和管理子系统之间的连接。</span></mark></li><li><mark><span>设备间子系统:实现中央主配线架与各种不同设备之间的连接。</span></mark></li><li><mark><span>垂直干线子系统:实现各楼层设备间子系统之间的互连。</span></mark></li><li><mark><span>管理子系统:连接各楼层水平布线子系统和垂直干缆线，负责连接控制其他子系统为连接其他子系统提供连接手段。</span></mark></li><li><mark><span>建筑群子系统:各个建筑物通信系统之间的互联</span></mark></li></ol><p><img src="http://qn.qs520.mobi/image-20230210174632423.png" referrerpolicy="no-referrer" alt="image-20230210174632423"><span> </span></p></li></ul><h4><a name="廉价磁盘冗余阵列" class="md-header-anchor"></a><span>廉价磁盘冗余阵列</span></h4><ul><li><p><span>RAID即磁盘冗余阵列技术，将数据分散存储在不同磁盘中，可并行读取，可冗余存储，提高磁盘访问速度，保障数据安全性。</span></p></li><li><p><mark><span>RAID0将数据分散的存储在不同磁盘中，磁盘利用率100%，访问速度最快，但是没有提供冗余和错误修复技术;</span></mark></p></li><li><p><mark><span>RAID1在成对的独立磁盘上产生互为备份的数据</span></mark><span>，增加存储可靠性，可以纠错，但磁盘利用率只有50%</span></p><p><img src="http://qn.qs520.mobi/image-20230210174830359.png" referrerpolicy="no-referrer" alt="image-20230210174830359"><span> </span></p></li><li><p><span>RAID2将数据条块化的分布于不同硬盘上，并使用</span><mark><span>海明码校验;</span></mark></p></li><li><p><span>RAID3使用</span><mark><span>奇偶校验</span></mark><span>，并用单块磁盘存储奇偶校验信息(可靠性低于RAID5)</span></p></li><li><p><mark><span>RAID5在所有磁盘上交叉的存储数据及奇偶校验信息</span></mark><span>(所有校验信息存储总量为一个磁盘容量但分布式存储在不同的磁盘上)，读/写指针可同时操作;</span></p><p><img src="http://qn.qs520.mobi/image-20230210174924812.png" referrerpolicy="no-referrer" alt="image-20230210174924812"><span> </span></p></li><li><p><span>RAID0+1(是两个RAIDO，若一个磁盘损坏，则当前RAIDO无法工作，即有一半的磁盘无法工作);</span></p></li><li><p><span>RAID1+0(是两个RAD1，不允许同一组中的两个磁盘同时损坏)与RAID1原理类似，磁盘利用率都只有50%，但安全性更高</span></p><p><img src="http://qn.qs520.mobi/image-20230210174959608.png" referrerpolicy="no-referrer" alt="image-20230210174959608"><span> </span></p></li></ul><h4><a name="网络存储技术" class="md-header-anchor"></a><span>网络存储技术</span></h4><ol start='' ><li><p><mark><span>直接附加存储(DAS)</span></mark><span>: 是指</span><mark><span>将存储设备通过SCSI接口直接连接到一台服务器上使用</span></mark><span>，其本身是硬件的堆叠，存储操作依赖于服务器，不带有任何存储操作系统。</span></p><ul><li><span>存在问题: 在传递距离、连接数量、传输速率等方面都受到限制。容量难以扩展升级:数据处理和传输能力降低;服务器异常会波及存储器</span></li></ul></li><li><p><mark><span>网络附加存储(NAS)</span></mark><span>: </span><mark><span>通过网络接口与网络直接相连</span></mark><span>，由用户通过网络访问，有独立的存储系统如下图所示。NAS存储设备类似于一个</span><mark><span>专用的文件服务器</span></mark><span>，去掉了通用服务器大多数计算功能，而仅仅提供文件系统功能。以数据为中心，将存储设备与服务器分离，其存储设备在功能上完全独立于网络中的主服务器。客户机与存储设备之间的数据访问不再需要文件服务器的干预，同时它允许客户机与存储设备之间进行直接的数据访问，所以不仅响应速度快，而且数据传输速率也很高。</span></p><ul><li><p><span>NAS的性能特点是进行小文件级的共享存取;支持即插即用:可以很经济的解决存储容量不足的问题，但难以获得满意的性能。</span></p><p><img src="http://qn.qs520.mobi/image-20230210175227076.png" referrerpolicy="no-referrer" alt="image-20230210175227076"><span> </span></p></li></ul></li><li><p><mark><span>存储区域网(SAN)</span></mark><span>:SAN是通过专用交换机将磁盘阵列与服务器连接起来的高速专用子网。它没有采用文件共享存取方式，而是采用</span><mark><span>块(block)级别存储</span></mark><span>。SAN是通过专用高速网将一个或多个网络存储设备和服务器连接起来的专用存储系统，其最大特点是将存储设备从传统的以太网中分离了出来，成为独立的存储区域网络SAN 的系统结构。根据数据传输过程采用的协议，其技术划分为</span><mark><span>FCSAN (光纤通道)、IP SAN (IP网络(以太网))和IB SAN (无线带宽) 技术。</span></mark></p></li></ol><h4><a name="其他考点补充" class="md-header-anchor"></a><span>其他考点补充</span></h4><ul><li><mark><span>网络地址翻译NAT:</span></mark><span> </span><mark><span>私有IP地址翻译为公有IP地址，</span></mark><span>公司内有很多电脑，在公司局域网内可以互联通信，但是要访问外部因特网时，只提供固定的少量IP地址能够访问因特网，将公司所有电脑这个大的地址集合映射到能够访问因特网的少量IP地址集合的过程就称为NAT。很明显，使用了NAT后，一个公司只有少量固定IP地址可以上网，大大减少了IP地址的使用量。</span></li><li><mark><span>默认网关</span></mark><span>:一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。</span><mark><span>默认网关的IP地址必须与本机IP地址在同一个网段内，即同网络号</span></mark><span>。</span></li><li><mark><span>虚拟局域网VLAN:是一组逻辑上的设备和用户</span></mark><span>，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样。VLAN工作在OSI参考模型的第2层和第3层，一个VLAN就是一个</span><mark><span>广播域</span></mark><span>，</span><mark><span>VLAN之间的通信是通过第3层的路由器来完成的。</span></mark></li><li><span>与传统的局域网技术相比较，VLAN技术更加灵活，它具有以下优点: 网络设备的移动、添加和修改的管理开销减少;可以控制广播活动;可提高网络的安全性。</span></li><li><mark><span>虚拟专用网VPN:是在公用网络上建立专用网络的技术</span></mark><span>。其之所以称为虚拟网，主要是因为整个VPN网络的任意两个节点之间的连接并没有传统专网所需的端到端的物理链路，而是架构在公用网络服务商所提供的网络平台，如Internet、ATM(异步传输模式》、Frame Relay (中继)等之上的逻辑网络，用户数据在逻辑链路中传输。</span></li><li><span>PPP: 点对点协议，安全认证介绍: PPP的NCP可以承载多种协议的三层数据包。PPP使用LCP控制多种链路的参(建立、认证、压缩、回拨)。</span></li><li><span>PPP的认证类型:ppp认证是通过二次握手建立认证(明文不加密)，chap挑战握手认证协议，通过三次握手建立认证(密文采用MD5加密)。PPP的双向验证，采用的是chap的主验证风格。PPP的加固验证，采用的是两种(pap,chap)验证同时使用</span></li><li><mark><span>冲突域和广播域(考点)</span></mark><span>: 冲突域是属于物理层概念，广播域是数据链路层概念，一个局域网就是一个广播域，包括虚拟局域网。路由器可以阻断广播域和冲突域，交换机只能阻断冲突域，因此一个路由器下可以划分多个广播域和多个冲突域;一个交换机下整体是一个广播域，但</span><mark><span>可以划分多个冲突域</span></mark><span>;而物理层设备集线器下整体作为一个冲突域和一个广播域。</span></li><li><span>一个完整的URL组成：</span><mark><code>协议://服务or主机.域名：端口号/路径</code></mark><span>，例如：</span><code>http://www.taobao.com/index</code></li></ul><h2><a name="span-id6多媒体技术6多媒体技术span" class="md-header-anchor"></a><span id="6.多媒体技术"><span>6.多媒体技术</span></span></h2><h3><a name="span-id基本概念基本概念span" class="md-header-anchor"></a><span id="基本概念"><span>基本概念</span></span></h3><ul><li><p><span>媒体可分为下面五类:</span></p></li><li><p><span>感觉媒体：直接作用于人的感觉器官，使人产生直接感觉的媒体。常见的感觉媒体分为文本，图形，图像，动画， 音频视频</span></p></li><li><p><span>表示媒体：指传输感觉媒体的中介媒体，即用于数据交换的编码。如:如文本编码，声音编码，图像编码等</span></p></li><li><p><span>表现(显示)媒体:进行信息输入和信息输出的媒体。也即输入输出设备，如:键盘、鼠标和麦克风;显示器、打印机和音响等。</span></p></li><li><p><span>存储媒体:存储表示媒体的物理介质。如磁盘、光盘和内存等</span></p></li><li><p><span>传输媒体: 传输表示媒体的物理介质。如电缆、光纤、双绞线等。</span>
<span>例:以下媒体中， (12) 是表示媒体， (13) 是表现媒体</span></p><p><span>（12） A。图像    B.图像编码     C.电磁波    D.鼠标</span></p><p><span>（13） A。图像    B.图像编码     C.电磁波    D.鼠标</span>
<span>答案:B D</span></p></li><li><p><span>解析:表示媒体指信息的表示形式，如文字图形、编码、动画等;表现媒体是表现和获取信息 的物理设备，如键盘鼠标等输入和输出设备。</span></p></li></ul><h4><a name="媒体分类" class="md-header-anchor"></a><span>媒体分类</span></h4><h4><a name="声音" class="md-header-anchor"></a><span>声音</span></h4><ul><li><p><span>以声音的带宽来衡量声音的大小，单位是HZ。声音是一种模拟信号，要对其进行处理，就必须将其转化为数字信号。转换过程有三个步骤:</span><mark><span>采样、量化、编码</span></mark><span>。人耳能听到的音频信号的频率范围是</span><mark><span>20Hz~20KHz</span></mark><span>。</span><mark><span>声音的采样频率一般为最高频率的两倍</span></mark><span>，才能保证不失真。声音文件格式：</span><code>.wav、.snd、.au、.aif、.voc、.mp3、.ra、.mid等</code></p><p><img src="http://qn.qs520.mobi/image-20230210215305001.png" referrerpolicy="no-referrer" alt="image-20230210215305001"><span> </span></p></li></ul><h4><a name="图形和图像" class="md-header-anchor"></a><span>图形和图像</span></h4><ul><li><p><span>颜色三要素：</span></p><ul><li><mark><span>亮度</span></mark><span>:彩色明暗深浅程度</span></li><li><mark><span>色调(红、绿)</span></mark><span> :颜色的类别</span></li><li><mark><span>饱和度</span></mark><span>:某一颜色的深浅程度</span></li></ul></li><li><p><span>彩色空间</span></p></li><li><p><span>即设备显示图片所使用的色彩空间，普通的电脑显示器是RGB色彩空间，除了红、绿、蓝三原色外，其他颜色都是通过这三原色叠加形成的;电视中使用YUV色彩空间，主要是为了兼容黑白电视，使用的是亮度原理，即调不同的亮度显示不同的颜色;</span></p></li><li><p><span>CMY(CMYK)，印刷书籍时采用的色彩空间，这个采用的是和RGB相反的减法原理，浅蓝、粉红、黄三原色的印刷颜料实际上是吸收除了本身色彩之外的其他颜色的，因此，印刷出来才是这些颜色;</span></p></li><li><p><span>HSV(HSB)，艺术家彩色空间，是从艺术的角度划分的。</span></p></li><li><p><span>图像的属性: 分辨率(每英寸像素点数dpi) 、像素深度(存储每个像素所使用的二进制位数)。</span></p></li><li><p><span>图像文件格式: </span><code>.bmp、·gif、 jpg、png、 .tif、.wmf等</code></p></li><li><p><mark><span>DPI: 每英寸像素点数。</span></mark></p></li><li><p><span>图像深度是图像文件中记录一个像素点所需要的位数。显示深度表示显示缓存中记录屏幕上一个点的位数 (bit) ，也即显示器可以显示的颜色数。</span></p></li><li><p><span>水平分辨率: 显示器在</span><mark><span>横向</span></mark><span>上具有的像素点数目</span></p></li><li><p><span>垂直分辨率: 显示器在</span><mark><span>纵向</span></mark><span>上具有的像素点数目。</span></p></li><li><p><mark><span>矢量图的基本组成单位是图元，位图的基本组成单位是像素，视频和动画的基本组成单元是帧</span></mark><span>。 </span></p></li></ul><h4><a name="多媒体计算" class="md-header-anchor"></a><span>多媒体计算</span></h4><p><img src="http://qn.qs520.mobi/image-20230210215619564.png" referrerpolicy="no-referrer" alt="image-20230210215619564"><span> </span></p><ul><li><span>上述计算中，图像中要理解色数的概念。要理解音频容量计算的原理，就是每个采样通道的采样次数</span><em><span>每次采样的位数</span></em><span>总的采用通道数。</span></li><li><span>视频就是一帧帧图像的组合，因此本质是求图像容量，当然要加上音频容量。</span></li><li><span>注意单位B和b的区别和换算，注意K(大写，1024，存储时才用) 和k (小写，1000) 的区别注意结果单位。</span></li></ul><h4><a name="多媒体标准" class="md-header-anchor"></a><span>多媒体标准</span></h4><ul><li><p><span>主要是图像的JPEG标准和视频的MPEG标准，对于MPEG，要掌握每个级别的代表设备标准,具体如下图所示:</span></p><p><img src="http://qn.qs520.mobi/image-20230210215937430.png" referrerpolicy="no-referrer" alt="image-20230210215937430"><span> </span></p></li></ul><h4><a name="数据压缩" class="md-header-anchor"></a><span>数据压缩</span></h4><ul><li><p><span>能够压缩的前提是有冗余，冗余分类如下:</span></p><ul><li><span>空间冗余(几何冗余):对于一副画面中的同样的信息，在压缩时，不需要重复存储，只记录一次信息内容，而后记录这些相同信息出现的位置即可。</span></li><li><span>时间冗余: 在压缩视频时，对于一帧和下一帧，只记录变化的部分，不变的部分不记录。</span></li><li><span>视觉冗余: 例如JPEG标准，就是有损压缩，对于人眼关注不到的细节就不存储，找到一个临界值，达到视觉欺骗的效果。</span></li><li><span>信息熵冗余:不同的信息编码的几余效率是不同的，可以通过改变信息编码来改变冗余。</span></li><li><span>结构冗余:对于结构相同的模块，只记录一次。和空间冗余有点类似。</span></li><li><span>知识冗余:从知识角度来说，有些可以根据常识推导出来的东西，可以不用记录</span></li></ul></li><li><p><span>有损压缩和无损压缩</span></p><ul><li><span>压缩后能够还原的编码方式称为</span><mark><span>无损压缩(熵编码法)</span></mark><span>:例如WINRAR压缩等，最终可以还原出原数据，最经典的就是</span><mark><span>哈夫曼(霍夫曼编码)编码，</span></mark><span>香农编码，算术编码等是无损压缩。</span></li><li><span>压缩后无法还原的编码方式就是</span><mark><span>有损压缩(熵压缩法)</span></mark><span>，变化编码就是有损压缩 :例如JPEG格式的图片</span></li></ul></li></ul><h2><a name="span-id7-安全性知识信息安全和网络安全7-安全性知识信息安全和网络安全span" class="md-header-anchor"></a><span id="7. 安全性知识(信息安全和网络安全)"><span>7. 安全性知识(信息安全和网络安全)</span></span></h2><h4><a name="信息安全和信息系统安全" class="md-header-anchor"></a><span>信息安全和信息系统安全</span></h4><ul><li><p><strong><span>信息安全系统的体系架构</span></strong><span>：</span></p><ul><li><p><mark><span>X轴是“安全机制”</span></mark><span>，为提供某些安全服务，利用各种安全技术和技巧，所形成的一个较为完善的机构体系。</span><mark><span>Y轴是“ISO网络参考模型”。z轴是“安全服务”</span></mark><span>。就是从网络中的各个层次提供给信息应用系统所需要的安全服务支持。</span></p></li><li><p><span>由X、Y、Z三个轴形成的信息安全系统三维空间就是</span><mark><span>信息系统的“安全空间</span></mark><span>”。</span></p></li><li><p><span>随着网络逐层扩展，这个空间不仅范围逐步加大，安全的内涵也就更丰富，达到具有</span><mark><span>认证、权限、完整、加密和不可否认五大要素</span></mark><span>，也叫作</span><mark><span>“安全空间”的五大属性</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230212150552128.png" referrerpolicy="no-referrer" alt="image-20230212150552128"><span> </span></p></li></ul></li><li><p><strong><span>信息安全含义及属性(考点)</span></strong><span>:保护信息的</span><mark><span>保密性、完整性、可用性</span></mark><span>，另外也包括其他属性，如:真实性、可核查性、不可抵赖性和可靠性。</span></p><ul><li><p><mark><span>保密性</span></mark><span>:信息</span><mark><span>不被泄漏给未授权的个人、:实体和过程或不被其使用的特性</span></mark><span>，包括:(1) 最小授权原则 (2) 防暴露 (3) 信息加密 (4) 物理保密</span></p></li><li><p><mark><span>完整性</span></mark><span>(不能被随便修改): 信息</span><mark><span>未经授权不能改变的特性</span></mark><span>。影响完整性的主要因素有设备故障误码、人为攻击和计算机病毒等。保证完整性的方法包括:</span></p><ol start='' ><li><span>协议:通过安全协议检测出被删除、失效、被修改的字段。</span></li><li><span>纠错编码方法:利用校验码完成检错和纠错功能。</span></li><li><span>密码校验和方法。</span></li><li><span>数字签名:能识别出发送方来源。</span></li><li><span>公证: 请求系统管理或中介机构证明信息的真实性</span></li></ol></li><li><p><mark><span>可用性</span></mark><span>: </span><mark><span>需要时，授权实体可以访问和使用的特性</span></mark><span>。一般用系统正常使用时间和整个工作时间之比来度量</span></p></li></ul></li><li><p><strong><span>其他属性</span></strong><span>:</span></p><ul><li><span>真实性:指对</span><mark><span>信息的来源进行判断</span></mark><span>，能对伪造来源的信息予以鉴别</span></li><li><span>可核查性:系统实体的行为可以</span><mark><span>被独一无二的追溯到该实体的特性</span></mark><span>，这个特性就是要求该实体对其行为负责，为探测和调查安全违规事件提供了可能性。</span></li><li><span>不可抵赖性:是指建立有效的责任机制，</span><mark><span>防止用户否认其行为</span></mark><span>，这一点在电子商务中是极其重要的。</span></li><li><span>可靠性:系统在规定的时间和给定的条件下，</span><mark><span>无故障地完成规定功能的概率</span></mark></li></ul></li><li><p><strong><span>安全需求</span></strong><span>: 可划分为</span><mark><span>物理线路安全、网络安全、系统安全和应用安全</span></mark><span>;从各级安全需求字面上也可以理解:</span></p><ul><li><span>物理线路就是</span><mark><span>物理设备、物理环境</span></mark></li><li><span>网络安全指</span><mark><span>网络上的攻击、入侵</span></mark></li><li><span>系统安全指的是</span><mark><span>操作系统漏洞、补丁等;</span></mark></li><li><span>应用安全就是</span><mark><span>上层的应用软件，包括数据库软件</span></mark></li></ul></li></ul><h4><a name="信息安全技术" class="md-header-anchor"></a><span>信息安全技术</span></h4><ul><li><p><strong><span>加密技术</span></strong></p><ul><li><p><span>一个密码系统，通常简称为密码体制(Cryptosystem)，由五部分组成:</span></p><ol start='' ><li><span>明文空间M，它是全体明文的集合</span></li><li><span>密文空间C，它是全体密文的集合。</span></li><li><span>密钥空间K，它是全体密钥的集合。其中每一个密钥K 均由加密密钥Ke 和解密密钥Kd 组成，即K=&lt; Ke，Kd&gt;.</span></li><li><span>加密算法E，它是一组由M 至C的加密变换</span></li><li><span>解密算法D，它是一组由C到M 的解密变换。</span></li></ol></li><li><p><span>对于明文空间M 中的每一个明文M，加密算法E在密钥Ke 的控制下</span><mark><span>将明文M 加密成密文C: CE (M, Ke)</span></mark></p></li><li><p><span>而解密算法D 在密钥Kd的控制下</span><mark><span>将密文C 解密出同一明文M:M=D (C, Kd ) =D (E (M, Ke),Kd)</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230212151519016.png" referrerpolicy="no-referrer" alt="image-20230212151519016"><span> </span></p></li></ul></li><li><p><strong><span>对称加密技术</span></strong></p><ul><li><p><mark><span>数据的加密和解密的密钥(密码) 是相同的，属于不公开密钥加密算法。其缺点是加密强度不高(因为密钥位数少)且密钥分发困难(因为密钥还需要传输给接收方，也要考虑保密性等问题)优点是加密速度快，适合加密大数据</span></mark></p></li><li><p><span>常见的对称密钥加密算法如下</span></p><ul><li><p><mark><span>DES</span></mark><span>:替换+移位、56位密钥、64位数据块、速度快，密钥易产生</span></p></li><li><p><span>3DES:三重DES，两个56位密钥K1、K2。</span></p><ul><li><span>加密: K1加密-&gt;K2解密-&gt;K1加密</span></li><li><span>解密: K1解密-&gt;K2加密-&gt;K1解密</span></li></ul></li><li><p><mark><span>AES</span></mark><span>:是美国联邦政府采用的一种区块加密标准，这个标准用来替代原先的DES对其的要求是“至少像3DES一样安全”</span></p></li><li><p><mark><span>RC-5</span></mark><span>:RSA数据安全公司的很多产品都使用了RC-5。</span></p></li><li><p><mark><span>IDEA</span></mark><span>:128位密钥，64位数据块，比DES的加密性好，对计算机功能要求相对低</span></p></li></ul></li></ul></li><li><p><strong><span>非对称加密技术</span></strong></p><ul><li><p><span>数据的</span><mark><span>加密和解密的密钥是不同的，分为公钥和私钥</span></mark><span>。是公开密钥加密算法，</span><mark><span>其缺点是加密速度慢。优点是安全性高</span></mark><span>，不容易破解</span></p></li><li><p><span>非对称技术的原理是: 发送者发送数据时，</span><mark><span>使用接收者的公钥作加密密钥，私钥作解密密钥</span></mark><span>，这样只有接收者才能解密密文得到明文。安全性更高，因为无需传输密钥。但</span><mark><span>无法保证完整性</span></mark><span>。如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230212152145852.png" referrerpolicy="no-referrer" alt="image-20230212152145852"><span> </span></p></li><li><p><span>常见的非对称加密算法如下:</span></p><ul><li><span>RSA:512位(或1024位) 密钥，计算机量极大，难破解</span></li><li><span>Elgamal、ECC(圆曲线算法)、背包算法、Rabin、D-H等</span></li></ul></li></ul></li><li><p><span>相比较可知，对称加密算法密钥一般只有</span><mark><span>56位</span></mark><span>，因此</span><mark><span>加密过程简单，适合加密大数据，也因此加密强度不高</span></mark><span>; 而非对称加密算法密钥有</span><mark><span>1024位</span></mark><span>，相应的解密计算量庞大，</span><mark><span>难以破解，却不适合加密大数据</span></mark><span>，，一般用来加密对称算法的密钥，这样，就将</span><mark><span>两个技术组合使用了，这也是数字信封的原理</span></mark></p></li><li><p><strong><span>数字信封原理</span></strong><span>: </span><mark><span>信是对称加密的密钥</span></mark><span>，数字信封就是</span><mark><span>对此密钥进行非对称加密</span></mark><span>，具体过程:发送方将数据用对称密钥加密传输，而将对称密钥用接收方公钥加密发送给对方。接收方收到数字信封，用自己的私钥解密信封，取出对称密钥解密得原文。</span></p></li><li><p><span>数字信封运用了对称加密技术和非对称加密技术，</span><mark><span>本质是使用对称密钥加密数据，非对称密钥加密对称密钥，解决了对称密钥的传输问题</span></mark></p></li><li><p><strong><span>信息摘要</span></strong></p><ul><li><span>所谓信息摘要，就是</span><mark><span>一段数据的特征信息</span></mark><span>，当</span><mark><span>数据发生了改变，信息摘要也会发生改变</span></mark><span>，发送方</span><mark><span>会将数据和信息摘要一起传给接收方</span></mark><span>，接收方会根据接收到的数据</span><mark><span>重新生成一个信息摘要</span></mark><span>，若此摘要和接收到的摘要相同，则说明数据正确。</span><strong><span>信息摘要是由哈希函数生成的。</span></strong></li><li><span>信息摘要的特点: 不算数据多长，都会产生</span><mark><span>固定长度的信息摘要，任何不同的输入数据，都会产生不同的信息摘要</span></mark><span>:单向性，即</span><mark><span>只能由数据生成信息摘要不能由信息摘要还原数据</span></mark></li><li><span>信息摘要算法: MD5(产生128位的输出)、SHA-1 (安全散列算法，产生160位的输出，安全性更高)</span></li></ul></li><li><p><strong><span>数字签名</span></strong><span>: </span><mark><span>唯一标识一个发送方</span></mark><span>，可以保证完整性和不可抵赖性，基于非对称加密</span></p><ul><li><p><span>发送者发送数据时，使用</span><mark><span>发送者的私钥进行加密</span></mark><span>，接收者收到数据后，只能</span><mark><span>使用发送者的公钥进行解密</span></mark><span>，这样就能</span><mark><span>唯一确定发送方</span></mark><span>，这也是数字签名的过程。</span><mark><span>但无法保证机密性</span></mark><span>。如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230212152903199.png" referrerpolicy="no-referrer" alt="image-20230212152903199"><span> </span></p></li></ul></li><li><p><strong><span>公钥基础设施PKI</span></strong><span>: 是以</span><mark><span>非对称密钥加密技术为基础</span></mark><span>，以数据机密性、完整性身份认证和行为不可抵赖性为安全目的，来实施和提供安全服务的具有普适性的</span><mark><span>安全基础设施</span></mark></p><ol start='' ><li><p><mark><span>数字证书</span></mark><span>:一个数据结构，是一种由一个</span><mark><span>可信任的权威机构签署的信息集合</span></mark><span>。在不同的应用中有不同的证书。如X.509证书必须包含下列信息: (1)本号 (2)序列号 (3)签名算法标识符 (4)认证机构 (5) 有效期限 (6)主题信息 (7) 认证机构的数字签名 (8) 公钥信息。</span></p><ul><li><mark><span>公钥证书主要用于确保公钥及其与用户绑定关系的安全。这个公钥就是证书所标识的那个主体的合法的公钥</span></mark><span>。任何一个用户只要知道签证机构的公钥，就能检查对证书的签名的合法性。如果检查正确，那么用户就可以相信那个证书所携带的公钥是真实的，而且这个公钥就是证书所标识的那个主体的合法的公钥 </span><mark><span>例如驾照</span></mark></li></ul></li><li><p><mark><span>签证机构CA: 负责签发证书、管理和撤销证书</span></mark><span>。是所有注册用户所信赖的权威机构，CA在给用户签发证书时</span><mark><span>要加上自己的数字签名</span></mark><span>，</span><mark><span>以保证证书信息的真实性。任何机构可以用CA的公钥来验证该证书的合法性</span></mark></p></li></ol></li></ul><h4><a name="网络安全技术" class="md-header-anchor"></a><span>网络安全技术</span></h4><ul><li><p><span>防火墙是在</span><mark><span>内部网络和外部因特网之间增加的一道安全防护措施</span></mark><span>，分为</span><mark><span>网络级防火墙和应用级防火墙</span></mark><span>。</span></p><ul><li><strong><span>网络级防火墙</span></strong><mark><span>层次低，但是效率高</span></mark><span>，因为其使用包过滤和状态监测手段，般只检验网络包外在(起始地址、状态) 属性是否异常，若异常，则过滤掉不与内网通信，因此对应用和用户是透明的。但是这样的问题是，如果遇到伪装的危险数据包就没办法过滤，此时，就要依靠应用级防火墙</span></li><li><strong><span>应用级防火墙</span></strong><span>，</span><mark><span>层次高，效率低</span></mark><span>，因为应用级防火墙会将网络包拆开，具体检查里面的数据是否有问题，会消耗大量时间，造成效率低下，但是安全强度高。</span></li></ul></li><li><p><strong><span>入侵检测系统IDS</span></strong></p><ul><li><span>防火墙技术主要是分隔来自外网的威胁，却对</span><mark><span>来自内网的直接攻击无能为力</span></mark><span>此时就要用到入侵检测IDS技术，位于防火墙之后的第二道屏障，作为防火墙技术的补充。</span></li><li><span>原理: </span><mark><span>监控当前系统/用户行为</span></mark><span>，使用入侵检测分析引擎进行分析，这里包含一个知识库系统，囊括了历史行为、特定行为模式等操作，将当前行为和知识库进行匹配，就能检测出当前行为是否是入侵行为，如果是入侵，则记录证据并上报给系统和防火墙，交由它们处理。</span></li><li><span>不同于防火墙，</span><mark><span>IDS入侵检测系统是一个监听设备，没有跨接在任何链路上无须网络流量流经它便可以工作</span></mark><span>。因此，对IDS的部署，唯一的要求是: </span><mark><span>IDS应当挂接在所有所关注流量都必须流经的链路上</span></mark><span>。因此，IDS在交换式网络中的位置般选择在: </span><mark><span>(1) 尽可能靠近攻击源 (2)尽可能靠近受保护资源</span></mark></li></ul></li><li><p><strong><span>入侵防御系统IPS</span></strong></p><ul><li><span>IDS和防火墙技术都是在入侵行为已经发生后所做的检测和分析，而</span><mark><span>IPS是能够提前发现入侵行为，在其还没有进入安全网络之前就防御</span></mark><span>。</span><mark><span>在安全网络之前的链路上挂载入侵防御系统IPS，可以实时检测入侵行为，并直接进行阻断</span></mark><span>，这是与IDS的区别，要注意。</span></li><li><strong><span>杀毒软件</span></strong><span>:用于</span><mark><span>检测和解决计算机病毒</span></mark><span>，与防火墙和IDS要区分，计算机病毒要靠杀毒软件防火墙是处理网络上的非法攻击。</span></li><li><strong><span>蜜罐系统</span></strong><span>: </span><mark><span>伪造一个蜜罐网络引诱黑客攻击</span></mark><span>，蜜罐网络被攻击不影响安全网络，并且可以借此了解黑客攻击的手段和原理从而对安全系统进行升级和优化。</span></li></ul></li><li><p><strong><span>网络攻击和威胁</span></strong><span>(重点)</span></p><ul><li><img src="http://qn.qs520.mobi/image-20230212172739556.png" referrerpolicy="no-referrer" alt="image-20230212172739556"><span>  </span></li></ul></li><li><p><strong><span>计算机病毒和木马</span></strong></p><ul><li><p><span>病毒: 编制或者在计算机程序中插入的</span><mark><span>破坏计算机功能或者破坏数据，影响计算机使用并且能够自我复制</span></mark><span>的一组</span><mark><span>计算机指令或者程序代码</span></mark></p></li><li><p><span>木马: 是一种</span><mark><span>后门程序</span></mark><span>常被黑客用作控制远程计算机的工具，隐藏在被控制电脑上的一个小程序监控电脑一切操作并盗取信息。</span></p></li><li><p><span>代表性病毒实例：</span></p><ul><li><span>蠕虫病毒(感染EXE文件): 熊猫烧香，罗密欧与朱丽叶，恶鹰，尼姆达，冲击波，欢乐时光。</span></li><li><span>木马: QQ消息尾巴木马，特洛伊木马，X卧底。</span></li><li><span>宏病毒(感染word、excel等文件中的宏变量):美丽沙，台湾1号。</span></li><li><span>CIH病毒:史上唯一破坏硬件的病毒。</span></li><li><span>红色代码:蠕虫病毒+木马。</span></li></ul></li></ul></li></ul><h4><a name="网络安全协议" class="md-header-anchor"></a><span>网络安全协议</span></h4><ul><li><p><span>物理层主要使用物理手段，隔离、屏蔽物理设备等，其它层都是靠协议来保证传输的安全，具体如下图所示:</span></p><p><img src="http://qn.qs520.mobi/image-20230212172953152.png" referrerpolicy="no-referrer" alt="image-20230212172953152"><span> </span></p></li><li><p><span>SSL协议: 安全套接字协议，被设计为</span><mark><span>加强Web安全传输(HTTP/HTTPS/)的协议</span></mark><span>，安全性高，和HTTP结合之后，形成HTTPS安全协议，端口号为443.</span></p></li><li><p><span>SSH协议:安全外壳协议，被设计为</span><mark><span>加强Telnet/FTP安全的传输协议</span></mark></p></li><li><p><span>SET协议: </span><mark><span>安全电子交易协议</span></mark><span>主要应用于</span><mark><span>B2C模式 (电子商务) 中保障支付信息的安全性</span></mark><span>。SET协议本身比较复杂，设计比较严格，安全性高，它能保证信息传输的机密性、真实性、完整性和不可否认性。</span><mark><span>SET协议是PKI框架下的一个典型实现</span></mark><span>，同时也在不断升级和完善，如SET 2.0将支持借记卡电子交易</span></p></li><li><p><span>Kerberos协议: 是一种</span><mark><span>网络身份认证协议</span></mark><span>，该协议的基础是</span><mark><span>基于信任第三方，它提供了在开放型网络中进行身份认证的方法</span></mark><span>，认证实体可以是用户也可以是用户服务。这种认证不依赖宿主机的操作系统或计算机的IP地址，不需要保证网络上所有计算机的物理安全性，并且假定数据包在传输中可被随机窃取和篡改。两种体制：Kerberos和PKI</span></p></li><li><p><span>PGP协议:使用</span><mark><span>RSA公钥证书</span></mark><span>进行身份认证，使用</span><mark><span>IDEA (128位密)</span></mark><span> 进行数据加密，使用</span><mark><span>MD5</span></mark><span>进行数据完整性验证。综合运用对称加密，非对称加密，信息摘要，数字信封，数字签名等技术</span></p><ul><li><p><span>发送方A有三个密钥:A的私钥、B的公钥、A生成的一次性对称密钥</span></p></li><li><p><span>接收方B有两个密钥: B的私钥、A的公钥。</span></p><p><img src="http://qn.qs520.mobi/image-20230212173255106.png" referrerpolicy="no-referrer" alt="image-20230212173255106"><span>   </span></p></li></ul></li></ul><h2><a name="span-id8知识产权和标准化8知识产权和标准化span" class="md-header-anchor"></a><span id="8.知识产权和标准化"><span>8.知识产权和标准化</span></span></h2><h4><a name="知识产权概述" class="md-header-anchor"></a><span>知识产权概述</span></h4><ul><li><p><span>知识产权是指公民、法人、非法人单位对自己的</span><mark><span>创造性智力成果和其他科技成果依法享有的民事权</span></mark><span>。是</span><mark><span>智力成果的创造人</span></mark><span>依法享有的权利和在</span><mark><span>生产经营活动中标记所有人</span></mark><span>依法所享有的权利的总称。包含</span><mark><strong><span>著作权、专利权、商标权、商业秘密权</span></strong><span>、植物新品种权、集成电路布图设计权和地理标志权等</span></mark></p></li><li><p><span>属性：</span></p><ul><li><mark><span>无体性</span></mark><span>:知识产权的对象</span><mark><span>是没有具体形体，是智力创造成果</span></mark><span>，是一种抽象的财富。</span></li><li><mark><span>专有性</span></mark><span>:指除权利人同意或法律规定外，权利人以外的任何人不得享有或使用该项权利。</span></li><li><mark><span>地域性</span></mark><span>: 指知识产权</span><mark><span>只在授予其权利的国家或确认其权利的国家产生</span></mark><span>，并且</span><mark><span>只能在该国范围内受法律保护，而其他国家则不受保护。</span></mark></li><li><mark><span>时间性</span></mark><span>:</span><mark><span>仅在法律规定的期限内受到保护</span></mark><span>，一旦超过期限，权利自行消灭相关知识产品即成为整个社会的共同财富，为全人类所共同使用。</span></li></ul></li><li><p><span>在软件使用许可中，按照被许可使用权排他性强弱的不同，可分为</span><mark><span>独占使用许可，排他使用许可，普通使用许可</span></mark></p></li></ul><h4><a name="保护期限" class="md-header-anchor"></a><span>保护期限</span></h4><ul><li><p><mark><span>知识产权具有地域限制，保护期限</span></mark><span>各种情况如下表所示：</span></p><p><img src="http://qn.qs520.mobi/image-20230212200814559.png" referrerpolicy="no-referrer" alt="image-20230212200814559"><span> </span></p></li></ul><h4><a name="知识产权人的确定" class="md-header-anchor"></a><span>知识产权人的确定</span></h4><ol start='' ><li><p><span>职务作品</span></p><p><img src="http://qn.qs520.mobi/image-20230212200852464.png" referrerpolicy="no-referrer" alt="image-20230212200852464"><span> </span></p></li><li><p><span>委托作品，单位和委托的区别在于，当合同中未规定著作权的归属时，著作权默认归于单位，而委托创作中，著作权默认归属于创作方个人，具体如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230212200946342.png" referrerpolicy="no-referrer" alt="image-20230212200946342"><span> </span></p></li></ol><h4><a name="侵权判定考点" class="md-header-anchor"></a><span>侵权判定(考点)</span></h4><ul><li><p><span>中国公民、法人或者其他组织的作品，</span><mark><span>不论是否发表，都享有著作权</span></mark><span>，开发软件所用的</span><mark><span>思想、处理过程、操作方法或者数学概念不受保护</span></mark></p></li><li><p><span>著作权法</span><mark><span>不适用</span></mark><span>于下列情形:法律、法规、国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文;时事新闻:历法、通用数表、通用表格和公式</span></p><p><img src="http://qn.qs520.mobi/image-20230212201129687.png" referrerpolicy="no-referrer" alt="image-20230212201129687"><span> </span></p></li></ul><h4><a name="标准划分" class="md-header-anchor"></a><span>标准划分</span></h4><ul><li><p><span>根据标准制定机构和适用范围的不同，可分为</span><mark><span>国际标准、国家标准、行业标准、区域/地方标准和企业标准</span></mark></p><ol start='' ><li><span>国际标准:是指国际标准化组织(IS)、国际电工委员会(IEC)和国际电信联盟(ITU 制定的标准以及国际标准化组织确认并公布的其他国际组织制定的标准。</span><mark><span>国际标准在世界范围内统一使用,提供各国参考</span></mark></li><li><span>国家标准:是指由</span><mark><span>国家标准化主管机构制定或批准发布，在全国范围内统一适用的标准</span></mark><span>。比如: GB--.中华人民共和国国家标准，强制性国家标准代号为GB，推荐性国家标准代号为GB/T，国家标准指导性文件代号为GB/Z，国军标代号为GJB。ANSI (American National Standards nstitute) ---美国国家标准协会标准</span></li><li><span>行业标准:是由</span><mark><span>某个行业机构、团体等制定的，适用于某个特定行业业务领域的标准</span></mark><span>。比如: EEE-.美国电气电子工程师学会标准;GA---公共安全标准，YD---通信行业标准</span></li><li><span>区域/地方标准:是由</span><mark><span>某一区域/地方内的标准化主管机构制定、批准发布的，适用于某个特定区域/地方的标准</span></mark><span>。比如: EN---欧洲标准</span></li><li><span>企业标准: 是</span><mark><span>企业范围内根据需要协调、统一的技术要求、管理要求和工作要求所制定的标准，适用于本企业内部的标准</span></mark><span>。一般以Q字开头，比如Q/320101 RER 001-2012，其中320101代表地区，RER代表企业名称代号，001代表该企业该标准的序号，2012代表年号</span></li></ol></li></ul><h2><a name="span-id9企业信息化战略与实施考点9企业信息化战略与实施考点span" class="md-header-anchor"></a><span id="9.企业信息化战略与实施(考点)"><span>9.企业信息化战略与实施(考点)</span></span></h2><h4><a name="信息" class="md-header-anchor"></a><span>信息</span></h4><ul><li><p><strong><span>信息</span></strong><span>是</span><mark><span>客观事物状态和运动特征的一种普遍形式</span></mark><span>，客观世界中大量地存在产生和传递着以这些方式表示出来的各种各样的信息。</span></p></li><li><p><span>控制论创始人维纳认为: </span><mark><span>信息就是信息，既不是物质也不是能量</span></mark><span>，</span><strong><span>香农</span></strong><span>是信息论的奠基者提出信息是“</span><mark><span>用以消除随机不确定性的东西，定了信息量的单位为比特( bit )</span></mark></p></li><li><p><span>信息具有价值，而价值的大小决定于信息的质量，这就要求</span><mark><span>信息满足一定的质量属性</span></mark><span>，包括:</span></p><ul><li><mark><span>精确性</span></mark><span>：对事物状态描述的精准程度。</span></li><li><mark><span>完整性</span></mark><span>：对事物状态描述的全面程度，完整信息应包括所有重要事实。</span></li><li><mark><span>可靠性</span></mark><span>：指信息的来源、采集方法、传输过程是可以信任的，符合预期。</span></li><li><mark><span>及时性</span></mark><span>：指获得信息的时刻与事件发生时刻的间隔长短。昨天的天气信息不论怎样精确、完整，对指导明天的穿衣并无帮助，从这个角度出发，这个信息的价值为零。</span></li><li><mark><span>经济性</span></mark><span>：指信息获取、传输带来的成本在可以接受的范围之内</span></li><li><mark><span>可验证性</span></mark><span>：指信息的主要质量属性可以被证实或者证伪的程度</span></li><li><mark><span>安全性</span></mark><span>：指在信息的生命周期中，信息可以被非授权访问的可能性，可能性越低，安全性越高。</span></li><li><mark><span>真伪性</span></mark><span>:真实是信息的中心价值，不真实的信息价值可能为负。</span></li><li><mark><span>层次性</span></mark><span>:信息一般和管理层一样，可以为战略层、策略层和执行层 3 个层次。</span></li><li><mark><span>不完全性</span></mark><span>:客观事实的全部信息是不可能得到的。我们需要正确滤去不重要的信息、失真的信息抽象出有用的信息。</span></li><li><mark><span>滞后性</span></mark><span>:信息是数据加工的结果，因此信息必然落后于数据，加工需要时间</span></li><li><mark><span>扩压性</span></mark><span>:信息和实物不同，它可以扩散也可以压缩。</span></li><li><mark><span>分享性</span></mark><span>:信息可以分享，这和物质不同，并且信息分享具有非零和性。</span></li><li><span>示例:2019年10月1日，以中共中央·.·”在北京天安门广场隆重举行庆祝中华人民共和国成立70周年大会</span></li></ul></li></ul><h4><a name="信息系统" class="md-header-anchor"></a><span>信息系统</span></h4><ul><li><strong><span>信息系统</span></strong><span>的</span><mark><span>组成部件包括硬件、软件、数据库、网络、存储设备、感知设备，外设、人员以及把数据处理成信息的规程</span></mark><span>等。</span></li><li><span>硬件: 由执行输入、处理和输出行为的计算机设备组成</span></li><li><span>软件: 由管理计算机运行的程序构成</span></li><li><span>数据库: 是经过机构化、规范化组织后的事实和信息的集合。数据库是信息系统中最有价值和最重要的一部分。</span></li></ul><h4><a name="信息技术发展趋势" class="md-header-anchor"></a><span>信息技术发展趋势</span></h4><ul><li><p><span>我在国</span><mark><span>“十三五”</span></mark><span>规划纲要中，将培育</span><mark><span>人工智能、移动智能终端、第五代移动通信(5G)，先进传感器</span></mark><span>等作为新一代信息技术产业创新重点发展，拓展新兴产业发展空间。</span></p></li><li><p><span>当前，信息技术发展的总趋势是从典型的</span><mark><span>技术驱动发展模式向应用驱动与技术驱动相结合</span></mark><span>的模式转变，</span><strong><span>信息技术发展趋势和新技术应用主要包括以下几个方面:</span></strong></p><ol start='' ><li><span>高速度大容量。</span></li><li><span>集成化和平台化。</span></li><li><span>智能化</span></li><li><span>虚拟计算。</span></li><li><span>通信技术。</span></li><li><span>遥感和传感技术</span></li><li><span>移动智能终端。</span></li><li><span>以人为本</span></li><li><span>信息安全</span></li></ol></li><li><p><mark><span>工业化与信息化“两化融合”</span></mark><span>的含义:</span></p><ul><li><span>一是信息化与工业化发展战略的融合，即信息化发展战略与工业化发展战略要协调一致，信息化发展模式与工业化发展模式要高度匹配，信息化规划与工业化发展规划、计划要密切配合;</span></li><li><span>二是指信息资源与材料、能源等工业资源的融合;</span></li><li><span>三是指虚拟经济与工业实体经济融合</span></li><li><span>四是指信息技术与工业技术、IT 设备与工业装备的融合</span></li></ul></li><li><p><span>互联网+是两化融合的升级，是互联网+各种传统行业</span></p></li></ul><h4><a name="国家信息化体系六要素" class="md-header-anchor"></a><span>国家信息化体系六要素</span></h4><ul><li><p><mark><span>信息技术应用</span></mark><span>: 是</span><mark><span>信息化体系六要素中的龙头</span></mark><span>，是国家信息化建设的主阵地，集中体现了国家信息化建设的需求与利益;</span></p></li><li><p><mark><span>信息资源</span></mark><span>: 其</span><mark><span>开发利用是国家信息化的核心任务</span></mark><span>，是国家信息化建设取得实效的关键，也是我国信息化的薄弱环节;</span></p></li><li><p><mark><span>信息网络</span></mark><span>: 是信息资源开发利用和信息技术应用的基础，是</span><mark><span>信息传输、交换、共享的必要手段</span></mark></p></li><li><p><mark><span>信息技术和产业</span></mark><span>: </span><mark><span>是我国进行信息化建设的基础</span></mark></p></li><li><p><mark><span>信息化人才</span></mark><span>: </span><mark><span>是国家信息化成功之本</span></mark><span>，对其他各要素的发展速度和质量起着决定性的影响，是信息化建设的关键:</span></p></li><li><p><mark><span>信息化政策法规和标准规范</span></mark><span>: 用于规范和协调信息化体系六要素之间关系，是</span><mark><span>国家信息化快速、持续、有序、健康发展的根本保障</span></mark></p></li><li><p><span>助记:上鹰(应用)，下鸡(技术)，左人(人才)，右龟(法规)，中间织(资源)张网(网络)</span></p><p><img src="http://qn.qs520.mobi/image-20230213173111618.png" referrerpolicy="no-referrer" alt="image-20230213173111618"><span> </span></p></li></ul><h4><a name="电子政务" class="md-header-anchor"></a><span>电子政务</span></h4><ul><li><p><span>政府对政府G2G:政府之间上级对下级政府对企业</span></p></li><li><p><span>G2B:企业到政府办事。</span></p></li><li><p><span>政府对公众G2C:公众对政府信息的查询。</span></p></li><li><p><span>政府对公务员G2E:政府内部工作人员自动化办公，是其他模式的基础</span></p><p><img src="http://qn.qs520.mobi/image-20230213173542700.png" referrerpolicy="no-referrer" alt="image-20230213173542700"><span> </span></p></li></ul><h4><a name="信息化战略体系" class="md-header-anchor"></a><span>信息化战略体系</span></h4><ul><li><mark><span>企业战略规划</span></mark><span>利用</span><mark><span>机会和威胁评价现在和未来的环境</span></mark><span>，用</span><mark><span>优势和劣势评价企业现状</span></mark><span>，进而选择和确定</span><mark><span>企业的总体和长远目标</span></mark><span>，制定和抉择实现目标的行动方案。</span></li><li><mark><span>信息系统战略规划</span></mark><span>关注</span><mark><span>如何通过信息系统来支撑业务流程的运作</span></mark><span>，进而实现企业的关键业务目标，其</span><mark><span>重点在于对信息系统远景、组成架构、各部分逻辑关系进行规划</span></mark><span>，企业战略与信息化战略集成的主要方法有 BITA (Business-IT Agnment，</span><mark><span>业务与 IT 整合</span></mark><span>)和EITA (Enterprise IT Architecture，</span><mark><span>企业 IT 架构</span></mark><span>)。</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230213173704818.png" referrerpolicy="no-referrer" alt="image-20230213173704818"><span> </span></p><ul><li><p><mark><span>信息技术战略规划</span></mark><span>:通常简称为</span><mark><span>IT战略规划</span></mark><span>，是在</span><mark><span>信息系统规划的基础上</span></mark><span>，对</span><mark><span>支撑信息系统运行的硬件、软件、支撑环境等进行具体的规划</span></mark><span>，它更关心技术层面的问题。</span></p></li><li><p><mark><span>信息资源规划IRP</span></mark><span>是在以上规划的基础上，为开展具体的信息化建设项目而进行的</span><mark><span>数据需求分析、信息资源标准建立、信息资源整合工作</span></mark><span>，</span><mark><span>信息资源规划</span></mark><span>是信息化建设的基础工程，是指对企业生产经营活动所需要的信息，对产生、获取、处理、存储、传输和利用等方面进行全面的规划。IRP 强调</span><mark><span>将需要分析和系统建模紧密结合起来，需求分析是系统建模的准备，系统建模是用户需求的定型和规范化表达。</span></mark><span>分为七个步骤，这里列举四个：</span></p><ul><li><mark><span>业务需求分析</span></mark><span>：职能域分析，业务域定义， 业务流程梳理</span></li><li><mark><span>数据需求分析</span></mark><span>：用户视图收集，用户视图分组、分析，数据元素分析</span></li><li><mark><span>系统功能建模</span></mark><span>：子系统定义功能，模块定义，程序单元定义</span></li><li><mark><span>系统数据建模</span></mark><span>：主题数据库定义，基本表定义，扩展表定义</span></li></ul></li><li><p><mark><span>系统规划</span></mark><span>: </span><mark><span>单个项目的立项分析</span></mark><span>，是信息系统生命周期的第一个阶段，期任务是对企业的环境、目标及现有系统的状况进行初步调查，根据企业目标和发展战略，确定信息系统的发展战略，对建设新系统的需求做出分析和预测，同时考虑建设新系统所受的各种约束，研究建设新系统的必要性和可能性。</span></p></li></ul><h4><a name="信息系统战略规划" class="md-header-anchor"></a><span>信息系统战略规划</span></h4><ul><li><p><span>一个</span><mark><span>企业信息系统的战略规划可分为下面三个阶段</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230213174141300.png" referrerpolicy="no-referrer" alt="image-20230213174141300"><span> </span></p></li><li><p><strong><span>第一阶段:以数据处理为核心，围绕职能部门需求</span></strong></p><ul><li><mark><span>企业系统规划法BSP: 自上而下地识别</span></mark><span>企业目标、企业过程和数据，然后对数据进行分析，</span><mark><span>自下而上地</span></mark><span>设计信息系统。</span><mark><span>重视数据的创建和使用</span></mark><span>，以数据的创建和使用归类，提供一个信息系统规划，</span><mark><span>建立CU矩阵(创建使用矩阵)</span></mark><span>, </span></li><li><mark><span>关键成功因素法CSF</span></mark><span>: 重视</span><mark><span>关键因素</span></mark><span>，每个企业在某阶段都有关键因素，抓住关键信息。</span></li><li><mark><span>战略集合转化法SST</span></mark><span>: 将企业的战略信息(环境、目标等)收集起来，</span><mark><span>当成一个“信息集合</span></mark><span>”并且</span><mark><span>转换为信息系统的战略信息</span></mark><span>，全方位的注重企业的战略信息。</span></li></ul></li><li><p><strong><span>第二阶段:以企业内部MIS(管理信息系统)为核心，围绕企业整体需求</span></strong></p><ul><li><mark><span>战略数据规划法SDP: 强调建立企业模型和主题数据库</span></mark><span>(重点和关键，</span><mark><span>是面向业务主题</span></mark><span>，整个企业的)，</span><mark><span>数据类基本上是稳定的，而业务和流程是多变的</span></mark><span>。</span></li><li><mark><span>信息工程法IE: 第一次提出以工程的方法来建立信息系统</span></mark><span>，信息工程是面向企业计算机信息系统建设，</span><mark><span>以数据为中心的开发方法</span></mark><span>。信息工程方法认为，与企业的信息系统密切相关的三要素是: </span><mark><span>企业的各种信息、企业的业务过程和企业采用的信息技术</span></mark><span>。信息工程自上而下地将整个信息系统的开发过程划分为四个实施阶段，分别是</span><mark><span>信息规划阶段、业务领域分析阶段、系统设计阶段和系统构建阶段</span></mark><span>。</span></li><li><mark><span>战略栅格法SG</span></mark><span>: 建立一个2*2的矩阵，每个矩阵元素代表过程对</span><mark><span>数据类</span></mark><span>的创建和使用等。</span><mark><span>栅格即划分矩阵</span></mark></li></ul></li><li><p><strong><span>第三阶段:综合考虑企业内外环境，以集成为核心，围绕企业战略需求</span></strong></p><ul><li><mark><span>价值链分析法VCA</span></mark><span>: 将所有对企业有影响的信息作为一个个活动，其都有可能对企业造成增值，</span><mark><span>分析其中对企业增值最大的信息</span></mark><span>。</span></li><li><mark><span>战略一致性模型SAM</span></mark><span>: 保证</span><mark><span>企业战略和信息系统战略要一致</span></mark></li></ul></li></ul><h4><a name="企业信息化" class="md-header-anchor"></a><span>企业信息化</span></h4><ul><li><strong><span>企业信息化程度</span></strong><span>是国家信息化建设的基础和关键，企业信息化就是企业利用</span><mark><span>现代信息技术</span></mark><span>，通过</span><mark><span>信息资源的深入开发和广泛利用</span></mark><span>，实现企业生产过程的自动化管理方式的网络化、决策支持的智能化和商务运营的电子化，不断提高生产、经营、管理、决策的效率和水平，进而</span><mark><span>提高企业经济效益和企业竞争力</span></mark><span>的过程。企业信息化方法主要包括</span><mark><span>业务流程重构、核心业务应用、信息系统建设、主题数据库、资源管理和人力资本投资方法</span></mark></li><li><span>企业信息化</span><mark><span>一定要建立在企业战略规划基础之上</span></mark><span>，以企业战略规划为基础建立的企业管理模式是建立企业战略数据模型的依据。企业信息化就是</span><mark><span>技术和业务的融合</span></mark><span>。这个“融合”并不是简单地利用 信息系统对手工的作业流程进行自动化而是需要从</span><mark><span>企业战略的层面、业务运作层面、管理运作层面</span></mark><span>这3个层面来实现</span></li><li><span>企业信息化涉及到对</span><mark><span>企业管理理念的创新</span></mark><span>，管理科学的核心就是应用科学的方法实施管理，按照市场发展的要求，</span><mark><span>对企业现有的管理流程重新整合</span></mark><span>，从作为管理核心的</span><mark><span>财务、资金管理，向技术、物资、人力资源的管理</span></mark><span>，并延伸到</span><mark><span>企业技术创新、工艺设计、产品设计、生产制造过程的管理</span></mark><span>，进而扩展到</span><mark><span>客户关系管理供应链的管理乃至发展电子商务</span></mark><span>，形成企业内部向外部扩散的全方位管理。</span></li><li><span>企业信息化过程中有3个重要影响因素: </span><mark><span>经营战略、业务流程与组织、信息架构</span></mark><span>.</span></li></ul><h4><a name="企业资源计划erp" class="md-header-anchor"></a><span>企业资源计划ERP</span></h4><ul><li><p><strong><span>企业资源计划ERP</span></strong><span>: 由</span><mark><span>MRP (物料需求计划)</span></mark><span>逐步演变并结合计算机技术的快速发展而来，大致经历了以下四个阶段:</span></p><ol start='' ><li><mark><span>基本MRP</span></mark><span>: 聚焦于相关</span><mark><span>物资需求问题</span></mark><span>，根据生产计划、物料清单、库存信息</span><mark><span>制定出相关的物资需求时间表</span></mark><span>，从而</span><mark><span>及时采购所需物资，降低库存</span></mark><span>。不足: </span><mark><span>没有考虑企业现有生产能力和采购约束</span></mark></li><li><mark><span>闭环MRP</span></mark><span>: 在基本MRP基础上，</span><mark><span>增加了生产能力计划</span></mark><span>、</span><mark><span>车间作业计划和采购作业计划</span></mark><span>，</span><mark><span>将整个生产管理过程纳入计划</span></mark><span>: 并且在计划执行中</span><mark><span>根据反馈信息平衡和调整计划，使得生产的各个方面协调统一，形成一个环形回路</span></mark><span>。不足: </span><mark><span>没有充分考虑资金流。</span></mark></li><li><mark><span>MRPⅡ</span></mark><span>指的是</span><mark><span>制造资源计划</span></mark><span>，将生产、财务、销售、工程技术和采购等</span><mark><span>各个子系统集成为一个一体化的系统</span></mark><span>。不足:主要侧重于</span><mark><span>企业内部</span></mark><span>人力、财务管理。</span></li><li><mark><span>ERP</span></mark><span>是</span><mark><span>一个以财务会计为核心</span></mark><span>的信息系统，把</span><mark><span>客户需求和企业内部的制造活动以及供应商的制造资源整合在一起</span></mark><span>，形成一个</span><mark><span>完整的供应链</span></mark><span>并对供应链上的所有环节进行有效管理。从而达到</span><mark><span>最佳资源组合，使企业利润最大化</span></mark></li></ol></li><li><p><span>ERP功能:</span></p><ol start='' ><li><mark><span>财会管理</span></mark><span>: 会计核算、财务管理。</span></li><li><mark><span>生产控制管理</span></mark><span>: 主生产计划、物料需求计划、能力需求计划、车间控制、制造标准。</span></li><li><mark><span>物流管理</span></mark><span>: 销售管理、库存控制、采购管理。</span></li><li><mark><span>人力资源管理:</span></mark><span> 人力资源规划的辅助决策、招聘管理、工资核算、工时管理、差旅核算。</span></li></ol></li><li><p><span>ERP特点:</span></p><ol start='' ><li><span>是</span><mark><span>统一的集成系统</span></mark></li><li><span>是</span><mark><span>面向业务流程的系统</span></mark></li><li><span>是</span><mark><span>模块化可配置的</span></mark></li><li><span>是</span><mark><span>开放的系统</span></mark></li></ol></li><li><p><span>企业有三大资源: </span><mark><span>物流(物流管理)、资金流(财务管理), 信息流(生产控制管理)</span></mark><span>现在一般认为</span><mark><span>人力资源(人力资源管理)是企业第四大资源</span></mark></p></li><li><p><span>企业的资源计划可从下面三点来理解:</span></p><ul><li><mark><span>管理思想</span></mark><span>: ERP首先是一种管理思想，将企业资源分类管理，是管理思想的变革。</span></li><li><mark><span>软件产品</span></mark><span>: 其次ERP是个软件产品，为企业用户提供一体化的解决方案。</span></li><li><mark><span>管理系统</span></mark><span>: ERP最后是一个管理系统，存在众多的子系统，这些子系统有统一的规划，是互联互通的，便于事前事中监控。</span></li></ul></li><li><p><strong><span>ERP的五个层次</span></strong></p><ul><li><mark><span>生产计划大纲是根据经营计划的生产目标制定的</span></mark><span>，是对企业经营计划的细化，用以描述企业在可用资源的条件下，在一定时期中的</span><mark><span>产量计划</span></mark><span>。</span></li><li><mark><span>主生产计划是对企业生产计划大纲的细化</span></mark><span>，说明在一定时期内的如下计划: </span><mark><span>生产什么生产多少和什么时候交货</span></mark></li><li><mark><span>物料需求计划</span></mark><span>是对主生产计划的</span><mark><span>各个项目所需的全部制造件和全部采购件的网络支持计划和时间进度计划。</span></mark></li><li><mark><span>能力需求计划</span></mark><span>是对物料需求计划所需能力进行核算的一种</span><mark><span>计划管理方法</span></mark><span>。旨在通过分析</span><mark><span>比较MRP的需求和企业现有生产能力</span></mark><span>，及早发现能力的瓶颈所在。</span></li><li><mark><span>车间作业计划</span></mark><span>是在MRP所产生的加工制造订单(即自制零部件生产计划)的基础上，按照交货期的前后和生产优先级选择原则以及车间的生产资源情况(如设 备、人员、物料的可用性、加工能力的大小等)，将零部件的生产计划以订单的形式下达给适当的车间。</span></li></ul></li></ul><h4><a name="客户关系管理crm" class="md-header-anchor"></a><span>客户关系管理CRM</span></h4><ul><li><p><strong><span>客户关系管理CRM</span></strong><span>:  </span><mark><span>以客户为中心，提高客户满意度、增加客户的忠诚度</span></mark><span>, CRM是一个</span><mark><span>集成化的信息管理系统</span></mark><span>，它</span><mark><span>存储了企业现有和潜在客户的信息</span></mark><span>，并且对这些信息进行</span><mark><span>自动的处理</span></mark><span>从而产生</span><mark><span>更人性化的市场管理策略</span></mark></p></li><li><p><span>CRM涵盖的要素主要有:</span></p><ol start='' ><li><span>CRM</span><mark><span>以信息技术为手段</span></mark><span>，但是CRM绝不仅仅是某种信息技术的应用，它更是一种</span><mark><span>以客户为中心的商业策略</span></mark><span>，CRM注重的是与</span><mark><span>客户的交流</span></mark><span>，企业的经营是</span><mark><span>以客户为中心</span></mark><span>，而不是传统的以产品或以市场为中心。</span></li><li><span>CRM在注重提高客户的满意度的同时，一定要把帮助企业提高获取利淮的能力作为重要指标。</span></li><li><span>CRM的实施</span><mark><span>要求企业对其业务功能进行重新设计，并对工作流程进行重组 (BPR)，将业务的中心转移到客户，同时要针对不同的客户群体有重点地采取不同的策略</span></mark></li></ol></li><li><p><strong><span>CRM系统的主要模块包</span></strong><span>括</span><mark><span>销售自动化、营销自动化、客户服务与支持、商业智能。</span></mark></p></li><li><p><span>CRM的功能：</span></p><ul><li><strong><span>客户服务</span></strong><span>: 是CRM的</span><mark><span>关键内容</span></mark><span>，对客户提供的服务，可以提高客户忠诚度</span></li><li><strong><span>市场营销</span></strong><span>:包括商机产生、商机获取和管理、商业活动管理和电话营销等; </span><mark><span>销售人员与潜在客户的互动行为</span></mark><span>、将潜在客户发展为真正客户并保持其忠诚度是使企业赢利的核心因素。</span></li><li><strong><span>共享的客户资料库</span></strong><span>: 是企业的一种重要信息资源，将</span><mark><span>市场营销和客户服务连接起来</span></mark><span>。也是CRM的基础和依托。</span></li><li><strong><span>分析能力</span></strong><span>: CRM的一个重要方面在于它</span><mark><span>具有使客户价值最大化的分析能力</span></mark><span>。对上述获取的资料库进行分析。</span></li></ul></li><li><p><mark><span>市场营销和客户服务是CRM的支柱性功能</span></mark></p></li><li><p><span>一个有效的CRM解决方案应该具备以下要素:</span></p><ul><li><mark><span>畅通有效的客户交流渠道</span></mark><span>(触发中心)</span></li><li><mark><span>对所获信息进行有效分析</span></mark><span>(挖掘中心)</span></li><li><span>CRM</span><mark><span>必须能与ERP很好地集成</span></mark></li></ul></li><li><p><span>CRM的实现过程</span></p><ul><li><mark><span>客户服务与支持</span></mark><span>：即通过控制服务品质以赢得顾客的忠诚度</span></li><li><mark><span>客户群维系</span></mark><span>: 即通过与顾客的交流实现新的销售。</span></li><li><mark><span>商机管理</span></mark><span>: 即利用数据库开展销售</span></li></ul></li></ul><h4><a name="供应链管理scm" class="md-header-anchor"></a><span>供应链管理SCM</span></h4><ul><li><p><strong><span>供应链管理SCM</span></strong><span>: 是一种</span><mark><span>集成的管理思想和方法</span></mark><span>，是在满</span><mark><span>足服务水平要求</span></mark><span>的同时，为了使</span><mark><span>系统成本达到最低</span></mark><span>而采用的</span><mark><span>将供应商、制造商、仓库和商店有效地结合成一体来生产商品</span></mark><span>，有效地控制和管理各种</span><mark><span>信息流、资金流和物流</span></mark><span>，并把</span><mark><span>正确数量的商品在正确的时间配送到正确的地点</span></mark><span>的一套管理方法。</span></p><ul><li><mark><span>以客户为中心</span></mark><span>。SCM</span><mark><span>追求的目标首先是满足客户的需求;衡量SCM绩效的最重要的指标就是客户满意度</span></mark><span>。</span></li><li><span>集成化管理。SCM的本质</span><mark><span>在于集成化管理</span></mark></li><li><span>扩展性管理。现代的SCM使传统的企业向</span><mark><span>扩展性企业发展</span></mark></li><li><span>合作管理。SCM非常强调</span><mark><span>企业之间的合作</span></mark><span>，打破传统的封闭的经营意识通过供应链中各个节点企业之间建立起</span><mark><span>新型的合作关系</span></mark><span>。</span></li><li><span>多层次管理。包括</span><mark><span>公司战略层次、战术层次和作业层次</span></mark><span>上的活动，主要目标是通过系统的观点，对多个职能和各个层次的供应商进行整合。</span></li></ul></li><li><p><strong><span>供应链节点</span></strong><span>: </span><mark><span>供应商、制造商、分销商、零售商、仓库、配送中心、客户</span></mark><span>等</span></p></li><li><p><span>每个企业内部都有一条或者几条供应链，每个企业也都处于一条供应链的某个节点中，SCM要注意的就是供应网络的构造，处于供应链中的企业是利益共同体，如何实现协作运营。</span></p></li><li><p><span>SCM包括</span><mark><span>计划、采购、制造、配送、退货</span></mark><span>五大基本内容。</span></p><ul><li><span>计划: 这是SCM的</span><mark><span>策略部分</span></mark><span>，企业需要有</span><mark><span>一个策略来管理所有的资源</span></mark><span>，以满足客户对产品的需求。好的计划是建立一系列的方法监控供应链。</span></li><li><span>采购: 选择能</span><mark><span>为企业提供产品和服务的供应商。</span></mark></li><li><span>制造: </span><mark><span>安排生产、测试、打包和准备送货所需的活动</span></mark><span>，是供应链中测量内容最多的部分。</span></li><li><span>配送: </span><mark><span>即物流</span></mark><span>，是调整用户的订单收据、建立仓库网络、拍递送人员提货并送货、建立产品计价系统、接收付款</span></li><li><span>退货: 是供应链中的</span><mark><span>问题处理部分</span></mark></li></ul></li></ul><h4><a name="决策支持系统dss" class="md-header-anchor"></a><span>决策支持系统DSS</span></h4><ul><li><p><span>帮助</span><mark><span>决策者提高决策水平和质量，起到辅助作用：</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230214094530576.png" referrerpolicy="no-referrer" alt="image-20230214094530576"><span> </span></p></li><li><p><span>DSS系统由四个子系统组成:</span></p><ul><li><span>数据库子系统:建立与</span><mark><span>决策相关的信息</span></mark><span>;</span></li><li><span>推理部分: </span><mark><span>知识库，包含智能推理分析算法</span></mark></li><li><span>模型库子系统: 是最</span><mark><span>复杂的子系统</span></mark><span>，一系列</span><mark><span>应用场景模型</span></mark><span>，</span><mark><span>用户主要根据模型来决策;</span></mark></li><li><span>用户接口子系统: 是</span><mark><span>一个人机交互界面</span></mark><span>，完美的集合上述三个子系统，供用户使用。</span></li></ul></li><li><p><span>决策支持可以分为</span><mark><span>结构化决策、半结构化决策和非结构化决策</span></mark><span>其中，</span></p><ul><li><span>结构化决策是指对某一决策过程的规则进行</span><mark><span>确定性描述与建模</span></mark><span>，以适当的算法产生决策方案，并能从多种方案中选择最优解;</span></li><li><span>非结构化决策的决策过程复杂，</span><mark><span>不可能用确定的模型和语言描述其决策过程</span></mark><span>更无所谓最优解。</span></li><li><span>半结构化和非结构化决策一般用于</span><mark><span>企业的中、高级管理层</span></mark><span>。一般来说，</span><mark><span>决策往往不可能一次完成，而是一个迭代的过程</span></mark></li></ul></li></ul><h4><a name="补充" class="md-header-anchor"></a><span>补充</span></h4><ul><li><p><mark><span>工作流管理系统(WFMS)</span></mark><span>：WFMS 将业务流程中工作如何组织与协调的规则抽象出来，在 WFMS 的协助下，开发人员遵从一定的编程接口和约定，就可以开发出更具灵活性的事务处理系统，用户无需重新开发即可更改工作流程，以适应业务的变更。通过</span><mark><span>软件定义</span></mark><span>创建工作流</span></p><ul><li><p><span>WFMS 的基本功能体现在以下几个方面:</span></p><ul><li><span>(1)</span><mark><span>对工作流进行建模。即定义工作流</span></mark><span>，包括具体的活动和规则等，所创建的模型是同时可以被人和计算机所“理解”的，工作流对应现实世界的业务处理过程，不能改变真实业务的处理逻辑。</span></li><li><span>(2)</span><mark><span>工作流执行</span></mark><span>。遵循工作流模型来创建和执行实际的工作流，即通过 WFMS 可以执行多个工作项。</span></li><li><span>(3)</span><mark><span>业务过程的管理和分析</span></mark><span>监控和管理执行中的业务(工作流)，例如，进度完成情况和数据所处状态、工作分配与均衡情况等</span></li></ul></li><li><p><span>六个模块：</span><mark><span>工作流执行服务(核心)，工作流引擎，流程定义工具(展示流程)，客户端应用，调用应用，管理监控工具</span></mark></p></li></ul></li><li><p><mark><span>企业资源规划系统</span></mark><span>是一套为企业运营提供辅助决策和日常管理信息的大规模集成化软 件，同时也是辅助企业管理向零缺陷趋近的一整套现代化管理思想和办公手段。它将供应商 和企业内部的</span><mark><span>采购、生产、销售</span></mark><span>以及客户紧密联系起来，可对</span><mark><span>供应链</span></mark><span>上的所有环节进行有效 管理，实现对企业的动态控制和资源的集成和优化，提升基础管理水平，追求资源的合理高 效利用</span></p></li><li><p><mark><span>产品数据管理</span></mark><span>(Product Data Management，PDM)是一门用来管理所有与产品相关信息 (包括零件信息、配置、文档、计算机辅助设计文件、结构、权限信息等)和所有与产品相关过程(包括过程定义和管理)的技术。PDM 系统是一种软件框架，利用这个框架可以帮助企业实现对与企业产品相关的</span><mark><span>数据、开发过程以及使用者进行集成与管理</span></mark><span>，可以实现对设计、制造和生产过程中需要的大量数据进行跟踪和支持。主要功能有：</span></p><ol start='' ><li><span>数据库和文档管理</span></li><li><span>产品结构和配置管理</span></li><li><span>生命周期管理和流程管理</span></li><li><span>集成开发接口</span></li></ol></li><li><p><mark><span>业务流程分析</span></mark><span>的主要方法有</span><mark><span>价值链分析法、客户关系分析法、供应链分析法、基于 ERP 的分析法和业务流程重组</span></mark><span>等。</span></p><ol start='' ><li><mark><span>价值链分析法</span></mark><span>。价值链分析法找出或设计出那些能够使顾客满意，实现顾客价值最大化的业务流程。价值链就是一个创造价值的工作流程，在这一总流程基础上，可把企业具体的活动细分为生产指挥流程、计划决策流程、营销流程、信息搜集与控制流程、资金筹措流程等。其中有些业务流程特别重要，对形成企业核心竞争力起着关键作用，这样的业务流程称为基本业务流程，对应于价值链中的基本活动:其他业务流程是对企业的基本经营活动提供支持和服务，称为辅助业务流程，对应</span>
<span>于价值链中的辅助活动。</span></li><li><mark><span>客户关系分析法</span></mark><span>。客户关系分析法就是把 CRM 用在业务流程的分析上。CRM 的目标是建立真正以客户为导向的组织结构，以最佳的价值定位瞄准最具吸引力的客户，最大化地提高运营效率建立有效的合作伙伴关系。从 CRM 的角度分析业务流程,企业的业务流程应当是以客户与企业的关系以及客户行为为依据的，而不是传统的按照企业内部管理来实施的。</span></li><li><mark><span>供应链分析法</span></mark><span>。供应链分析法是从企业供应链的角度分析企业的业务流程，它源于 SCM。供应链是指用一个整体的网络用来传送产品和服务，从原材料开始一直到最终客户(消费者)，它凭借一个设计好的信息流、物流和资金流来完成。供应链分析法主要从企业内部供应链和外部供应链两个角度来分析企业的业务流程，分析哪些流程处于供应链的核心环节。</span></li><li><mark><span>基于 ERP 的分析法</span></mark><span>。ERP 的基本思想是将企业的业务流程看作是一个紧密联接的供应链，将供应商和企业内部的采购、生产、销售，以及客户紧密联系起来，对供应链上的所有环节进行有效管理，实现对企业的动态控制和各种资源的集成和优化，从而提升企业基础管理水平，追求企业资源的合理、高效利用。</span></li><li><mark><span>业务流程重组</span></mark><span>。通过重新审视企业的价值链，从功能成本的比较分析中，确定企业在哪些环节具有比较优势。在此基础上，以顾客满意为出发点进行价值链的分解与整合，改造原有的业务流程，实现业务流程的最优化。</span></li></ol></li><li><p><mark><span>(集成定义方法IDEF)</span></mark><span> 是一系列建模、分析和仿真方法，从 IDEFO 到 IDEF14(括 DEFX 在内)共 16套方法，每套方法都是通过建模程序来获取某个特定类型的信息。它们分别是 </span><mark><span>IDEF0(功能建模)、IDEF1(信息建模)、IDEF1X (数据建模)</span></mark><span>、IDEF2(仿真建模设计)、IDEF3(过程描述获取)、</span><mark><span>IDEF4(面向对象设计)</span></mark><span>IDEF5(本体论描述获取)、IDEF6(设计原理获取)、IDEF7(信息系统审计)、IDEF8(用户界面建模)、IDEF9(场景驱动信息系统设计)、IDEF10(实施架构建模)，IDEF11(信息制品建模)、IDEF12(组织建模)、IDEF13 (三模式映射设计) 和 IDEF14(网络规划)。</span></p></li></ul><h4><a name="知识管理" class="md-header-anchor"></a><span>知识管理</span></h4><ul><li><p><span>明确知识和信息的区别，</span><mark><span>知识是由信息推导出来的</span></mark><span>，人类智慧和经验的集合</span></p><ul><li><mark><span>显性知识:</span></mark><span>例如文档、资料、视频等能够看得见的知识。</span></li><li><mark><span>隐性知识</span></mark><span>:存在于人脑海中的知识，包括人的记忆与经验技巧，理想抱负等</span></li></ul></li><li><p><span>知识管理应该探寻如何将隐性知识转化为显性知识，达到共享的目的，有如下三种工具可以实现:</span></p><ul><li><mark><span>知识生成工具</span></mark><span>:获取知识的工具，包括知识获取、知识合成、知识创新</span></li><li><mark><span>知识编码工具</span></mark><span>:如何表达知识的工具。</span></li><li><mark><span>知识转移工具</span></mark><span>:知识需要传播，达到共享的目的，传播过程中会遇到困难和差异，包括时间差异、空间差异和社会差异。</span></li></ul></li></ul><h4><a name="企业门户" class="md-header-anchor"></a><span>企业门户</span></h4><ul><li><span>企业网站(单向的): </span><mark><span>注重消息的单向传送展示，缺乏信息互动</span></mark><span>，是企业</span><mark><span>门户</span></mark><span>的雏形。</span></li><li><span>企业信息门户EIP(多了数据资源): 在互联网模式下，将企业的</span><mark><span>各种应用系统、数据资源和互联网资源统一集成</span></mark><span>在企业门户下，</span><mark><span>提供企业的产品和用户的信息</span></mark><span>，达到信息共享，使得企业相关的供应链、客户通过此门户获得所需的信息，快速了解企业文化。</span></li><li><span>企业知识门户EKP(多了知识库，类似教程之类的): 企业网站的基础上</span><mark><span>增加知识性内容</span></mark><span>，企业员工可通过EKP了解今天企业所发生的事情，找到与自己相关的项目资源信息，</span><mark><span>建立了一个企业知识库</span></mark><span>，能够提高企业员工的工作效率。</span></li><li><span>企业应用门户EAP(多了业务流程): </span><mark><span>对企业业务流程的集成，以业务流程和企业应用为核心</span></mark><span>把业务流程中功能不同的应用模块通过门户技术集成在一起，企业员工和合作伙伴可以通过EAP访问相应的应用系统，实现移动办公，企业业务流程包括三要素：</span><mark><span>实体，对象，活动</span></mark></li><li><span>企业通用门户: </span><mark><span>将上述四者有机的融合在一起</span></mark></li></ul><h4><a name="企业应用集成论文考点" class="md-header-anchor"></a><span>企业应用集成(论文考点)</span></h4><ul><li><p><mark><span>企业应用集成EAI</span></mark><span>，可以适用于大多数要实施电子商务的企业，以及企业之间的应用集成。</span></p><ol start='' ><li><p><span>表示集成:即界面集成，是最原始的集成，</span><mark><span>黑盒集成</span></mark><span>。将多个信息系统的界面集成在一起，</span><mark><span>统一入口</span></mark><span>，为用户提供一个看上去统一，但是由多个系统组成的应用系统的集成，例如桌面。</span></p><p><img src="http://qn.qs520.mobi/image-20230214101423028.png" referrerpolicy="no-referrer" alt="image-20230214101423028"><span> </span></p></li><li><p><span>数据集成: </span><mark><span>白盒集成，把不同来源、格式、特点性质的数据在逻辑上或者物理上有机的集中</span></mark><span>，从而为企业提供全面的</span><mark><span>数据共享</span></mark><span>。如数据仓库。</span></p></li><li><p><span>控制集成(功能集成、应用集成)</span><mark><span>黑盒集成</span></mark><span>，</span><mark><span>业务逻辑层次的集成</span></mark><span>，可以借助于远程过程调用或远程方法调用、面向消息的中间件等技术，将多个应用系统功能进行绑定，使之像一个实时运行的系统一样接受信息输入和产生数据输出，实现多个系统功能的叠加。如钉钉。</span></p><p><img src="http://qn.qs520.mobi/image-20230214101530935.png" referrerpolicy="no-referrer" alt="image-20230214101530935"><span> </span></p></li><li><p><span>业务流程集成:即</span><mark><span>过程集成，最彻底的、综合的集成</span></mark><span>，这种集成超越了数据和系统，由一系列基于标准的、统一数据格式的工作流组成。当进行业务流程集成时，企业必须对各种业务信息的交换进行定义、授权和管理，以便于改进操作、减少成本、提高响应速度。</span></p><ul><li><span>它包括应用集成、B2B集成、自动化业务流程管理、人工流程管理、企业门户以及对所有应用系统和流程的管理和监控等</span>
<span>如电子购物网站-第三方支付平台-银行-物流等流程集成</span></li></ul></li></ol></li><li><p><strong><span>应用集成数据交换方式</span></strong></p><ul><li><strong><span>共享数据库</span></strong><span>: 在应用集成时，让</span><mark><span>多个应用系统通过直接共享数据库的方式来进行数据交换</span></mark><span>，实时性强，可以频繁交互，属于同步方式;但是安全性、并发控制、死锁等问题突出。</span></li><li><strong><span>消息传递</span></strong><span>: 消息是软件对象之间进行交互和通信时所使用的一种数据结构可以独立于软件平台而存在，</span><mark><span>适用于数据量小、但要求频繁、立即、可靠、异步地数据交换场合</span></mark><span>。</span></li><li><strong><span>文件传输</span></strong><span>: 是指在进行数据交换时，</span><mark><span>直接将数据文件传送到相应位置</span></mark><span>，让目标系统直接读取数据，</span><mark><span>可以一次性传送大量信息，但不适合频繁进行数据传送</span></mark><span>适用于数据量大、交换频度小、即时性要求低的情况。</span></li></ul></li><li><p><strong><span>企业集成平台</span></strong></p><ul><li><p><span>集成平台是</span><mark><span>支持企业集成的支撑环境</span></mark><span>，包括</span><mark><span>硬件、软件、软件工具和系统</span></mark><span>，通c过集成各种企业应用软件形成</span><mark><span>企业集成系统</span></mark><span>。由于硬件环境和应用软件的多样性，企业信息系统的功能和环境都非常复杂，因此，为了能够较好地满足企业的应用需求，作为企业集成系统支持环境的集成平台，</span><mark><span>其基本功能主要有</span></mark><span>:</span></p><ol start='' ><li><mark><span>通信服务:</span></mark><span> 它提供</span><mark><span>分布环境下透明的同步 /异步通信服务功能</span></mark><span>，使用户和应用程序</span><mark><span>无需关心具体的操作系统和应用程序所处的网络物理位置</span></mark><span>，而以透明的函数调用或对象服务方式完成它们所需的通信服务要求。</span></li><li><mark><span>信息集成服务:</span></mark><span> 它为</span><mark><span>应用提供透明的信息访问服务</span></mark><span>，通过实现</span><mark><span>异种数据库系统之间数据的交换</span></mark><span>、互操作、分布数据管理和共享信息模型定义(或共享信息，数据库的建立)使集成平台上运行的应用、服务或用户端能够</span><mark><span>以一致的语义和接口实现对数据</span></mark><span>(数据库、数据文件、应用交互信息) 的访问与控制。</span></li><li><mark><span>应用集成服务:</span></mark><span> 它通过</span><mark><span>高层应用编程接口来实现对相应应用程序的访问</span></mark><span>，这些高层应用编程接口包含在不同的适配器或代理中，它们被用来连接不同的应用程序。</span></li><li><mark><span>二次开发工具:</span></mark><span> 是集成平台提供的</span><mark><span>一组帮助用户开发特定应用程序(如实现数据转换的适配器或应用 封装服务等)的支持工具</span></mark><span>，其目的是简化用户在企业集成平台实施过程中(特定应用程序接口)的开发工作。</span></li><li><mark><span>平台运行管理工具:</span></mark><span> 它是企业集成平台的</span><mark><span>运行管理和控制模块</span></mark><span>，负责企业集成平台系统的静态和动态配置、集成平台应用运行管理和维护、事件管理和出错管理等。</span></li></ol></li></ul></li><li><p><strong><span>企业信息集成</span></strong><span>分为</span><mark><span>企业内部的信息集成和外部的信息集成</span></mark><span>两个方面</span></p><ol start='' ><li><p><span>按集成内容，企业内部的信息集成一般可分为以下四个方面:</span></p><ul><li><mark><span>技术平台的集成</span></mark><span> 系统底层的</span><mark><span>体系结构、软件、硬件以及异构网络的特殊需求</span></mark><span>首先必须得到集成。</span></li><li><mark><span>数据的集成</span></mark><span>为了完成应用集成和业务流程集成，需要解决</span><mark><span>数据和数据库的集成问题</span></mark><span>。数据集成的目的是</span><mark><span>实现不同系统的数据交流与共享</span></mark><span>，是进行其他更进一步集成的基础。</span></li><li><mark><span>应用系统的集成</span></mark><span>是实现</span><mark><span>不同系统之间的互操作</span></mark><span>，使得不同应用系统之间能够实现数据和方法的共享。它为进一步的过程集成打下了基础。</span></li><li><mark><span>业务过程的集成</span></mark><span> 使得在</span><mark><span>不同应用系统中的流程能够无缝连接</span></mark><span>，实现流程的协调运作和流程信息的充分共享。</span></li></ul></li><li><p><span>企业外部的信息集成主要包括以下两个部分:</span></p><ol start='' ><li><span>通过</span><mark><span>门户网站和互联网</span></mark><span>实现公众、社会团体、社会和客户的互动，实现企业内外部信息资源的有效交流和集成:</span></li><li><span>通过</span><mark><span>与合作伙伴信息系统的对接</span></mark><span>，建立动态的企业联盟，发展基于竞争合作机制的虚拟企业，重塑企业的战略模式和竞争优势。</span></li></ol></li></ol></li></ul><h4><a name="电子商务" class="md-header-anchor"></a><span>电子商务</span></h4><ul><li><p><span>电子商务分三个方面:电子商情广告、电子选购和交易，电子交易凭证的交换、电子支付与结算;网上售后服务等</span></p></li><li><p><span>参与电子商务的实体有四类:顾客 (个人消费者或集团购买)、商户(包括销售商、制造商和储运商)、银行(包括发卡行和收单行) 及</span><mark><span>认证中心。</span></mark></p></li><li><p><span>按照交易对象，电子商务模式包括</span></p><ul><li><span>B2B模式，企业对企业。</span></li><li><span>B2C模式，企业对消费者</span></li><li><span>C2C，消费者对消费者。</span></li><li><span>O2O即Online To Offline，含义是线上购买线下的商品和服务，实体店提货或享受服务。</span></li></ul></li><li><p><span>电子商务的基础设施包括: 网络基础设施、多媒体内容和网络出版的基础设施、报文和信息传播的基础设施、商业服务的基础设施。此外，技术标准，政策、法律等是电子商务系统的重要保障和应用环境。</span></p></li></ul><h2><a name="span-id10软件工程10软件工程span" class="md-header-anchor"></a><span id="10.软件工程"><span>10.软件工程</span></span></h2><h4><a name="信息系统生命周期" class="md-header-anchor"></a><span>信息系统生命周期</span></h4><ul><li><p><strong><span>软件工程基本原理</span></strong><span>: 用分阶段的生命周期计划严格管理、坚持进行阶段评审、实现严格的产品控制采用现代程序设计技术、结果应能清楚的审查、开发小组的人员应少而精、承认不断改进软件工程实践的必要性。</span></p></li><li><p><span>软件工程的基本要素: </span><mark><span>方法、工具、过程</span></mark></p></li><li><p><strong><span>软件生存周期</span></strong><span>: 可行性分析与项目开发计划、需求分析、概要设计(选择系统解决方案，规划子系统)、详细设计(设计子系统内部具体实现) 、编测试、维护。</span></p><p><img src="http://qn.qs520.mobi/image-20230215110701749.png" referrerpolicy="no-referrer" alt="image-20230215110701749"><span> </span></p></li></ul><ol start='' ><li><mark><span>系统规划阶段</span></mark><span>: 任务是对组织的环境、目标及现行系统的状况进行</span><mark><span>初步调查</span></mark><span>，根据组织目标和发展战略确定信息系统的发展战略，对</span><mark><span>建设新系统的需求做出分析和预测</span></mark><span>，同时考虑建设新系统所受的各种约束，研究建设新系统的必要性和可能性。根据需要与可能，给出制建系统的备选方案。输出: </span><mark><span>可行性研究报告、系统设计任务书。</span></mark></li><li><mark><span>系统分析阶段</span></mark><span>: 任务是根据系统设计任务书所确定的范围，对</span><mark><span>现行系统进行详细调查</span></mark><span>，描述现行系统的业务流程，指出现行系统的局限性和不足之处，确定新系统的基本目标和逻辑功能要求，即</span><mark><span>提出新系统的逻辑模型</span></mark><span>。系统分析阶段又称为</span><mark><span>逻辑设计阶段</span></mark><span>。这个阶段是</span><mark><span>整个系统建设的关键阶段，也是信息系统建设与一般工程项目的重要区别所在。输出: 系统说明书</span></mark><span>。</span></li><li><mark><span>系统设计阶段</span></mark><span>: 系统分析阶段的任务是回答系统“做什么”的问题，而</span><mark><span>系统设计阶段要回答的问题是“怎么做”</span></mark><span>。该阶段的任务是根据系统说明书中规定的功能要求，</span><mark><span>具体设计实现逻辑模型的技术方案</span></mark><span>，也就是</span><mark><span>设计新系统的物理模型</span></mark><span>。这个阶段又称为</span><mark><span>物理设计阶段</span></mark><span>，可分为</span><mark><span>总体设计(概要设计》和详细设计</span></mark><span>两个子阶段。输出: </span><mark><span>系统设计说明书(概要设计、详细设计说明书)</span></mark></li><li><mark><span>系统实施阶段</span></mark><span>: 是将</span><mark><span>设计的系统付诸实施的阶段</span></mark><span>。这一阶段的任务包括计算机等设备的购置、安装和调试程序的编写和调试、人员培训、数据文件转换、系统调试与转换等。这个阶段的特点是几个互相联系、互相制约的任务同时展开，必须精心安排、合理组织。系统实施是按实施计划分阶段完成的，每个阶段应写出实施进展报告。系统测试之后写出系统测试分析报告。输出:</span><mark><span>实施进展报告、系统测试分析报告。</span></mark></li><li><mark><span>系统运行和维护阶段</span></mark><span>: 系统投入运行后，需要经常进行维护和评价，记录系统运行的情况，根据一定的规则对系统进行必要的修改，评价系统的工作质量和经济效益。</span></li></ol><h4><a name="能力成熟度模型" class="md-header-anchor"></a><span>能力成熟度模型</span></h4><ul><li><p><strong><span>能力成熟度模型CMM</span></strong></p><p><img src="http://qn.qs520.mobi/image-20230215112315092.png" referrerpolicy="no-referrer" alt="image-20230215112315092"><span> </span></p></li><li><p><strong><span>能力成熟度模型集成CMMI</span></strong></p></li><li><p><span>是</span><mark><span>若干过程模型的综合和改进</span></mark><span>，不仅仅软件，而是支持多个工程学科和领域的系统的、一致的过程改进框架，能适应现代工程的特点和需要，能提高过程的质量和工作效率。</span></p></li><li><p><span>CMMI两种表示方法: </span></p><ol start='' ><li><p><mark><span>阶段式模型</span></mark><span>：类似于CMM，它</span><mark><span>关注组织的成熟度</span></mark><span>，五个成熟度模型如下：</span></p><p><img src="http://qn.qs520.mobi/image-20230215112731869.png" referrerpolicy="no-referrer" alt="image-20230215112731869"><span> </span></p></li><li><p><mark><span>连续式模型</span></mark><span>: 关注每个过程域的能力，一个组织对不同的过程域可以达到不同的过程域能力等级</span></p></li></ol></li></ul><h4><a name="软件过程模型" class="md-header-anchor"></a><span>软件过程模型</span></h4><ul><li><p><strong><span>瀑布模型(SDLC)</span></strong><span>: 瀑布模型是一个经典的软件生命周期模型一般将软件开发分为:</span><mark><span>可行性分析(计划)、需求分析、软件设计 (概要设计、详细设计)、编码(含单元测试)、测试、运行维护</span></mark><span>等几个阶段。</span></p></li><li><p><span>瀑布模型特点</span></p><ol start='' ><li><span>从</span><mark><span>上一项开发活动接受该项活动的工作对象作为输入</span></mark></li><li><span>利用这一输入，</span><mark><span>实施该项活动应完成的工作内容。</span></mark></li><li><span>给出该项活动的</span><mark><span>工作成果，作为输出</span></mark><span>传给下一项开发活动。</span></li><li><span>对</span><mark><span>该项活动的实施工作成果进行评审</span></mark><span>。若其工作成果得到确认，则继续进行下一项开发活动;否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件</span></li></ol><p><img src="http://qn.qs520.mobi/image-20230215114754956.png" referrerpolicy="no-referrer" alt="image-20230215114754956"><span> </span></p></li><li><p><strong><span>RAD模型：</span></strong><span>快速应用开发（Rapid Application Development,RAD）模型是一个增量型的软件开发过程模型，强调极短的开发周期。RAD模型是</span><mark><span>瀑布模型的一个“高速”变种</span></mark><span>，通过大量使用</span><mark><span>可复用构件</span></mark><span>，采用</span><strong><span>基于构件</span></strong><span>的建造方法赢得快速开发。如果需求理解得好且约束了项目的范围，利用这种模型可以很快地创建出功能完善的“信息系统“ 。其流程从业务建模开始，随后是数据建模、过程建模、应用生成、测试及反复。RAD只能</span><mark><span>用于信息系统开发，不适合技术风险很高</span></mark><span>的情况。</span></p></li><li><p><strong><span>螺旋模型</span></strong><span>是一个</span><mark><span>演化软件过程模型</span></mark><span>，将</span><mark><span>原型实现的迭代特征与线性顺序(瀑布) 模型中控制的和系统化的方面结合</span></mark><span>起来。在螺旋模型中，</span><mark><span>软件开发是一系列的增量发布。</span></mark></p></li><li><p><span>开发过程具有</span><mark><span>周期性重复的螺旋线状</span></mark><span>。四个象限分别标志每个周期所划分的四阶段: </span><mark><span>制订计划、风险分析、实施工程和客户评估</span></mark><span>。螺旋模型强调了</span><mark><span>风险分析</span></mark><span>，特别</span><mark><span>适用于庞大而复杂的、高风险的系统</span></mark><span>。</span></p><p><img src="http://qn.qs520.mobi/image-20230215114949809.png" referrerpolicy="no-referrer" alt="image-20230215114949809"><span> </span></p></li><li><p><strong><span>V模型</span></strong><span>从整体上看起来，就是一个V字型的结构，由左右两边组成。左边的下画线分别代表了需求分析、概要设计、详细设计、编码。右边的上画线代表了单元测试、集成测试、系统测试与验收测试。V模型的特点如下:</span></p><ol start='' ><li><mark><span>单元测试</span></mark><span>的主要目的是针对</span><mark><span>编码过程中</span></mark><span>可能存在的各种错误; (单编，单元测试-编码过程。下同)                                      </span></li><li><mark><span>集成测试</span></mark><span>的主要目的是针对</span><mark><span>详细设计中</span></mark><span>可能存在的问题( 集详)                                               </span></li><li><mark><span>系统测试</span></mark><span>主要针对</span><mark><span>概要设计</span></mark><span>，检查系统作为一个整体是否有效地得到运行;(系概)     </span></li><li><mark><span>验收测试</span></mark><span>通常由业务专家或者用户进行，以确认产品能真正符合用户业务上的需要。(验需)     </span></li><li><span>V模型用于</span><mark><span>需求明确和需求变更不频繁</span></mark><span>的情形。</span></li></ol><p><img src="http://qn.qs520.mobi/image-20230215115159903.png" referrerpolicy="no-referrer" alt="image-20230215115159903"><span> </span></p></li><li><p><strong><span>原型化模型</span></strong><mark><span>第一步就是创建一个快速原型</span></mark><span>，能够满足项目干系人与未来的用户可以与原型进行交互，再通过与相关干系人进行充分的讨论和分析，</span><mark><span>最终弄清楚当前系统的需求</span></mark><span>，进行了充分的了解之后，在原型的基础上开发出用户满意的产品。</span></p></li><li><p><span>原型法认为在很难一下子全面准确地提出用户需求的情况下，原型应当具备的特点如下:</span></p><ol start='' ><li><mark><span>实际可行</span></mark></li><li><span>具有</span><mark><span>最终系统的基本特征</span></mark></li><li><mark><span>构造方便、快速，造价低</span></mark><span>。原型法的特点在于原型法对用户的需求是</span><mark><span>动态响应、逐步纳入</span></mark><span>的</span></li></ol></li><li><p><strong><span>增量模型</span></strong><span>: 首先开发</span><mark><span>核心模块功能</span></mark><span>，而后与用户确认，之后再开发次核心模块的功能，即每次开发一部分功能，并与用户需求确认，最终完成项目开发，</span><mark><span>优先级最高的服务最先交付</span></mark><span>。</span></p></li><li><p><span>特点: 但由于并不是从系统整体角度规划各个模块，因此</span><mark><span>不利于模块划分</span></mark><span>难点在于</span><mark><span>如何将客户需求划分为多个增量</span></mark><span>。与原型不用的是</span><mark><span>增量模型的每一次增量版本都可作为独立可操作的作品</span></mark><span>，而</span><mark><span>原型的构造一般是为了演示</span></mark><span>。</span></p><p><img src="http://qn.qs520.mobi/image-20230215115437157.png" referrerpolicy="no-referrer" alt="image-20230215115437157"><span> </span></p></li><li><p><strong><span>喷泉模型</span></strong><span>: 是一种以</span><mark><span>用户需求为动力，以对象作为驱动</span></mark><span>的模型，适合于</span><mark><span>面向对象</span></mark><span>的开发方法。使开发过程具有</span><mark><span>迭代性和无间隙性</span></mark><span>。</span></p></li><li><p><strong><span>基于构件的开发模型CBSD</span></strong><span>: 利用</span><mark><span>预先包装的构件来构造应用系统</span></mark><span>。构件可以是组织内部开发的构件，也可以是商品化成品软件构件特点是</span><mark><span>增强了复用性</span></mark><span>，在系统开发过程中，会构建一个构件库，供其他系统复用，因此可以提高可靠性，节省时间和成本。</span></p></li><li><p><strong><span>形式化方法模型</span></strong><span>: 建立在</span><mark><span>严格数学基础</span></mark><span>上的一种软件开发方法，主要活动是生成计算机软件形式化的数学规格说明。</span></p></li></ul><h4><a name="信息系统开发方法" class="md-header-anchor"></a><span>信息系统开发方法</span></h4><ul><li><p><span>结构是指系统内各个组成要素之间的相互联系、相互作用的框架</span></p></li><li><p><strong><span>结构化方法</span></strong></p><ul><li><p><strong><span>结构化方法也称为生命周期法</span></strong><span>，是一种传统的信息系统开发方法，由</span><mark><span>结构化分析 (Structured Analysis,SA)、结构化设计 (Structured Design.SD)和结构化程序设计 (Structured Programming，SP)</span></mark><span> 三部分有机组合而成，其精髓是</span><mark><span>自顶向下、逐步求精和模块化</span></mark><span>设计。</span></p><ul><li><span>SA对应生命周期里的系统</span><mark><span>分析</span></mark><span>阶段</span></li><li><span>SD对应生命周期里的系统</span><mark><span>设计</span></mark><span>阶段</span></li><li><span>SP对应生命周期里的系统</span><mark><span>实施</span></mark><span>阶段</span></li></ul></li><li><p><span>结构化方法的开发过程一般是先把系统功能视作一个大的模块，再根据系统分析与设计的要求对其进行进一步的模块分解或组合。</span><mark><span>OMT 方法使用了建模的思想</span></mark><span>，讨论如何建立一个实际的应用模型，包括</span><mark><span>对象模型、动态模型和功能模型</span></mark><span>。简单地说，功能模型指出发生了什么，动态模型确定什么时候发生，而对象模型确定发生的客体。</span></p><ul><li><mark><span>对象模型</span></mark><span>描述系统中对象的静态结构、对象之间的挂心、属性和操作，主要用</span><mark><span>对象图来实现:</span></mark></li><li><mark><span>动态模型</span></mark><span>描述与时间和操作顺序有关的系统特征，例如，激发事件、事件序列、确定事件先后关系的状态等，主要用</span><mark><span>状态图</span></mark><span>来实现动态模型，</span></li><li><mark><span>功能模型</span></mark><span>描述一个计算如何从输入值得到输出值，它不考虑计算的次序主要用</span><mark><span>DFD 来实现</span></mark><span>功能模型。</span></li></ul></li><li><p><span>结构化方法的主要特点</span></p><ol start='' ><li><mark><span>开发目标清晰化</span></mark><span>。结构化方法的系统开发遵循“</span><mark><span>用户第一</span></mark><span>”的原则。</span></li><li><mark><span>开发工作阶段化</span></mark><span>。每个阶段工作完成后，</span><mark><span>要根据阶段工作目标和要求进行审查</span></mark><span>，这使各阶段工作有条不紊地进行，便于项目管理与控制。</span></li><li><mark><span>开发文档规范化</span></mark><span>。结构化方法每个阶段工作完成后，</span><mark><span>要按照要求完成相应的文档</span></mark><span>，以保证各个工作阶段的街接与系统维护工作的遍历。</span></li><li><mark><span>设计方法结构化</span></mark><span>。在</span><mark><span>系统分析与设计</span></mark><span>时，从整体和全局考虑，</span><mark><span>自顶向下地分解</span></mark><span>，在</span><mark><span>系统实现时</span></mark><span>，根据设计的要求，先编写各个具体的功能模块，然后</span><mark><span>自底向上逐步实现整个系统</span></mark></li></ol></li><li><p><span>结构化方法的不足和局限</span></p><ol start='' ><li><mark><span>开发周期长</span></mark><span>:按顺序经历各个阶段，直到实施阶段结束后，用户才能使用系统。</span></li><li><mark><span>难以适应需求变化</span></mark><span>:不适用于需求不明确或经常变更的项目。</span></li><li><mark><span>很少考虑数据结构</span></mark><span>:结构化方法是一种面向过程，面向数据流的开发方法，很少考虑数据结构。</span></li></ol></li><li><p><span>结构化方法常用工具</span></p><ul><li><span>结构化方法一般利用图形表达用户需求，常用工具有</span><mark><span>数据流图、数据字典、结构化语言、判定表以及判定树</span></mark><span>等</span></li></ul></li></ul></li><li><p><strong><span>面向对象方法</span></strong></p><ul><li><p><strong><span>面向对象 (Object-oriented，oo)</span></strong><span>方法认为，客观世界是由各种对象组成的，</span><mark><span>任何事物都是对象，每一个对象都有自己的运动规律和内部状态，都属于某个对象类</span></mark><span>，是该对象类的一个元素。复杂的对象可由相对简单的各种对象以某种方式而构成，不同对象的组合及相互作用就构成了系统。</span></p></li><li><p><span>面向对象方法的特点</span></p><ol start='' ><li><span>使用oo方法构造的系统具有</span><mark><span>更好的复用性</span></mark><span>，其关键在于建立一个全面合理、统一的模型(</span><mark><span>用例模型和分析模型</span></mark><span>)</span></li><li><span>oo方法也划分阶段，但其中的系统分析、系统设计和系统实现三个阶段之间已经</span><mark><span>没有“缝隙”</span></mark><span>。也就是说，这三个阶段的界限变得不明确，某项工作既可以在前一个阶段完成，也可以在后一个阶段完成;前一个阶段工作做得不够细，在后一个阶段可以补充。</span></li><li><span>面向对象方法可以</span><mark><span>普遍适用于各类信息系统的开发</span></mark></li></ol></li><li><p><span>面向对象方法的不足之处</span></p><ul><li><mark><span>必须依靠一定的面向对象技术支持，在大型项目的开发上具有一定的局限性，不能涉足系统分析以前的开发环节</span></mark></li></ul></li><li><p><span>当前，一些大型信息系统的开发，通常是将</span><mark><span>结构化方法和oo方法结合起来</span></mark><span>,首先，使用结构化方法进行自顶向下的整体划分;然后，自底向上地采用00方法进行开发。因此，结构化方法和00方法仍是两种在系统开发领域中相互依存的、不可替代的方法</span></p></li></ul></li><li><h5><a name="面向服务方法" class="md-header-anchor"></a><span>面向服务方法</span></h5><ul><li><span>SO 方法有三个主要的抽象级别，分别是</span><mark><span>操作、服务和业务流程</span></mark><span>。位于最低层的</span><strong><span>操作代表单个逻辑单元的事物</span></strong><span>，执行操作通常会导致读、写或修改一个或多个持久性数据。</span><strong><span>服务的操作类似于对象的方法</span></strong><span>,它们都有特定的结构化接口,并且返回结构化的响应;位于第二层的服务代表操作的逻辑分组;最高层的</span><strong><span>业务流程则是为了实现特定业务目标而执行的一组长期运行的动作或活动</span></strong><span>，包括依据一组业务规则按照有序序列执行的一系列操作。其中操作的排序、选择和执行成为服务或流程的编排，典型的情况是调用已编排的服务来响应业务事件。</span></li></ul></li><li><p><strong><span>原型化方法</span></strong></p><ul><li><p><span>原型化方法也称为</span><mark><span>快速原型法，或者简称为原型法</span></mark><span>。它是一种根据用户初步需求，利用系统开发工具，</span><mark><span>快速地建立一个系统模型展示给用户</span></mark><span>，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。</span></p></li><li><p><span>按</span><mark><span>是否实现功能</span></mark><span>分类: 分为水平原型(行为原型，功能的导航)、垂直原型(结构化原型，实现了部分功能)。</span></p></li><li><p><span>按</span><mark><span>最终结果</span></mark><span>分类: 分为抛弃式原型、演化式原型</span></p><ul><li><span>抛弃式原型基本思路就是开始就做一个简单的界面设计，用来让用户有直观感受，从而可以提得出需求，等需求获取到之后，可以把这个界面原型抛弃不用。而演化式，会把原型保留，通过不断的演化，逐步形成最终产品。</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230215150908417.png" referrerpolicy="no-referrer" alt="image-20230215150908417"><span> </span></p></li><li><p><span>原型法的特点</span></p><ul><li><span>原型法可以使系统</span><mark><span>开发的周期缩短、成本和风险降低、速度加快，获得较高的综合开发效益</span></mark><span>。</span></li><li><span>原型法是以</span><mark><span>用户为中心</span></mark><span>来开发系统的，用户参与的程度大大提高，开发的系统符合用户的需求，因而增加了用户的满意度，提高了系统开发的成功率。由于用户参与了系统开发的全过程，</span><mark><span>对系统的功能和结构容易理解和接受</span></mark><span>，有利于系统的移交，有利于系统的运行与维护</span></li></ul></li><li><p><span>原型法的不足之处</span></p><ul><li><mark><span>开发的环境要求高。管理水平要求高</span></mark></li></ul></li><li><p><span>由以上的分析可以看出，原型法的优点</span><mark><span>主要在于能更有效地确认用户需求</span></mark><span>。从直观上来看，原型法</span><mark><span>适用于那些需求不明确的系统开发</span></mark><span>。事实上，</span><mark><span>对于分析层面难度大、技术层面难度不大的系统，适合于原型法开发</span></mark><span>。从严格意义上来说，目前的原型法</span><mark><span>不是一种独立的系统开发方法，而只是一种开发思想</span></mark><span>，它只支持在系统开发早期阶段快速生成系统的原型，没有规定在原型构建过程中必须使用哪种方法。因此，</span><mark><span>它不是完整意义上的方法论体系。这就注定了原型法必须与其他信息系统开发方法结合使用</span></mark></p></li></ul></li><li><p><strong><span>敏捷开发</span></strong></p><ul><li><p><span>敏捷开发是一种</span><mark><span>以人为核心、迭代、循序渐进的开发方法</span></mark><span>，相对于传统软件开发方法的“非敏捷”，更</span><mark><span>强调程序员团队与业务专家之间的紧密协作、面对面的沟通 (认为比书面的文档更有效) 、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用</span></mark><span>。</span></p></li><li><p><span>敏捷软件开发宣言:</span></p><ol start='' ><li><span>个体和交互胜过过程和工具</span></li><li><span>可以工作的软件胜过面面俱到的文档</span></li><li><span>客户合作胜过合同谈判</span></li><li><span>响应变化胜过遵循计划</span></li></ol><p><img src="http://qn.qs520.mobi/image-20230215151407328.png" referrerpolicy="no-referrer" alt="image-20230215151407328"><span> </span></p></li><li><p><strong><span>结对编程</span></strong><span>: </span><mark><span>一个程序员开发，另一个程序在一旁观察审查代码</span></mark><span>，能够有效的提高代码质量，在开发同时对代码进行初步审查，共同对代码负责。</span></p></li><li><p><strong><span>自适应开发</span></strong><span>:强调开发方法的</span><mark><span>适应性 (Adaptive)</span></mark><span> 。不象其他方法那样有很多具体的实践做法，它更侧重为软件的重要性提供最根本的基础，并从更高的组织和管理层次来阐述开发方法为什么要具备适应性。</span></p></li><li><p><strong><span>水晶方法</span></strong><span>: </span><mark><span>每一个不同的项目都需要一套不同的策略、约定和方法论</span></mark><span>，</span></p></li><li><p><strong><span>特性驱动开发</span></strong><span>: 是</span><mark><span>一套针对中小型软件开发项目的开发模式</span></mark><span>。是</span><mark><span>一个模型驱动的快速迭代开发过程</span></mark><span>，它强调的是简化、实用、易于被开发团队接受，适用于</span><mark><span>需求经常变动</span></mark><span>的项目。</span></p></li><li><p><strong><span>极限编程XP</span></strong><span>:核心是</span><mark><span>沟通、简明、反馈和勇气</span></mark><span>。因为知道计划永远赶不上变化，XP</span><mark><span>无需开发人员在软件开始初期做出很多的文档</span></mark><span>。</span><mark><span>XP提倡测试先行</span></mark><span>，为了将以后出现bug的几率降到最低。</span></p></li><li><p><strong><span>并列争球法SCRUM</span></strong><span>:是一种</span><mark><span>迭代的增量化过程</span></mark><span>，把</span><mark><span>每段时间 (30天) 一次的迭代称为一个“冲刺”</span></mark><span>，并按需求的优先级别来实现产品，多个自组织和自治的小组并行地递增实现产品。</span></p></li></ul></li><li><p><strong><span>统一过程(RUP)</span></strong></p><ul><li><p><span>提供了在开发组织中</span><mark><span>分派任务和责任的纪律化方法</span></mark><span>。它的目标是</span><mark><span>在可预见的日程和预算前提下，确保满足最终用户需求的高质量产品。</span></mark></p></li><li><p><span>3个显著特点: </span><mark><span>用例驱动、以架构为中心、迭代和增量</span></mark></p></li><li><p><span>4个流程: </span><mark><span>初始阶段、细化阶段、构建阶段和交付阶段</span></mark><span>。每个阶段结束时都要安排一次技术评审，以确定这个阶段的目标是否已经达到。</span></p><ul><li><span>初始阶段的任务是为</span><mark><span>系统建立业务模型并确定项目的边界</span></mark><span>。在初始阶段，必须识别所有与系统交互的外部实体，定义系统与外部实体交互的特性。在这个阶段中，所关注的是整个项目的业务和需求方面的主要风险。</span></li><li><span>细化阶段的任务是</span><mark><span>分析问题领域，建立完善的架构，淘汰项目中最高风险的元素</span></mark><span>。在细化阶段，必须在理解整个系统的基础上，对架构做出决策，包括其范围、主要功能和诸如性能等非功能需求，同时为项目建立支持环境。</span></li><li><span>构建阶段，</span><mark><span>要开发所有剩余的构件和应用程序功能，把这些构件集成为产品，并进行详细测试</span></mark><span>。从某种意义上说，构建阶段是一个制造过程，其重点放在管理资源及控制操作，以优化成本、进度和质量。构建阶段的主要任务是通过优化资源和避免不必要的报废和返工，使开发成本降到最低;完成所有所需功能的分析、开发和测试，快速完成可用的版本;确定软件、场地和用户是否已经为部署软件作好准备。当基线已经足够完善，可以安装到最终用户实际环境中时，</span></li><li><span>交付阶段。</span><mark><span>交付阶段的重点是确保软件对最终用户是可用的</span></mark><span>。交付阶段的主要任务是进行B 测试，制作产品发布版本;对最终用户支持文档定稿;按用户的需求确认新系统:培训用户和维护人员;获得用户对当前版本的反馈，基于反馈调整产品，例如，进行调试、性能或可用性的增强</span></li></ul></li><li><p><span>适用: 一个</span><mark><span>通用过程框架</span></mark><span>，可以用于种类广泛的软件系统、不同的应用领域不同的组织类型、不同性能水平和不同的项目规模。</span></p></li></ul></li></ul><h4><a name="软件产品线考点" class="md-header-anchor"></a><span>软件产品线(考点)</span></h4><ul><li><p><span>软件产品线是一个</span><mark><span>产品集合</span></mark><span>，这些产品</span><mark><span>共享一个公共的、可管理的特征集，这个特征集能满足特定领域的特定需求</span></mark><span>。软件产品线是一个十分适合专业的开发组织的软件开发方法，能有效地提高软件生产率和质量，缩短开发时间，降低总开发成本。</span></p><ul><li><mark><span>核心资源</span></mark><span>: 包括所有产品所</span><mark><span>共用的软件架构，通用的构件、文档</span></mark><span>等</span></li><li><mark><span>产品集合</span></mark><span>: 产品线中的各种产品。 </span></li></ul></li><li><p><span>产品线的建立方式</span></p><p><img src="http://qn.qs520.mobi/image-20230215153037825.png" referrerpolicy="no-referrer" alt="image-20230215153037825"><span> </span></p></li></ul><h4><a name="逆向工程" class="md-header-anchor"></a><span>逆向工程</span></h4><ul><li><p><strong><span>软件复用(考点)</span></strong><mark><span>是将已有软件的各种有关知识用于建立新的软件，以缩减软件开发和维护的花费</span></mark><span>。软件复用是提高软件生产力和质量的一种重要技术。早期的软件复用主要是</span><mark><span>代码级复用</span></mark><span>，被复用的知识专指程序，后来扩大到</span><mark><span>包括领域知识、开发经验、设计决定、体系结构、需求、设计、代码和文档等一切有关方面</span></mark><span>。</span></p></li><li><p><strong><span>逆向工程(考点)</span></strong><span>: 软件的逆向工程是</span><strong><span>分析程序</span></strong><span>，</span><mark><span>力图在比源代码更高抽象层次上建立程序的表示过程</span></mark><span>，逆向工程</span><mark><span>是设计的恢复过程</span></mark><span>。逆向工程的四个级别:</span></p><ul><li><mark><span>实现级</span></mark><span>:包括程序的抽象语法树、符号表、过程的设计表示。</span><mark><span>过程的设计模型</span></mark></li><li><mark><span>结构级</span></mark><span>:包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、</span><mark><span>程序和数据结构信息</span></mark><span>。  </span></li><li><mark><span>功能级</span></mark><span>:包括反映程序段功能及程序段之间关系的信息，例如</span><mark><span>对象模型、数据和控制流模型</span></mark></li><li><mark><span>领域级</span></mark><span>:包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息例如</span><mark><span>UML, 状态图和部署图</span></mark></li></ul></li><li><p><span>其中，</span><mark><span>领域级抽象级别最高，完备性最低，:实现级抽象级别最低，完备性最高</span></mark></p></li><li><p><span>与逆向工程相关的概念有</span><mark><span>重构、设计恢复、再工程和正向工程</span></mark></p><ol start='' ><li><span>重构是指在</span><mark><span>同一抽象级别上转换系统描述形式</span></mark></li><li><span>设计恢复是指借助工具</span><mark><span>从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面的信息。</span></mark></li><li><span>再工程是指在</span><mark><span>逆向工程所获得信息的基础上，修改或重构已有的系统，产生系统的一个新版本</span></mark><span>。再工程是</span><mark><span>对现有系统的重新开发过程，包括逆向工程、新需求的考虑过程和正向工程三个步骤</span></mark><span>。它不仅能从已存在的程序中重新获得设计信息，而且还能使用这些信息来重构现有系统，以改进它的综合质量。在利用再工程重构现有系统的同时，一般会增加新的需求，包括增加新的功能和改善系统的性能。</span></li><li><span>正向工程是指不仅从现有系统中恢复设计信息，</span><mark><span>而且使用该信息去改变或重构现有系统</span></mark><span>，以改善其整体质量。</span></li></ol></li><li><p><mark><span>逆向工程恢复信息的方法</span></mark></p><ul><li><figure><table><thead><tr><th><span>方法</span></th><th><span>导出信息</span></th></tr></thead><tbody><tr><td><span>用户指导下的搜索与变换方法</span></td><td><span>实现级，结构级</span></td></tr><tr><td><span>变换式方法</span></td><td><span>实现级，结构级，功能级</span></td></tr><tr><td><span>基于领域知识</span></td><td><span>功能级，领域级</span></td></tr><tr><td><span>铅板恢复法</span></td><td><span>实现级，结构级</span></td></tr></tbody></table></figure><p>&nbsp;</p></li></ul></li><li><p><strong><span>软件系统工具</span></strong><span>通常可以按软件过程活动将软件工具分为</span><mark><span>软件开发工具、软件维护工具、软件管理和软件支持工具</span></mark><span>。</span></p><ul><li><mark><span>软件开发工具</span></mark><span>: 需求分析工具、设计工具、编码与排错工具。</span></li><li><mark><span>软件维护工具</span></mark><span>: 版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具。</span></li><li><mark><span>软件管理和软件支持工具</span></mark><span>: 项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</span></li></ul></li></ul><h2><a name="span-id11系统规划11系统规划span案例分析考点1" class="md-header-anchor"></a><span id="11.系统规划"><span>11.系统规划</span></span><span>(案例分析考点1)</span></h2><h4><a name="系统规划步骤" class="md-header-anchor"></a><span>系统规划步骤</span></h4><ul><li><mark><span>(1)对现有系统进行初步调查</span></mark><span>。根据企业战略和发展目标，从类似企业和本企业内部收集各种信息，站在管理层的高度观察企业的现状，分析现有系统的运行状况。</span></li><li><mark><span>(2)分析和确定系统目标</span></mark><span>。系统目标应包括服务的质量和范围、政策、组织和人员等，它不仅包括信息系统的目标，还要反映整个企业的目标。</span></li><li><mark><span>(3)分析子系统的组成和基本功能</span></mark><span>。自顶向下对系统进行划分，并且详细说明各个子系统应该实现的功能。</span></li><li><mark><span>(4)拟定系统的实施方案(主要工作)</span></mark><span>。可以对子系统的优先级进行设定，以便确定子系统的开发顺序。</span></li><li><mark><span>(5)进行系统的可行性研究</span></mark><span>，编写可行性研究报告，召开可行性论证会</span></li><li><mark><span>(6)制订系统建设方案</span></mark><span>。对可行性研究报告中提出的各项技术指标进行分析比较，落实各项假设的前提条件，制订系统建设方案，并根据该方案及其实施计划编写成系统设计任务书。系统设计任务书经上级主管部门批准后，正式作为系统建设的依据</span></li></ul><h4><a name="项目机会选择" class="md-header-anchor"></a><span>项目机会选择</span></h4><ul><li><p><mark><span>(1)项目的立项目标和动机。</span></mark><span>1. 进行基础研究，2. 进行应用开发; 3. 提供技术服务  4. 产品的使用者。</span></p></li><li><p><mark><span>(2)项目立项的价值判断</span></mark></p></li><li><p><mark><span>(3)项目的选择和确定</span></mark><span>。1. 选择有核心价值的项目; 2. 评估所选择的项目; 3. 项目优先级排序; 4. 评估项目的多种实施方式，5. 平衡地选择合适的方案。</span></p></li><li><p><span>(4)</span><mark><span>初步调查</span></mark></p><ul><li><span>目标:掌握用户的概况，从整体上</span><mark><span>了解企业信息</span></mark><span>系统建设的现状，对用户提出的各种问题和初始需求进行识别</span><mark><span>(确认用户需求)</span></mark><span>，明确系统的初步目标，为可行性研究提供工作基础。</span></li><li><span>方式: </span><strong><span>最佳方式是与企业高层管理人员座谈</span></strong><span>，通过座谈了解企业高层对信息系统所设定的目标和系统边界，计划的资金投入和对工期的要求。</span></li><li><span>内容:初步需求分析，企业基本状况，管理方式和基础数据管理状况，现有系统状况。</span></li></ul></li><li><p><mark><span>(5)可行性分析</span></mark></p></li></ul><h4><a name="可行性分析考点" class="md-header-anchor"></a><span>可行性分析(考点)</span></h4><ul><li><p><span>可行性是指在企业当前的条件下，是否有必要建设新系统，以及建设新系统的工作是否具备必要的条件。也就是说，</span><mark><span>可行性包括必要性和可能性(是不是一定要做这个项目和有没有可能做这个项目)</span></mark><span>，可行性研究的步骤如下：</span></p><ol start='' ><li><span>复查系统目标和规模</span></li><li><span>分析现有系统</span></li><li><span>导出新系统的高层逻辑模型</span></li><li><span>用户复核</span></li><li><span>提出并评价解决方案</span></li><li><span>确定最终推荐的解决方案</span></li><li><span>草拟开发计划“</span></li><li><span>编制和提交可行性分析报告</span></li></ol></li><li><p><span>在信息系统建设项目中，可行性研究通常从</span><mark><span>经济可行性、技术可行性、法律可行性和用户使用可行性(考点)</span></mark><span>四个方面来进行分析，其中</span><mark><span>经济可行性通常被认为是项目的底线</span></mark></p><ul><li><p><strong><span>经济可行性</span></strong><span>: 也称为</span><mark><span>投资收益分析或成本效益分析</span></mark><span>，主要评估项目的</span><mark><span>建设成本运行成本和项目建成后可能的经济收益</span></mark><span>。</span></p><ul><li><span>要注意的是，在系统开发初期，由于用户需求和候选系统方案还没有确定，成本不可能得到准确的估算。因此，</span><mark><span>此时的经济可行性分析只能大致估算系统的成本和收益，判断信息系统的建设是否值得</span></mark></li></ul></li><li><p><strong><span>技术可行性</span></strong><span>:也称为技术风险分析，研究的对象是信息系统需要实现的功能和性能，以及技术能力约束。技术可行性主要通过考虑以下问题来进行论证:</span></p><ul><li><mark><span>技术</span></mark><span>:现有的技术能力和信息技术的发展现状是否足以支持系统目标的实现</span></li><li><mark><span>资源</span></mark><span>:现有的资源 (例如，掌握技术的员工、企业的技术积累、构件库、软硬件条件等)是否足以支持项目的实施。</span></li><li><mark><span>目标</span></mark><span>:由于在可行性研究阶段，项目的目标是比较模糊的，因此技术可行性最好与项目功能、性能和约束的定义同时进行。在可行性研究阶段，调整项目目标和选择可行的技术体系都是可以的，而一旦项目进入开发阶段，任何调整都意味着更多的开销。</span></li><li><span>需要特别指出的是，技术可行性绝不仅仅是论证在技术手段上是否可实现，实际上包含了</span><mark><span>在当前资源条件下</span></mark><span>的技术可行性。</span></li></ul></li><li><p><strong><span>法律可行性</span></strong><span>: 也称为</span><mark><span>社会可行性</span></mark><span>，具有比较广泛的内容它需要从政策、法律、道德、制度等社会因素来论证信息系统建设的现实性</span></p></li><li><p><strong><span>用户使用可行性</span></strong><span>: 也称为</span><mark><span>执行可行性</span></mark><span>，是</span><mark><span>从信息系统用户的角度</span></mark><span>来评估系统的可行性，包括企业的行政管理和工作制度、使用人员的素质和培训要求等可以细分为</span><mark><span>管理可行性和运行可行性</span></mark></p><ul><li><mark><span>(1)管理可行性</span></mark><span>。管理可行性是指从</span><mark><span>企业管理上</span></mark><span>分析系统建设可行性。主管领导不支持的项目一般会失败，中高层管理人员的抵触情绪很大，就有必要等一等，先积极做好思想工作，创造条件。另外，还要考虑管理方法是否科学，相应的管理制度改革的时机是否成熟，规章制度是否齐全等</span></li><li><mark><span>(2)运行可行性</span></mark><span>。运行可行性也称为</span><mark><span>操作可行性</span></mark><span>，是指分析和测定信息系统</span><mark><span>在确定环境中能够有效工作，并被用户方便使用的程度和能力</span></mark><span>。例如，ERP系统建成后的数据采集和数据质量问题，企业工作人员没有足够的IT技能等</span></li></ul></li></ul></li><li><p><strong><span>可行性研究报告内容</span></strong><span>：引言、引用文件、可行性研究的前提、可选的方案、所建议的系统、经济技术法律用户使用可行性、其他与项目有关的问题、注解、附录</span></p></li></ul><h4><a name="成本效益分析考点" class="md-header-anchor"></a><span>成本效益分析(考点)</span></h4><ul><li><p><span>成本按照投资时间分类:</span></p><ul><li><mark><span>(1)基础建设投资</span></mark><span>。例如，房屋和设施、办公设备、平台软件、必须的工具软(1)件等购置成本。基础建设投资既可以是一次性投资，也可以是分期付款。</span></li><li><mark><span>(2)其他一次性投资</span></mark><span>。例如，研究咨询成本、调研费、管理成本、培训费、差</span>
<span>旅费等，以及其他一次性杂费。</span></li><li><mark><span>(3)其他非一次性投资</span></mark><span>。主要是指系统的运行与维护成本。例如，设备租金和定期维护成本、定期消耗品支出、通信费、人员工资与奖金、房屋租金、公共设施维护等，以及其他经常性的支出项目</span></li></ul></li><li><p><span>按照成本性态分类: (考点)</span></p><ul><li><strong><span>(1)固定成本</span></strong><span>。固定成本是指其</span><mark><span>总额在一定期间和一定业务量范围内，不受业务量变动的影响而保持固定不变</span></mark><span>的成本。例如，管理人员的工资、办公费、固定资产折旧费、员工培训费等。</span></li><li><strong><span>(2)变动成本</span></strong><span>。变动成本也称为可变成本，是指</span><mark><span>在一定时期和一定业务量范围内其总额随着业务量的变动而成正比例变动</span></mark><span>的成本。例如，直接材料费、产品包装费、外包费用、开发奖金等。</span></li><li><strong><span>(3)混合成本。</span></strong><span>混合成本就是混合了固定成本和变动成本的性质的成本。例如水电费、电话费等。这些成本通常有一-个基数，超过这个基数就会随业务量的增大而增大。</span></li></ul></li><li><p><span>按计入方式分类：</span></p><ul><li><span>(1)直接成本: </span><mark><span>与产品生产工艺直接有关的成本</span></mark><span>，如原料、主要材料、外购半成品、生产工人工资、机器设备折旧等。</span></li><li><span>(2)间接成本:与产品生产工艺</span><mark><span>没有直接关系的成本</span></mark><span>，如机物料消耗、辅助工人和车间管理人员工资、车间房屋折旧等。</span></li></ul></li><li><p><span>沉没成本: </span><mark><span>指以往发生的，但与当前决策无关的费用</span></mark></p></li><li><p><span>收益分类:</span></p><ul><li><mark><span>(1)有形收益也称为经济收益</span></mark><span>，可以用货币的时间价值、投资回收期、投资回收率等指标进行度量。</span></li><li><mark><span>(2)无形收益也称为不可定量的收益</span></mark><span>，主要是从性质上、心理上进行衡量，很难直接进行量上的比较</span></li></ul></li></ul><h4><a name="盈亏平衡点" class="md-header-anchor"></a><span>盈亏平衡点</span></h4><ul><li><p><span>利润=销售额-成本=销售额- (固定成本+可变成本)</span></p></li><li><p><span>当利润&gt;0，即公司挣钱，当利润&lt;0，即公司亏本，当</span><mark><span>利润=0时，就是盈亏平衡点，此时不亏不赚</span></mark><span>，公式如下:</span></p></li><li><p><span>盈亏平衡点销售额=总固定成本+总可变成本=总固定成本+[</span><mark><span>可变成本占销售额的比例</span></mark><span>*盈亏平衡点销售额] </span></p></li><li><p><span>盈亏平衡点 = 固定成本 / (销售金额 - 可变成本)</span></p></li><li><p><span>注意:可变成本和销售收入成正比。</span></p><p><img src="http://qn.qs520.mobi/image-20230215190202425.png" referrerpolicy="no-referrer" alt="image-20230215190202425"><span> </span></p></li></ul><h4><a name="净现值计算考点" class="md-header-anchor"></a><span>净现值计算(考点)</span></h4><p><img src="http://qn.qs520.mobi/image-20230215201538238.png" referrerpolicy="no-referrer" alt="image-20230215201538238"><span> </span></p><p><mark><span>这里的净值通俗来说就是总的收益减掉总的成本就得到了净值，例如第四年的收益折现为2732 - 折现成本683 = 2049，这就是第四年的净值，但是投资回收期计算的是累计净值所以要还要减掉第三年的累计净值2216，第四年的累计净值为-167</span></mark></p><p><mark><span>NPVR = 现金流量 / 投资本金</span></mark></p><h2><a name="span-id12系统分析及需求工程12系统分析及需求工程案例分析考点2span" class="md-header-anchor"></a><span id="12.系统分析及需求工程"><span>12.系统分析及需求工程(案例分析考点2)</span></span></h2><p><mark><span>通读教材: 第8章软件工程;第10章 系统分析;第11章软件需求工程;第12章 软件架构设计;第13章 系统设计:</span></mark></p><h4><a name="软件需求" class="md-header-anchor"></a><span>软件需求</span></h4><ul><li><p><mark><span>软件需求</span></mark><span>: 是指用户</span><mark><span>对系统在功能、行为、性能、设计约束等方面的期望</span></mark><span>。是指</span><mark><span>用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力</span></mark><span>，以及反映这些条件或能力的文档说明。</span></p></li><li><p><span>分为</span><mark><span>需求开发</span></mark><span>和</span><mark><span>需求管理</span></mark><span>两大过程，如下所示:</span></p><p><img src="http://qn.qs520.mobi/image-20230216095041506.png" referrerpolicy="no-referrer" alt="image-20230216095041506"><span> </span></p></li><li><p><mark><span>业务需求</span></mark><span>: 反映</span><mark><span>企业或客户对系统高层次的目标要求</span></mark><span>，通常来自项目投资人、客户、市场营销部门或产品策划部门。通过业务需求可以确定项目视图和范围</span></p></li><li><p><mark><span>用户需求</span></mark><span>: 描述的是</span><mark><span>用户的具体目标，或用户要求系统必须能完成的任务</span></mark><span>。即描述了</span><mark><span>用户能使用系统来做什么</span></mark><span>。通常采取用户访谈和问卷调查等方式，对用户使用的场景进行整理，从而建立用户需求。 </span></p></li><li><p><mark><span>系统需求</span></mark><span>: </span><mark><span>从系统的角度来说明软件的需求</span></mark><span>，包括</span><strong><span>功能需求、非功能需求和设计约束</span></strong><span>等。</span></p><ul><li><span>1)</span><strong><span>功能需求</span></strong><span>:也称为行为需求，规定了</span><mark><span>开发人员必须在系统中实现的软件功能</span></mark><span>, </span><mark><span>用户利用这些功能来完成任务</span></mark><span>，满足业务需要。</span></li><li><span>2)</span><strong><span>非功能需求(性能需求)</span></strong><span>:指</span><mark><span>系统必须具备的属性或品质</span></mark><span>，又可以细分为</span><mark><span>软件质量属性(如可维护性、可靠性、效率等</span></mark><span>) 和其他非功能需求。</span></li><li><span>3)</span><strong><span>设计约束</span></strong><span>:也称为</span><mark><span>限制条件或补充规约</span></mark><span>，通常是</span><mark><span>对系统的一些约束说明</span></mark><span>，例如必须采用国有自主知识产权的数据库系统，必须运行在UNIX操作系统之下等。</span></li></ul></li><li><p><mark><span>质量功能部署</span></mark></p><ul><li><span>质量功能部署 (QFD)是一种</span><mark><span>将用户要求转化成软件需求的技术</span></mark><span>，其目的是最大限度地提升软件工程过程中用户的满意度。为了达到这个目标，QFD将软件需求分为三类，分别是</span><mark><span>常规需求、期望需求和意外需求</span></mark><span>。</span></li><li><span>(1)</span><strong><span>常规需求</span></strong><span>。用户认为</span><mark><span>系统应该做到的功能或性能</span></mark><span>，实现越多用户会越满意</span></li><li><span>(2)</span><strong><span>期望需求</span></strong><span>。用户</span><mark><span>想当然认为系统应具备的功能或性能，但并不能正确描述</span></mark><span>自己想要得到的这些功能或性能需求。如果期望需求没有得到实现，会让用户感到不满意。</span></li><li><span>(3)</span><strong><span>意外需求</span></strong><span>。意外需求也称为兴奋需求，是</span><mark><span>用户要求范围外的功能或性能</span></mark><span>(但通常是软件开发人员很乐意赋予系统的技术特性)，实现这些需求用户会更高兴，但不实现也不影响其购买的决策。</span></li></ul></li></ul><h4><a name="需求获取" class="md-header-anchor"></a><span>需求获取</span></h4><ul><li><p><mark><span>需求获取</span></mark><span>: 是一个确定和理解不同的项目干系人的需求和约束的过程</span></p></li><li><p><mark><span>常见的需求获取法</span></mark><span>包括:</span></p><ul><li><span>(1)</span><strong><span>用户访谈</span></strong><span>:1对1-3，有代表性的用户。其形式包括结构化和非结构化两种。结构化就是事先准备好问题照着问，非结构化就是发散性思维，随意聊天。</span><mark><span>优点是灵活，缺点是记录困难，有时间限制</span></mark></li><li><span>(2)</span><strong><span>问卷调查</span></strong><span>:用户多，无法一一访谈。</span><mark><span>优点是用户多范围广，成本低缺点是不灵活</span></mark></li><li><span>(3)</span><strong><span>采样</span></strong><span>:从种群中系统地选出有代表性的样本集的过程。</span><mark><span>样本数量=0.25*(可信度因子/错误率)2</span></mark><span>  (可信度处错误率的二次方)。</span><mark><span>优点是采样了代表样本提高效率，降低成本。缺点是样本选的不好会导致有偏差，还有取决于选取样本的人，依赖他的主观判断。</span></mark></li><li><span>(4)</span><strong><span>情节串联板</span></strong><span>:一系列图片，通过这些图片来讲故事。</span><mark><span>优点是直观，通俗易懂。缺点是花费时间多，效率低</span></mark></li><li><span>(5)</span><mark><strong><span>联合需求计划 (JRP)(相当于开会)</span></strong></mark><span>: 通过联合各个关键用户代表、系统分析师、开发团队代表一起，通过有组织的会议来讨论需求。</span><mark><span>优点是效率高，沟通方便，适合解决有争议的需求。缺点是耗时，容易出现无效开会。</span></mark></li><li><span>(6)</span><strong><span>需求记录技术</span></strong><span>: 任务卡片、场景说明、用户故事、Volere白卡。同4</span></li></ul></li></ul><h4><a name="需求分析" class="md-header-anchor"></a><span>需求分析</span></h4><ul><li><p><mark><span>需求分析</span></mark><span>: 一个好的需求应该具有无二义性、完整性、一致性、可测试性、确定性、可跟踪性、正确性、必要性等特性，因此，需要分析人员</span><mark><span>把杂乱无章的用户要求和期望转化为用户需求</span></mark><span>，这就是需求分析的工作。</span></p></li><li><p><strong><span>需求分析的任务</span></strong></p><ol start='' ><li><mark><span>绘制系统上下文范围关系图(数据流图)</span></mark><span>：这种关系图是用于定义系统与系统外部实体间的界限和接口的简单模型，它可以为需求确定一个范围。</span></li><li><mark><span>创建用户界面原型</span></mark><span>：用户界面对于一个系统来说是十分重要的，因此在需求分析阶段通过快速开发工具开发一个抛弃式原型，或者通过 PowerPoint、Flash 等演示工具制作一个演示原型，甚至是用纸和笔画出一些关键的界面接口示意图，将帮助用户更好地理解所要解决的问题，更好地理解系统。</span></li><li><mark><span>分析需求的可行性</span></mark><span>：对所有获得的需求进行成本、性能和技术实现方面的可行性研究，以及这些需求项是否与其他的需求项有冲突，是否有对外的依赖关系等</span></li><li><mark><span>确定需求的优先级</span></mark><span>：这是一项很重要的工作，迭代开发已经成为了现代软件工程方法的一个基础，而需求的优先级是制订迭代计划的一个最重要的依据。对于需求优先级的描述，可以采用满意度和不满意度指标进行说明。其中满意度表示当需求被实现时用户的满意程度，不满意度表示当需求未被实现时用户的不满意程度。</span></li><li><mark><span>为需求建立(逻辑)模型</span></mark><span>：也就是建立分析模型，这些模型的表现形式主要是图表加上少量的文字描述，所谓“一图抵千字”，图形化地描述需求将使得其更加清晰、易懂。根据采用的分析方法不同，采用的图也将不同。例如，00A 中的用例模型和领域模型，SA 中的 DFD和E-R 图等。需求分析模型主要描述系统的数据、功能、用户界面和运行的外部行为，它是系统的一种逻辑表示技术，并不涉及软件的具体实现细节。需求分析模型可以帮助系统分析师理解系统，使需求分析任务更加容易实现。同时，它也是以后进行软件设计的基础，为软件设计提供了系统的表示视图。</span></li><li><mark><span>创建数据字典</span></mark><span>：数据字典是对系统用到的所有数据项和结构进行定义，以确保开发人员使用了统一的数据定义</span></li><li><mark><span>使用QFD(质量功能部署)</span></mark><span>：这是在需求优先级基础上的一个升华，其原理与满意度和不满意度指标十分接近，通过将产品特性、属性与对用户的重要性联系起来</span></li></ol></li><li><p><strong><span>结构化(SA)的需求分析</span></strong></p><ul><li><p><span>结构化特点: </span><mark><span>自顶向下，逐步分解，面向数据</span></mark></p><ul><li><span>优点：结构化分析方法简单，清晰，易于学习和掌握。结构化分析方法的实施步骤是先分析当前现实环境中已经存在的系统，在此基础上再构思要开发的目标系统，这符合人们改造世界的一般规律，大大降低了问题的复杂度。结构化分析采用图形描述的方式，用数据流图把系统描述成可见的模型，易于分析和审查。</span></li><li><span>缺点：结构化分析方法要对一个整体问题进行不断分解，要处理的条件和信息会越来越多，这也使得结构化方法处理复杂问题有一定难度</span></li></ul></li><li><p><span>三大模型: </span><mark><span>功能模型(数据流图)，行为模型 (状态转换图)、数据模型 (E-R图)以及数据字典</span></mark><span>。</span></p></li><li><p><img src="http://qn.qs520.mobi/image-20230216104934218.png" referrerpolicy="no-referrer" alt="image-20230216104934218"><span> </span></p></li></ul></li><li><p><span>状态转换图STD如下图所示：</span></p><p><img src="http://qn.qs520.mobi/image-20230216105059438.png" referrerpolicy="no-referrer" alt="image-20230216105059438"><span> </span></p></li><li><p><span>数据流图描述</span><mark><span>数据在系统中如何被传送或变换，以及如何对数据流进行变换的功能或子功能，用于对功能建模，</span></mark><span>数据流图相关概念如图:</span></p><p><img src="http://qn.qs520.mobi/image-20230216105215965.png" referrerpolicy="no-referrer" alt="image-20230216105215965"><span> </span></p></li><li><p><span>数据流图是可以分层的，从顶层(即上下文无关数据流)到0层、1层等，顶层数据流图只含有一个加工处理表示整个管理信息系统，描述了系统的输入和输出，以及和外部实体的数据交互。数据流图示例如下: </span></p><p><img src="http://qn.qs520.mobi/image-20230216105353730.png" referrerpolicy="no-referrer" alt="image-20230216105353730"><span> </span></p></li><li><p><strong><span>需求分析方法-PDOA方法</span></strong></p><ul><li><p><mark><span>面向问题域的分析，更多的强调描述，而少强调建模</span></mark><span>，包括:</span></p><ol start='' ><li><span>关注问题域。用一个文档对含有的问题域进行相关的描述，并列出需要在该域中求解的问题列表，也就是需求列表。只有这个文档是在分析时产生的。</span></li><li><span>关注解系统(即系统实现)的待求行为。用一个文档对了解系统的待求行为进行描述。该文档将在需求定义阶段完成</span></li></ol></li><li><p><span>在PDOA 方法中，对整个过程有着一个清晰的定义:</span></p><ol start='' ><li><span>收集基本的信息并开发问题框架，以建立问题域的类型。</span></li><li><span>在问题框架类型的指导下，进一步收集详细信息，并给出一个问题域相关特性的描述。</span></li><li><span>基于以上两点，收集并用文档说明新系统的需求</span></li></ol></li><li><p><span>从上面的描述中可以看出，问题框架是PDOA 的核心元素，是将问题域分为一系列相互关联的子域，而一个子域可以是那些可能算是精选出来的问题域的一部分。</span></p></li></ul></li><li><p><strong><span>面向对象的需求分析</span></strong></p></li><li><p><span>优点：面向对象方法将要处理的问题看做对象，复杂对象由简单对象组成。具有相同属性的对象属于同一个类，类具有封装性。面向对象方法的分析思维和人类思维方法一致，更容易理解。由于面向对象的封装性，所以局部的改变不会影响整体的功能，维护方便，可靠性也更高。</span></p></li><li><p><span>缺点：面向对象对于用户使用起来很方便，但是对分析人员的抽象能力有较高的要求，对于对象的建立不但要精准而且要全面，否则整体模块划分不合理，对功能会有很大影响</span></p><ul><li><p><span>(1)</span><mark><span>对象</span></mark><span>: 由</span><mark><span>数据及其操作所构成的封装体</span></mark><span>，是系统中用来</span><mark><span>描述客观事务的一个实体</span></mark><span>，是构成系统的一个基本单位。一个对象通常可以由</span><mark><span>对象名、属性和方法</span></mark><span>3个部分组成</span></p></li><li><p><span>(2)</span><mark><span>类</span></mark><span>:现实世界中</span><mark><span>实体的形式化描述</span></mark><span>，类将该实体的属性(数据) 和操作(函数)封装在一起。</span><mark><span>对象是类的实例，类是对象的模板，</span></mark><span>类可以分为三种: </span><mark><span>实体类、接口类(边界类)和控制类</span></mark><span>。</span></p><ul><li><mark><span>实体类</span></mark><span>保存要存入永久存储体的信息。实体类通常在事件流或交互图中,是对用户最有意义的类</span></li><li><mark><span>接口类(边界类)</span></mark><span>位于系统与外界的交界处，为用户提供一种与系统合作交互的方式，分为人和系统两大类，其中人的接口可以是显示屏窗口、Web 窗体、对话框、菜单、列表框、其他显示控制、条形码、二维码或者用户与系统交互的其他方法。系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据。</span></li><li><mark><span>控制类</span></mark><span>负责协调其他类的工作。每个用例中至少应该有一个控制类,它控制用况中的事件顺序</span></li><li><mark><span>实体对象</span></mark><span>: 用来表示业务域的事实数据并需要持久化存储的对象类型;</span></li><li><mark><span>控制对象</span></mark><span>:用来表示业务系统中应用逻辑和业务规则的对象类型;</span></li><li><mark><span>接口对象</span></mark><span>:用来表示用户与系统之间交互方式的对象类型。</span></li></ul></li><li><p><span>(3)</span><mark><span>抽象</span></mark><span>: 通过</span><mark><span>特定的实例抽取共同特征以后形成概念的过程。它强调主要特征，忽略次要特征</span></mark><span>。一个对象是现实世界中一个实体的抽象，一个类是一组对象的抽象，抽象是一种单一化的描述，它强调给出与应用相关的特性，抛弃不相关的特性。</span></p></li><li><p><span>(4)</span><mark><span>封装</span></mark><span>: 是一种</span><mark><span>信息隐蔽技术</span></mark><span>，将相关的概念组成一个单元模块，并通过一个名称来引用。面向对象封装是将数据和基于数据的操作封装成一个整体对象，对数据的访问或修改只能通过对象对外提供的接口进行。</span></p></li><li><p><span>(5)</span><mark><span>继承</span></mark><span>: 表示</span><mark><span>类之间的层次关系(父类与子类)</span></mark><span>，这种关系使得某类对象可以继承另外一类对象的特征，又可分为单继承和多继承。</span></p></li><li><p><span>(6)</span><mark><span>多态</span></mark><span>: </span><mark><span>不同的对象收到同一个消息时产生完全不同的结果</span></mark><span>。包括</span><mark><span>参数多态(不同类型参数多种结构类型)，包含多态(父子类型关系)、过载多态(类似于重载，一个名字不同含义)，强制多态(强制类型转换)</span></mark><span> 四种类型。多态、由继承机制支持，将通用消息放在抽象层，具体不同的功能实现放在低层。</span></p></li><li><p><span>(7)</span><mark><span>接口</span></mark><span>:  描述对操作规范的说明，其</span><mark><span>只说明操作应该做什么</span></mark><span>，并没有定义操作如何做。</span></p></li><li><p><span>(8)</span><mark><span>消息</span></mark><span>: 体现</span><mark><span>对象间的交互</span></mark><span>，通过它向目标对象发送操作请求</span></p></li><li><p><span>(9)</span><mark><span>覆盖</span></mark><span>: 子类在原有父类接口的基础上，</span><mark><span>用适合于自己要求的实现去置换父类中的相应实现</span></mark><span>。即在子类中重定义一个与父类同名同参的方法。</span></p></li><li><p><span>(10)</span><mark><span>函数重载</span></mark><span>: 与覆盖要区分开，函数重载与子类父类无关，且函数是</span><mark><span>同名不同参数</span></mark></p></li><li><p><span>(11) 绑定是一个把</span><mark><span>过程调用和响应调用所需要执行的代码加以结合</span></mark><span>的过程。在一般的程序设计语言中，</span><mark><span>绑定是在编译时进行的，叫作静态绑定</span></mark><span>。</span><mark><span>动态绑定则是在运行时进行的</span></mark><span>，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。</span></p></li></ul></li><li><p><strong><span>面向对象(OOA)的分析</span></strong><span>: 是为了</span><mark><span>确定问题域，理解问题</span></mark><span>。包含五个活动: </span><mark><span>认定对象，组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息</span></mark><span>。</span></p></li><li><p><strong><span>面向对象需求建模</span></strong><span>: </span><mark><span>用例模型(对应用例图)和分析模型(分为静态和动态)</span></mark><span>，结构化需求分析会建立三种需求模型</span></p><p><img src="http://qn.qs520.mobi/image-20230216111730377.png" referrerpolicy="no-referrer" alt="image-20230216111730377"><span> </span></p></li></ul><h4><a name="统一建模语言uml" class="md-header-anchor"></a><span>统一建模语言UML</span></h4><ul><li><p><strong><span>UML(统一建模语言)</span></strong><span>: 是一种</span><mark><span>可视化的建模语言，而非程序设计语言</span></mark><span>，支持从需求分析开始的软件开发的全过程。</span></p></li><li><p><span>从总体上来看，UML的结构包括</span><mark><span>构造块、规则和公共机制</span></mark><span>三个部分。</span></p><ul><li><p><span>(1)</span><strong><span>构造块</span></strong><span>。UML有三种基本的构造块，分别是</span><mark><span>事物 (thing)、关系(relationship) 和图 (diagram)</span></mark><span> 。事物是UML的重要组成部分，关系把事物紧密联系在一起，图是多个相互关联的事物的集合</span></p></li><li><p><span>(2)</span><strong><span>公共机制</span></strong><span>。公共机制是指达到特定目标的公共UML方法</span></p></li><li><p><span>(3)</span><strong><span>规则</span></strong><span>。规则是构造块如何放在一起的规定</span></p><p><img src="http://qn.qs520.mobi/image-20230216214709922.png" referrerpolicy="no-referrer" alt="image-20230216214709922"><span> </span></p></li></ul></li><li><p><strong><span>事物(thing)</span></strong></p><ul><li><p><strong><span>结构事物</span></strong><span>: 模型的静态部分，如类、接口、用例、构件等;</span></p></li><li><p><strong><span>行为事物</span></strong><span>: 模型的动态部分，如交互、活动、状态机;</span></p></li><li><p><strong><span>分组事物</span></strong><span>: 模型的组织部分，如包</span></p></li><li><p><strong><span>注释事物</span></strong><span>: 模型的解释部分，依附于一个元素或组元素之上对其进行约束或解释的简单符号。</span></p><p><img src="http://qn.qs520.mobi/image-20230216120203449.png" referrerpolicy="no-referrer" alt="image-20230216120203449"><span> </span></p></li></ul></li><li><p><strong><span>关系(relationship)</span></strong></p><ul><li><p><strong><span>依赖</span></strong><span>: </span><mark><span>一个事物的语义依赖于另一个事物的语义的变化而变化</span></mark></p></li><li><p><strong><span>关联</span></strong><span>: 是一种结构关系，描述了一组链，链是对象之间的连接。分为</span><mark><span>组合和聚合</span></mark><span>，</span><mark><span>都是部分和整体的关系</span></mark><span>，其中组合事物之间关系更强。两个类之间的关联，实际上是两个类所扮演角色的关联，因此，两个类之间可以有多个由不同角色标识的关联。</span></p></li><li><p><strong><span>泛化</span></strong><span>: </span><mark><span>一般/特殊的关系</span></mark><span>，子类和父类之间的关系（泛化更重于继承）</span></p></li><li><p><strong><span>实现</span></strong><span>: </span><mark><span>一个类元指定了另一个类元保证执行的契约</span></mark><span> （实现更重于继承之后的</span><mark><span>实现</span></mark><span>）</span></p></li><li><p><span>记忆方法：关联依赖实现泛化聚合组合。依赖是虚线实心然后到实现虚线空心然后到实线空心，聚合组合顺序：空心到实心</span></p><p><img src="http://qn.qs520.mobi/image-20230216120503104.png" referrerpolicy="no-referrer" alt="image-20230216120503104"><span> </span></p></li></ul></li><li><p><strong><span>图(diagram)</span></strong></p><ul><li><p><span>UML2.0图，书上是13种，有的说法还包含制品图，一共14种，了解即可，总分类如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230216120542524.png" referrerpolicy="no-referrer" alt="image-20230216120542524"><span> </span></p></li><li><p><mark><span>类图</span></mark><span>: 静态图，为系统的</span><mark><span>静态设计视图</span></mark><span>，展现</span><mark><span>一组对象、接口、协作和它们之间的关系</span></mark><span>。UML类图如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230216120648930.png" referrerpolicy="no-referrer" alt="image-20230216120648930"><span> </span></p></li><li><p><mark><span>对象图</span></mark><span>:静态图，展现</span><mark><span>某一时刻一组对象及它们之间的关系</span></mark><span>，</span><mark><span>为类图的某快照</span></mark><span>。在没有类图的前提下，对象图就是静态设计视图。如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230216120740452.png" referrerpolicy="no-referrer" alt="image-20230216120740452"><span> </span></p></li><li><p><mark><span>用例图(重点)</span></mark><span>: 静态图，展现了一组</span><mark><span>用例、参与者以及它们之间的关系</span></mark><span>。用例图中的参与者是人、硬件或其他系统可以扮演的角色;用例是参与者完成的一系列操作，用例图用例之间的关系有</span><mark><span>扩展、包含、泛化</span></mark><span>。如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230216120838272.png" referrerpolicy="no-referrer" alt="image-20230216120838272"><span> </span></p></li><li><p><mark><span>序列图</span></mark><span>:即</span><mark><span>顺序图</span></mark><span>，动态图，是场景的图形化表示，描述了</span><mark><span>以时间顺序组织的对象之间的交互活动</span></mark><span>。有</span><strong><span>同步消息</span></strong><span>(进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示)，</span><strong><span>异步消息</span></strong><span> (发出消息后继续执行，不引起调用者阻塞，也不等待返回消息，由空心箭头表示)、</span><strong><span>返回消息</span></strong><span>(由从右到左的虚线箭头表示)三种。如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230216120946968.png" referrerpolicy="no-referrer" alt="image-20230216120946968"><span> </span></p></li><li><p><mark><span>通信图</span></mark><span>:动态图，即</span><mark><span>协作图，强调参加交互的对象的组织</span></mark><span>。如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230216121024761.png" referrerpolicy="no-referrer" alt="image-20230216121024761"><span> </span></p></li><li><p><mark><span>状态图(重要)</span></mark><span>:动态图，展现了一个状态机，描述</span><mark><span>单个对象在多个用例中的行为，</span></mark><span>包括简单状态和组合状态。转换可以通过</span><mark><span>事件触发器</span></mark><span>触发，事件触发后相应的</span><mark><span>监护条件</span></mark><span>会进行检查。状态图中转换和状态是两个独立的概念，如下:图中方框代表状态，箭头上的代表触发事件，实心圆点为起点和终点。</span></p><p><img src="http://qn.qs520.mobi/image-20230216121153568.png" referrerpolicy="no-referrer" alt="image-20230216121153568"><span> </span></p></li><li><p><mark><span>活动图</span></mark><span>:动态图，是一种</span><mark><span>特殊的状态图</span></mark><span>，展现了</span><mark><span>在系统内从一个活动到另一个活动的流程</span></mark><span>。活动的分岔和汇合线是一条水平粗线。牢记下图中</span><mark><span>并发分岔、并发汇合、监护表达式、分支、流</span></mark><span>等名词及含义。每个分岔的分支数代表了可同时运行的线程数。活动图中能够并行执行的是在一个分岔粗线下的分支上的活动</span></p><p><img src="http://qn.qs520.mobi/image-20230216121301144.png" referrerpolicy="no-referrer" alt="image-20230216121301144"><span> </span></p></li><li><p><mark><span>构件图(组件图)</span></mark><span>：静态图，为系统</span><mark><span>静态实现视图，展现了一组构件之间的组织和依赖</span></mark><span>。如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230216121409563.png" referrerpolicy="no-referrer" alt="image-20230216121409563"><span> </span></p></li><li><p><mark><span>部署图</span></mark><span>:静态图，为系统</span><mark><span>静态部署视图</span></mark><span>，部署图</span><mark><span>物理模块</span></mark><span>的节点分布。它与构件图相关，通常一个结点包含一个或多个构件。其依赖关系类似于包依赖，因此部署组件之间的依赖是单向的类似于包含关系。如下:</span></p><p><img src="http://qn.qs520.mobi/image-20230216121456214.png" referrerpolicy="no-referrer" alt="image-20230216121456214"><span> </span></p></li><li><p><mark><span>UML 4+1视图</span></mark></p><ul><li><p><span>(1) 逻辑视图。逻辑视图也称为</span><mark><span>设计视图</span></mark><span>，它表示了设计模型中在架构方面具有重要意义的部分，即</span><mark><span>类、子系统、包和用例实现的子集，描述了设计的对象模型，支持系统的功能需求。</span></mark></p></li><li><p><span>(2)进程视图。进程视图是</span><mark><span>可执行线程和进程作为活动类的建模</span></mark><span>，它是</span><mark><span>逻辑视图的一次执行实例，描述了并发与同步结构</span></mark><span>。</span></p></li><li><p><span>(3)实现视图。实现视图对组成基于系统的</span><mark><span>物理代码的文件和构件进行建模，支持软件开发的内部需求</span></mark></p></li><li><p><span>(4)部署视图。部署视图把构件</span><mark><span>部署到一组物理节点上</span></mark><span>表示软件到硬件的映射和分布结构，反映了分布式特性，支持系统的拓扑，安装，通信需求。</span></p></li><li><p><span>(5)用例视图。用例视图是</span><mark><span>最基本的需求分析模型，用来说明重要的系统活动，是其他四个的综合</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230216121650752.png" referrerpolicy="no-referrer" alt="image-20230216121650752"><span> </span></p></li></ul></li></ul></li><li><p><mark><span>需求分析方法的对比(考点)</span></mark><span>：</span></p><ul><li><mark><span>SA</span></mark><span> 方法关注于功能的分层和分解，这非常符合人们自上而下、逐步分解问题直到可解决的自然思考方式。SA 方法本身隐含着几个基本假设，即问题域是可定义的、问题域是有限的、通过有限的步骤总可以将复杂问题分解到可解决的程度</span></li><li><mark><span>OOA</span></mark><span> 方法则遵循完全不同的思维方式，它基于抽象、信息隐藏、功能独立和模块化这些基本理念对系统进行分析。O0A 方法首先对问题域的事物的“外在表象”进行观测，然后在逻辑世界中模拟出一个对应的逻辑对象，“断定”该对象和现实事物是一致的。随后，观测到的对象被记录入对象集合，观测到的行为和表象被记录入对象关系模型和对象行为模型</span></li><li><mark><span>PDOA</span></mark><span> 的特点是重新将重点定位在问题域和需求上，通过对问题域的分类，向系统分析师提供具体问题的相关指南。并且它将规格说明作为另外的任务处理，它的成果只是一份问题域的全面描述和一份需求列表而已。PDOA 丰富和完善了SA和OOA 方法</span></li></ul></li></ul><h4><a name="需求定义" class="md-header-anchor"></a><span>需求定义</span></h4><ul><li><p><mark><span>需求定义(软件需求规格说明书SRS):</span></mark><span>是需求开发活动的产物，编制该文档的目的是使项目干系人与开发团队对系统的初始规定有一个共同的理解，使之成为整个开发工作的基础。SRS是软件开发过程中最重要的文档之一，对于任何规模和性质的软件项目都不应该缺少</span></p></li><li><p><strong><span>需求定义方法</span></strong></p><ul><li><span>1)</span><strong><span>严格定义</span></strong><span>也</span><mark><span>称为预先定义，适合需求明确</span></mark><span>，需求的严格定义</span><mark><span>建立在以下的基本假设之上</span></mark><span>: </span><mark><span>所有需求都能够被预先定义</span></mark><span>。开发人员与用户之间能够准确而清晰地交流。采用图形(或文字)可以充分体现最终系统。</span></li><li><span>2)</span><strong><span>原型方法</span></strong><span>，</span><mark><span>迭代的循环型开发方式</span></mark><span>，</span><mark><span>适合需求不明确</span></mark><span>, 需要注意的问题:并非所有的需求都能在系统开发前被准确地说明。项目干系人之间通常都存在交流上的困难，</span><mark><span>原型提供了克该服困难的一个手段</span></mark><span>。特点:需要实际的、可供用户参与的系统模型。有合适的系统开发环境。反复是完全需要和值得提倡的，需求一旦确定，就应遵从严格的方法。</span></li></ul></li><li><p><mark><span>需求规格说明书(SRS)内容、作用</span></mark></p><ul><li><mark><span>内容</span></mark><span>:范围;引用文件，需求，合格性规定;需求可追踪性，尚未解决的问题，注解;附录。</span></li><li><mark><span>通俗答法</span></mark><span>: 系统应该提供的功能和服务，非功能需求，包括系统的特征、特点和属性，限制系统开发或者系统运行必须遵守的约束条件;系统必须连接的其他系统的信息。</span></li><li><mark><span>作用</span></mark><span>:系统所有者和用户使用需求定义文档来确认需求以及任何可能产生的变化，并作为验收依据，系统分析人员、设计人员和构造人员使用它来理解需要什么以及处理需求变更，开发用于验证系统的测试用例;项目经理使用它作为制定项目计划、处理变更及验收的依据</span></li></ul></li></ul><h4><a name="需求验证" class="md-header-anchor"></a><span>需求验证</span></h4><ul><li><p><span>需求验证:也称为需求确认，目的是</span><mark><span>与用户一起确认需求无误</span></mark><span>，对需求规格说明书SAS进行评审和测试，包括两个步骤:</span></p><ul><li><span>需求评审:</span><mark><span>正式评审和非正式评审。</span></mark></li><li><span>需求测试: </span><mark><span>设计概念测试用例。</span></mark></li></ul></li><li><p><span>需求验证通过后，要请用户签字确认，作为验收标准之一，此时，这个需求规格说明书就是需求基线，不可以再随意更新，如果需要更改必须走需求变更流程。</span></p></li></ul><h4><a name="需求管理" class="md-header-anchor"></a><span>需求管理</span></h4><ul><li><p><span>定义需求基线: 通过了评审的需求说明书就是需求基线，下次如果需要变更需求，就需要按照流程来一步步进行。需求的流程及状态如下图所示</span></p><p><img src="http://qn.qs520.mobi/image-20230216202321143.png" referrerpolicy="no-referrer" alt="image-20230216202321143"><span> </span></p></li><li><p><strong><span>需求变更和风险</span></strong></p><ul><li><p><span>主要关心需求变更过程中的需求风险管理，带有风险的做法有: </span><mark><span>无足够用户参与、忽略了用户分类、用户需求的不断增加、模棱两可的需求、不必要的特性、过于精简的SRS、不准确的估算</span></mark></p></li><li><p><span>变更产生的原因: </span><mark><span>外部环境的变化、需求和设计做的不够完整、新技术的出现、公司机构重组造成业务流程的变化。</span></mark></p></li><li><p><mark><span>变更控制委员会CCB</span></mark><span>: 也称为配置控制委员会，其任务时对建议的配置项变更做出评价、审批，以及监督已经批准变更的实施。</span></p></li><li><p><strong><span>需求变更的流程</span></strong><span>如下图：</span></p><p><img src="http://qn.qs520.mobi/image-20230216202447594.png" referrerpolicy="no-referrer" alt="image-20230216202447594"><span> </span></p></li></ul></li><li><p><span>双向跟踪，两个层次，如下图所示</span></p><p><img src="http://qn.qs520.mobi/image-20230216202558470.png" referrerpolicy="no-referrer" alt="image-20230216202558470"><span> </span></p></li><li><p><span>正向跟踪表示</span><mark><span>用户原始需求是否都实现了</span></mark><span>，反向跟踪表示</span><mark><span>软件实现的是否都是用户要求的</span></mark><span>，不多不少，可以用原始需求和用例表格(需求跟踪矩阵)来表示</span></p></li><li><p><span>若原始需求和用例有对应，则在对应栏打对号，若某行都没有对号，表明原始需求未实现，正向跟踪发现问题:若某列都没有对号，表明有多余功能用例软件实现了多余功能，反向跟踪发现问题</span></p></li></ul><h2><a name="span-id13系统设计13系统设计span" class="md-header-anchor"></a><span id="13.系统设计"><span>13.系统设计</span></span></h2><h4><a name="处理流程设计" class="md-header-anchor"></a><span>处理流程设计</span></h4><ul><li><p><span>业务流程建模</span></p><ul><li><span>标杆瞄准:以行业领先的标杆企业为目标，结合本企业情况分析建模</span></li><li><span>IDEF (一系列建模、分析和仿真方法的统称)</span></li><li><span>DEMO(组织动态本质建模法)</span></li><li><span>Petri网</span></li><li><span>业务流程建模语言: BPEL、 BPML、BPMN、XPDL。</span></li><li><span>基于服务的BPM:基于Web服务的思想对业务流程进行建模</span></li></ul></li><li><p><span>IDEF集成流程建模</span></p><ul><li><p><mark><span>IDEFO:业务流程(功能) 建模</span></mark></p></li><li><p><span>IDEF1:信息建模;</span></p></li><li><p><mark><span>IDEF1X: 数据建模 (如ER模型)</span></mark></p></li><li><p><mark><span>IDEF2: 仿真建模设计:</span></mark></p></li><li><p><span>IDEF3: 过程描述获取</span></p></li><li><p><mark><span>IDEF4: 面向对象设计</span></mark></p></li><li><p><span>IDEF5: 本体论描述获取</span></p></li><li><p><span>IDEF6: 设计原理获取</span></p></li><li><p><span>IDEF7: 信息系统审计</span></p></li><li><p><mark><span>IDEF8: 用户界面建模</span></mark></p></li><li><p><span>IDEF9: 场景驱动信息系统设计</span></p><ul><li><span>IDEF10: 实施架构建模</span></li></ul></li><li><p><span>IDEF11: 信息制品建模</span></p></li><li><p><mark><span>IDEF12: 组织结构建模</span></mark></p></li><li><p><span>IDEF13: 三模式映射设计;</span></p></li><li><p><span>IDEF14: 网络规划。</span></p></li></ul></li><li><p><strong><span>业务流程表示工具</span></strong></p><ul><li><mark><span>程序流程图 (Program Flow Diagram PFD)</span></mark><span>，用一些图框表示各种操作，它独立于PFD)任何一种程序设计语言，比较直观、清晰，易于学习掌握。任何复杂的程序流程图都应该由</span><mark><span>顺序、选择和循环结构</span></mark><span>组合或嵌套而成。</span></li><li><mark><span>IPO图</span></mark><span>也是流程描述工具，用来描述构成软件系统的每个模块的</span><mark><span>输入、输出和数据加工</span></mark><span>。</span></li><li><mark><span>N-S图(盒图)</span></mark><span>容易表示</span><mark><span>嵌套和层次</span></mark><span>关系，并具有</span><mark><span>强烈的结构化特征</span></mark><span>。但是当问题很复杂时，N-S图可能很大，因此</span><mark><span>不适合于复杂程序的设计。</span></mark></li><li><mark><span>问题分析图 (PAD)</span></mark><span>是一种</span><mark><span>支持结构化程序设计</span></mark><span>的图形工具。PAD具有清晰的逻辑结构、标准化的图形等优点，更重要的是，它引导设计人员使用结构化程序设计方法，从而提高程序的质量。</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230217100624899.png" referrerpolicy="no-referrer" alt="image-20230217100624899"><span> </span></p></li><li><p><strong><span>业务流程重组BPR</span></strong></p><ul><li><span>BPR是对企业的业务流程进行</span><mark><span>根本性的再思考和彻底性的再设计</span></mark><span>，从而获得可以用诸如成本、质量、服务和速度等方面的业绩来衡量的显著性的成就。</span><mark><span>BPR设计原则、系统规划和步骤如下图所示</span></mark></li><li><img src="http://qn.qs520.mobi/image-20230217100728990.png" referrerpolicy="no-referrer" alt="image-20230217100728990"><span> </span></li></ul></li><li><p><strong><span>业务流程管理BPM</span></strong></p><ul><li><span>BPM是一种</span><mark><span>以规范化的构造端到端的卓越业务流程为中心</span></mark><span>，以持续的</span><mark><span>提高组织业务绩效为目的</span></mark><span>的系统化方法</span></li><li><span>BPM与BPR管理思想最根本的不同就在于</span><mark><span>流程管理并不要求对所有的流程进行再造</span></mark><span>。构造卓越的业务流程并不是流程再造，而是</span><mark><span>根据现有流程的具体情况，对流程进行规范化的设计</span></mark></li><li><span>流程管理包含三个层面: </span><mark><span>规范流程、优化流程和再造流程</span></mark></li></ul></li></ul><h4><a name="软件架构设计" class="md-header-anchor"></a><span>软件架构设计</span></h4><ul><li><p><span>架构设计就是需求分配，即将满足需求的职责分配到组件上</span></p><p><img src="http://qn.qs520.mobi/image-20230217105429397.png" referrerpolicy="no-referrer" alt="image-20230217105429397"><span> </span></p></li><li><p><span>软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式以及这些模式的约束组成。</span></p></li><li><p><span>软件架构是项目干系人进行交流的手段，明确了对系统实现的约束条件，决定了开发和维护组织的组织结构，制约着系统的质量属性。软件架构使推理和控制的更改更加简单，有助于循序渐进的原型设计，可以作为培训的基础。</span></p></li><li><p><span>软件架构是可传递和可复用的模型，通过研究软件架构可能预测软件的质量</span></p></li><li><p><strong><span>架构风格</span></strong></p><ul><li><p><span>架构设计的一个</span><mark><span>核心问题是能否达到架构级的软件复用</span></mark></p></li><li><p><span>架构风格反映了</span><mark><span>领域中众多系统所共有的结构和语义特性，</span></mark><span>并指导如何将各个构件有效地组织成一个完整的系统。</span></p></li><li><p><span>有五种架构风格如下：</span></p><ul><li><span>数据流风格: 批处理序列个处理，顺序结构)、管道/过滤器(数据进出管道都要经过过滤器处理，分阶段的数据处理，常见于网络数据处理)</span></li><li><span>调用/返回风格:主程序/子程序、面向对象风格、层次结构(与上下两层关系切)。</span></li><li><span>独立构件风格:进程通信 (构件之间是独立的，通过消息通信)、事件系统(隐式调用)</span></li><li><span>虚拟机风格:解释器(有虚拟机，可以仿真硬件执行过程，实现解释执行，效率较低，可跨平台)、基于规则的系统。</span></li><li><span>仓库风格(数据共享风格):数据库系统、超文本系统、黑板系统(是一个解决方案的数据库知识源与黑板进行通信，用于没有确定方案的系统)</span></li></ul></li></ul></li><li><p><strong><span>两层c/s架构</span></strong></p><ul><li><p><mark><span>客户端和服务器都有处理功能</span></mark><span>，相比较于传统的集中式软件架构，还是有不少优点的，但是现在已经不常用，原因有:开发成本较高、客户端程序设计复杂、信息内容和形式单一、用户界面风格不一、软件移植困难、软件维护和升级困难、新技术不能轻易应用、安全性问题、服务器端压力大难以复用。</span></p><p><img src="http://qn.qs520.mobi/image-20230217105709103.png" referrerpolicy="no-referrer" alt="image-20230217105709103"><span> </span></p></li></ul></li><li><p><strong><span>三层c/s架构</span></strong></p><ul><li><p><span>将</span><mark><span>处理功能独立出来</span></mark><span>。表示层在客户机上，功能层在应用服务器上，数据层在数据库服务器上。其优点下面四点:</span></p></li><li><p><span>各层在逻辑上保持相对独立，整个系统的逻辑结构更为清晰，能提高系统和软件的可维护性和可扩展性;</span></p><ul><li><p><span>允许灵活有效的选用相应的平台和硬件系统，具有良好的可升级性和开放性;</span></p></li><li><p><span>各层可以并行开发，各层也可以选择各自最适合的开发语言;</span></p></li><li><p><span>功能层有效的隔离表示层与数据层，为严格的安全管理奠定了坚实的基础，整个系统的管理层次也更加合理和可控制。</span></p></li><li><p><span>三层c/s架构</span><mark><span>设计的关键在于各层之间的通信效率</span></mark><span>要慎重考虑三层间的通信方法、通信频度和数据量否则即使分配给各层的硬件能力很强，性能也不高</span></p><p><img src="http://qn.qs520.mobi/image-20230217110015799.png" referrerpolicy="no-referrer" alt="image-20230217110015799"><span> </span></p></li></ul></li></ul></li><li><p><span>三层B/S架构</span></p><ul><li><span>是三层C/S架构的变种，</span><mark><span>将客户端变为用户客户端上的浏览器将应用服务器变为网络上的WEB服务器又称为0客户端架构</span></mark><span>，虽然不用开发客户端，但有很多缺点，主要是数据处理能力差:</span></li><li><span>B/S架构缺乏对动态页面的支持能力，没有集成有效的数据库处理功能</span></li><li><span>安全性难以控制;</span></li><li><span>在数据查询等响应速度上，要远远低于C/S架构</span></li><li><span>数据提交一般以页面为单位，数据的动态交互性不强，不利于OLTP应用</span></li></ul></li></ul><h4><a name="结构化设计" class="md-header-anchor"></a><span>结构化设计</span></h4><ul><li><p><span>系统设计(</span><strong><span>这里的结构化设计就是系统设计的一种</span></strong><span>)主要目的:为系统制定蓝图，在各种技术和实施方法中权衡利弊精心设计，合理地使用各种资源，</span><mark><span>最终勾画出新系统的详细设计方法</span></mark></p></li><li><p><span>系统设计方法: </span><mark><span>结构化设计方法，面向对象设计方法</span></mark></p></li><li><p><span>系统设计的主要内容: </span><mark><span>概要设计、详细设计</span></mark></p><ul><li><strong><span>概要设计</span></strong><span>基本任务: 又称为</span><mark><span>系统总体结构设计</span></mark><span>是将系统的功能需求分配给软件模块，确定</span><mark><span>每个模块的功能和调用关系</span></mark><span>，</span><mark><span>形成软件的模块结构图，即系统结构图</span></mark></li><li><strong><span>详细设计</span></strong><span>的基本任务: </span><mark><span>模块内详细算法设计模块内数据结构设计、数据库的物理设计、其他设计 (代码、输入/输出格式、用户界面)</span></mark><span>、编写详细设计说明书、评审。</span></li></ul></li><li><p><span>一个模块应该具备以下</span><mark><span>四点要素</span></mark><span>：</span></p><ul><li><strong><span>输入和输出</span></strong><span>。模块的输入来源和输出去向都是同一个调用者，即一个模块从调用者那儿取得输入，进行加工后再把输出返回调用者。</span></li><li><strong><span>处理功能</span></strong><span>。指模块把输入转换成输出所做的工作。</span></li><li><strong><span>内部数据</span></strong><span>。指仅供该模块本身引用的数据。</span></li><li><strong><span>程序代码</span></strong><span>。指用来实现模块功能的程序。前两个要素是模块的外部特性，即反映了模块的外貌:后两个要素是模块的内部特性。在结构化设计中，主要考虑的是模块的外部特性，其内部特性只做必要了解，具体的实现将在系统实施阶段完成。</span></li></ul></li><li><p><mark><span>系统设计基本原理</span></mark></p><ul><li><span>抽象化; </span></li><li><span>自顶而下，逐步求精;</span></li><li><span>信息隐蔽</span></li><li><span>模块独立(高内聚，低耦合)。</span></li></ul></li><li><p><mark><span>系统设计原则</span></mark></p><ul><li><span>保持模块的大小适中</span></li><li><span>尽可能减少调用的深度</span></li><li><span>多扇入，少扇出;</span></li><li><span>单入口，单出口;</span></li><li><span>模块的作用域应该在模块之内;</span></li><li><span>功能应该是可预测的。</span></li></ul></li><li><p><strong><span>系统设计基本原理</span></strong><span>(考点): 抽象、模块化、信息隐蔽、模块独立衡量模块独立程度的标准有两个: </span><mark><span>耦合性和内聚性</span></mark><span>。内聚程度从低到高如下表所示：</span></p><p><img src="http://qn.qs520.mobi/image-20230217114248046.png" referrerpolicy="no-referrer" alt="image-20230217114248046"><span> </span></p></li><li><p><strong><span>耦合程度从低到高如下图所示</span></strong><span>(考点)</span></p><p><img src="http://qn.qs520.mobi/image-20230217114325860.png" referrerpolicy="no-referrer" alt="image-20230217114325860"><span> </span></p></li></ul><h4><a name="面向对象设计" class="md-header-anchor"></a><span>面向对象设计</span></h4><ul><li><p><strong><span>面向对象的设计</span></strong><span>: 是</span><mark><span>设计分析模型和实现相应源代码</span></mark><span>，设计问题域的解决方案，与技术相关。OOD同样应遵循抽象、信息隐蔽、功能独立、模块化等设计准则。</span></p></li><li><p><span>面向对象的</span><mark><span>分析模型</span></mark><span>主要</span><mark><span>由顶层架构图、用例与用例图、领域概念模型构成</span></mark><span>，</span><mark><span>设计模型</span></mark><span>则</span><mark><span>包含以包图表示的软件体系结构图、以交互图表示的用例实现图.完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230217121230412.png" referrerpolicy="no-referrer" alt="image-20230217121230412"><span> </span></p></li><li><p><strong><span>面向对象的设计原则</span></strong><span>:</span></p><ul><li><span>(1)</span><mark><span>单一责任原则</span></mark><span>。就一个类而言，应该</span><mark><span>仅有一个引起它变化的原因</span></mark><span>。，即，当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。</span></li><li><span>(2)</span><mark><span>开放 - 封闭原则</span></mark><span>。软件实体 (类、模块、函数等)应该是</span><mark><span>可以扩展的，即开放的;但是不可修改的，即封闭的</span></mark></li><li><span>(3)</span><mark><span>里氏替换原则</span></mark><span>。</span><mark><span>子类型必须能够替换掉他们的基类型</span></mark><span>。即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用</span></li><li><span>(4)</span><mark><span>依赖倒置原则</span></mark><span>。</span><mark><span>抽象不应该依赖于细节，细节应该依赖于抽象</span></mark><span>。即，高层模块不应该依赖于低层模块，二者都应该依赖于抽象。</span></li><li><span>(5)</span><mark><span>接口分离原则</span></mark><span>。不应该强迫客户依赖于它们不用的方法。接口属于客户不属于它所在的类层次结构。即: </span><mark><span>依赖于抽象，不要依赖于具体</span></mark><span>，同时在抽象级别不应该有对于细节的依赖。这样做的好处就在于可以最大限度地应对可能的变化。</span></li></ul></li></ul><h4><a name="设计模式" class="md-header-anchor"></a><span>设计模式</span></h4><ul><li><p><span>架构模式: 软件设计中的</span><mark><span>高层决策</span></mark><span>，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策。</span></p></li><li><p><span>设计模式: 每一个设计模式描述了一个在我们周围</span><mark><span>不断重复发生的问题，以及该问题的解决方案的核心</span></mark><span>。这样，你就能一次又一次地使用该方案而不必做重复劳动设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便的复用成功的的设计和体系结构</span><mark><span>四个基本要素: 模式名称、问题(应该在何时使用模式), 解决方案 (设计的内容)、效果 (模式应用的效)</span></mark></p></li><li><p><span>惯用法: 是最低层的模式，关注</span><mark><span>软件系统的设计与实现，实现时通过某种特定的程序设计语言</span></mark><span>来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法。</span></p></li><li><p><span>属于类行为模式的只有：</span><mark><span>创建型里的工厂方法，结构型里的适配器，行为型里的解释器，模板方法模式</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230220104144269.png" referrerpolicy="no-referrer" alt="image-20230220104144269"><span> </span></p><p><img src="http://qn.qs520.mobi/image-20230220104426613.png" referrerpolicy="no-referrer" alt="image-20230220104426613"><span> </span></p></li></ul><h4><a name="人机界面设计" class="md-header-anchor"></a><span>人机界面设计</span></h4><ul><li><p><span>人机界面设计三大黄金原则：</span></p><p><img src="http://qn.qs520.mobi/image-20230220104543609.png" referrerpolicy="no-referrer" alt="image-20230220104543609"><span> </span></p></li></ul><h2><a name="span-id14系统实施与维护14系统实施与维护案例分析考点3-2span" class="md-header-anchor"></a><span id="14.系统实施与维护"><span>14.系统实施与维护(案例分析考点3-2)</span></span></h2><h4><a name="测试原则和方法" class="md-header-anchor"></a><span>测试原则和方法</span></h4><ul><li><p><span>系统测试是</span><mark><span>为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试</span></mark></p></li><li><p><span>测试原则:</span></p><ul><li><span>应尽早并不断的进行测试:</span></li><li><span>测试工作应该避免由原开发软件的人或小组承担;在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期的输出结果;</span></li><li><span>既包含有效、合理的测试用例，也包含不合理、失效的用例;</span></li><li><span>检验程序是否做了该做的事，且是否做了不该做的事;</span></li><li><span>严格按照测试计划进行;</span></li><li><span>妥善保存测试计划和测试用例;</span></li><li><span>测试用例可以重复使用或追加测试</span></li></ul></li><li><p><span>软件测试方法可分为</span><mark><span>静态测试和动态测试</span></mark><span>。</span></p><ul><li><p><span>静态测试: 指被测试程序</span><mark><span>不在机器上运行</span></mark><span>，而采用</span><mark><span>人工检测和计算机辅助静态分析的手段</span></mark><span>对程序进行检测，包括对文档的静态测试和对代码的静态测试。对文档的静态测试主要以</span><mark><span>检查单</span></mark><span>的形式进行，而对代码的静态测试，包括</span><mark><span>桌前检查、代码审查、代码走查</span></mark><span>的方式。使用这种方法能够有效地发现30%-70%的逻辑设计和编码错误。</span></p></li><li><p><span>动态测试: 指在计算机上</span><mark><span>实际运行程序</span></mark><span>进行软件测试，一般采用</span><mark><span>白盒测试和黑盒测试</span></mark><span>方法</span></p><ul><li><span>黑盒测试法: </span><mark><span>功能性测试</span></mark><span>，不了解软件代码结构，根据功能设计用例，测试软件功能。</span></li><li><span>白盒测试法: </span><mark><span>结构性测试</span></mark><span>，明确代码流程，根据代码逻辑设计用例，进行用例覆盖。</span></li></ul></li></ul></li></ul><h4><a name="测试阶段" class="md-header-anchor"></a><span>测试阶段</span></h4><ul><li><p><span>(1)</span><mark><span>单元测试</span></mark><span>:也称为模块测试，测试的对象是</span><mark><span>可独立编译或汇编的程序模块</span></mark><span>软件构件或00软件中的类(统称为模块)，测试依据是</span><mark><span>软件详细设计说明书</span></mark></p></li><li><p><span>(2)</span><mark><span>集成测试</span></mark><span>:目的是</span><mark><span>检查模块之间，以及模块和已集成的软件之间的接口关系</span></mark><span>，并验证已集成的软件是否符合设计要求。测试依据是</span><mark><span>软件概要设计文档</span></mark></p></li><li><p><span>(3)</span><mark><span>确认测试</span></mark><span>: 主要用于</span><mark><span>验证软件的功能</span></mark><span>、</span><mark><span>性能和其他特性是否与用户需求一致。</span></mark><span>根据用户的参与程度，通常包括以下类型:</span></p><ul><li><span>内部确认测试:主要由</span><mark><span>软件开发组织内部按照SRS(软件需求规格说明书)进行测试</span></mark></li><li><span>Alpha测试: </span><mark><span>用户在开发环境</span></mark><span>下进行测试。</span></li><li><span>Beta测试: </span><mark><span>用户在实际使用环境</span></mark><span>下进行测试，通过改测试后，产品才能交付用户,</span></li><li><span>验收测试: </span><mark><span>针对SRS，在交付前以用户为主进行的测试</span></mark><span>。其测试对象为完整的、集成的计算机系统。验收测试的目的是，在真实的用户工作环境下，检验软件系统是否满足开发技术合同或SRS。验收测试的结论是用户确定是否接收该软件的主要依据。除应满足一般测试的准入条件外，在进行验收测试之前，应确认被测软件系统已通过系统测试。</span></li></ul></li><li><p><span>(4)</span><mark><span>系统测试</span></mark><span>: </span><mark><span>测试对象是完整的、集成的计算机系统</span></mark><span>;测试的目的是在真实系统工作环境下，验证完成的软件配置项能否和系统正确连接，并满足系统/子系统设计文档和软件开发合同规定的要求。</span><mark><span>测试依据是用户需求或开发合同</span></mark><span>.。主要内容包括功能测试、健壮性测试、性能测试、用户界面测试、安全性测试安装与反安装测试等，其中，最重要的工作是进行</span><mark><span>功能测试与性能测试</span></mark><span>。</span><mark><span>功能测试主要采用黑盒测试方法;性能测试主要指标有响应时间、吞吐量、并发用户数和资源利用率等</span></mark></p></li><li><p><span>(5)</span><mark><span>配置项测试</span></mark><span>:</span><mark><span>测试对象是软件配置项</span></mark><span>，测试目的是</span><mark><span>检验软件配置项与SRS的一致性</span></mark><span>。测试的依据是SRS。在此之间，应确认被测软件配置项已通过单元测试和集成测试。</span></p></li><li><p><span>(6)</span><mark><span>回归测试</span></mark><span>:测试目的是</span><mark><span>测试软件变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性</span></mark></p></li><li><p><span>测试顺序：单元测试 -&gt; 集成测试 -&gt; 系统测试 -&gt; 确认测试 </span></p></li></ul><h4><a name="系统实施与测试" class="md-header-anchor"></a><span>系统实施与测试</span></h4><ul><li><p><span>测试策略</span></p><ul><li><span>自底向上: 从最</span><mark><span>底层模块开始测试，需要编写驱动程序</span></mark><span>而后开始逐一合并模块，最终完成整个系统的测试。优点是</span><mark><span>较早的验证了底层模块</span></mark></li><li><span>自顶向下: </span><mark><span>先测试整个系统，需要编写桩程序，而后逐步向下直至最后测试最底层模块。优点是较早的验证了系统的主要控制和判断点</span></mark></li><li><span>三明治: 既有自底向上也有自顶向下的测试方法，</span><mark><span>二者都包括。兼有二者的优点，缺点是测试工作量大。</span></mark></li></ul></li><li><p><mark><span>黑盒测试用例</span></mark><span>: 将程序看做一个黑盒子，只知道输入输出，不知道内部代码由此设计出测试用例，分为下面几类:</span></p><ul><li><mark><span>等价类划分</span></mark><span>: 把所有的数据按照某种特性进行归类，而后在每类的数据里选取一个即可。等价类测试用例的设计原则: </span><mark><span>设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类</span></mark><span>，重复这一步，直到所有的有效等价类都被覆盖为止;  </span><mark><span>设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类</span></mark><span>，重复这一步，直到所有的无效等价类都被覆盖为止</span></li><li><span>边界值划分: 将每类的边界值作为测试用例，</span><mark><span>边界值一般为范围的两端值以及在此范围之外的与此范围间隔最小的两个值</span></mark><span>，如年龄范围为0-150，边界值为0,150，-1,151四个</span></li><li><span>错误推测: 没有固定的方法，凭经验而言，来推测有可能产生问题的地方作为测试用例进行测试。</span></li><li><span>因果图:由一个结果来反推原因的方法，具体结果具体分析，没有固定方法</span></li></ul></li><li><p><mark><span>白盒测试用例</span></mark><span>: 知道程序的代码逻辑，按照程序的代码语句，来设计覆盖代码分支的测试用例，覆盖级别从低至高分为下面几种:</span></p><ul><li><p><span>(1) </span><mark><span>语句覆盖SC</span></mark><span>: 逻辑代码中的</span><mark><span>所有语句都要被执行一遍，覆盖层级最低</span></mark><span>，因为执行了所有的语句，不代表执行了所有的条件判断。是否执行所有语句</span></p></li><li><p><span>(2)</span><mark><span>判定覆盖DC</span></mark><span>: 逻辑代码中的</span><mark><span>所有判断语句的条件的真假分支都要覆盖一次</span></mark><span>， 是否把所有判定都判断了</span></p><p><img src="http://qn.qs520.mobi/image-20230220115443437.png" referrerpolicy="no-referrer" alt="image-20230220115443437"><span> </span></p></li><li><p><span>(3</span><mark><span>)条件覆盖CC</span></mark><span>: </span><mark><span>针对每一个判断条件内的每一个独立条件都要执行一遍真和假</span></mark><span>。是否把所有条件都判断了</span></p></li><li><p><span>(4)</span><mark><span>条件判定组合覆盖CDC</span></mark><span>: </span><mark><span>同时满足判定覆盖和条件覆盖</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230220115617355.png" referrerpolicy="no-referrer" alt="image-20230220115617355"><span> </span></p></li><li><p><span>(5)</span><mark><span>路径覆盖</span></mark><span>: </span><mark><span>逻辑代码中的所有可行路径都覆盖了，覆盖层级最高</span></mark><span>，是否走了所有路线</span></p><p><img src="http://qn.qs520.mobi/image-20230220115657644.png" referrerpolicy="no-referrer" alt="image-20230220115657644"><span> </span></p></li></ul></li></ul><h4><a name="调试" class="md-header-anchor"></a><span>调试</span></h4><ul><li><span>测试是发现错误，调试是</span><mark><span>找出错误的代码和原因</span></mark></li><li><span>调试需要</span><mark><span>确定错误的准确位置:确定问题的原因并设法改正;改正后要进行回归测试</span></mark></li><li><span>调试的方法有: </span><mark><span>蛮力法，回溯法</span></mark><span>(从出错的地方开始，向回找) 、</span><mark><span>原因排除法</span></mark><span>(找出所有可能的原因，逐一进行排除，具体包括演绎法、归纳法、二分法)。</span></li></ul><h4><a name="软件度量" class="md-header-anchor"></a><span>软件度量</span></h4><ul><li><p><mark><span>软件的两种属性</span></mark><span>: </span><mark><span>外部属性指面向管理者和用户的属性，可直接测量，一般为性能指标</span></mark><span>。</span><mark><span>内部属性</span></mark><span>指</span><mark><span>软件产品本身的的属性，如可靠性等，只能间接测量</span></mark></p></li><li><p><mark><span>McCabe度量法(考点)</span></mark><span>: 又称为</span><mark><span>环路复杂度</span></mark><span>，</span><mark><span>假设有向图中有向边数为m，:节点数为n则此有向图的环路复杂度为m-n+2</span></mark><span>， 边数就是有多少个步骤，节点就是有多少个节点</span></p><p><img src="http://qn.qs520.mobi/image-20230220171415521.png" referrerpolicy="no-referrer" alt="image-20230220171415521"><span> </span></p></li><li><p><span>注意m和n代表的含义不能混淆，可以用一个最简单的环路来做特殊值记忆此公式，另外，针对一个程序流程图，每一个分支边(连线)就是一条有向边，每一条语句(语句框)就是一个顶点。</span></p></li></ul><h4><a name="系统运行和维护" class="md-header-anchor"></a><span>系统运行和维护</span></h4><ul><li><p><strong><span>遗留系统</span></strong><span>是指任何基本上</span><mark><span>不能进行修改和演化以满足新的变化了的业务需求的信息系统</span></mark><span>，它通常具有以下特点:</span></p></li><li><p><span>(1)系统虽然完成企业中许多重要的业务管理工作，但仍然</span><mark><span>不能完全满足要求</span></mark><span>。一般实现业务处理电子化及部分企业管理功能，很少涉及经营决策。</span></p></li><li><p><span>(2)系统在性能上已经落后，采用的</span><mark><span>技术已经过时</span></mark><span>。例如多采用主机/终端形式或小型机系统，软件使用汇编语言或第三代程序设计语言的早期版本开发，使用文件系统而不是数据库。</span></p></li><li><p><span>(3)通常是大型的软件系统，已经融入企业的业务运作和决策管理机制之中，</span><mark><span>维护工作十分困难</span></mark></p></li><li><p><span>(4)没有使用现代信息系统建设方法进行管理和开发，现在基本上已经没有文档，</span><mark><span>很难理解</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230220120230858.png" referrerpolicy="no-referrer" alt="image-20230220120230858"><span> </span></p></li><li><p><span>新老系统转换是指</span><mark><span>新系统开发完毕，投入运行，取代现有系统的过程</span></mark><span>。需要考虑多方面的问题，以实现与老系统的交接，有以下三种转换计划:</span></p><ul><li><mark><span>直接转换</span></mark><span>: </span><mark><span>现有系统被新系统直接取代了</span></mark><span>，</span><mark><span>风险很大</span></mark><span>，适用于新系统不复杂，业务量小或者现有系统已经不能使用的情况。优点是</span><mark><span>成本低，效率高。缺点是风险极大</span></mark><span>。</span></li><li><mark><span>并行转换</span></mark><span>: </span><mark><span>新系统和老系统并行工作一段时间</span></mark><span>，新系统经过试运行后再取代若新系统在试运行过程中有问题，也不影响现有系统的运行，</span><mark><span>风险极小</span></mark><span>，在试运行过程中还可以比较新老系统的性能，</span><mark><span>适用于大型系统</span></mark><span>。</span><mark><span>优点是风险小，有过渡，适合大型系统。缺点是成本高，耗费人力和时间资源，难以控制两个系统间的数据转换</span></mark></li><li><mark><span>分段转换</span></mark><span>: </span><mark><span>分期分批逐步转换</span></mark><span>，是直接和并行转换的集合，</span><mark><span>将大型系统分为多个子系统</span></mark><span>，依次试运行每个子系统，成熟一个子系统，就转换一个子系统。同样适用于大型项目，只是更耗时，而且现有系统和新系统间混合使用，需要协调好接口等问题。</span><mark><span>优点是风险较小，结合了以上两种的优点。缺点是兼容性较差, 更耗时</span></mark></li></ul></li><li><p><mark><span>数据转换与迁移</span></mark><span>: 将数据从旧数据库迁移到新数据库中。有三种方法: </span><mark><span>1. 系统切换前通过工具迁移、2. 系统切换前采用手工录入、3.系统切换后通过新系统生成</span></mark></p><ul><li><p><span>数据迁移前的</span><mark><span>准备工作</span></mark><span>包括:</span></p><ol start='' ><li><mark><span>待迁移数据源的详细说明</span></mark><span>，包括数据的存放方式、数据量和数据的时间跨度。</span></li><li><span>建立</span><mark><span>新旧系统数据库的数据字典</span></mark><span>，对现有系统的历史数据进行质量分析，以及新旧系统</span><mark><span>数据结构</span></mark><span>的差异分析。</span></li><li><span>新旧系统代码</span><mark><span>数据的差异分析</span></mark><span>.</span></li><li><span>建立新旧系统</span><mark><span>数据库表的映射关系</span></mark><span>，对无法映射字段的处理方法</span></li><li><span>开发或购买、部署ETL工具。</span></li><li><span>编写数据转换的</span><mark><span>测试计划和校验程序</span></mark></li><li><span>制定</span><mark><span>数据转换的应急措施</span></mark><span>。</span></li></ol></li><li><p><span>数据迁移后的校验: </span><mark><span>对迁移后的数据进行质量分析;新旧系统查询数据对比检查</span></mark></p></li></ul></li><li><p><span>系统的</span><mark><span>可维护性</span></mark><span>可以定义为</span><mark><span>维护人员理解、改正、改动和改进这个软件的难易程度</span></mark><span>，其评价指标如下:</span></p><ul><li><span>(1)</span><mark><span>易分析性</span></mark><span>。软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。</span></li><li><span>(2)</span><mark><span>易改变性</span></mark><span>。软件产品使指定的修改可以被实现的能力，实现包括编码、设计和文档的更改。</span></li><li><span>(3)</span><mark><span>稳定性</span></mark><span>。软件产品避免由于软件修改而造成意外结果的能力。</span></li><li><span>(4)</span><mark><span>易测试性</span></mark><span>。软件产品使已修改软件能被确认的能力。</span></li><li><span>(5)</span><mark><span>维护性的依从性</span></mark><span>。软件产品遵循与维护性相关的标准或约定的能力</span></li></ul></li><li><p><span>系统维护包括</span><mark><span>硬件维护、软件维护和数据维护</span></mark><span>，其中</span><mark><span>软件维护类型如下</span></mark></p><ul><li><mark><span>改正性维护(纠错性)</span></mark><span>:发现了bug而进行的修改。</span></li><li><mark><span>适应性维护</span></mark><span>:由于</span><mark><span>外部环境发生了改变</span></mark><span>，被动进行的对软件的修改和升级。</span></li><li><mark><span>完善性维护</span></mark><span>:基于用户主动对软件提出更多的需求，修改软件，增加更多的功能，使其比之前的软件功能、性能更高，更加完善。</span></li><li><mark><span>预防性维护</span></mark><span>:对未来可能发生的bug进行预防性的修改。</span></li><li><img src="http://qn.qs520.mobi/image-20230301142015554.png" referrerpolicy="no-referrer" alt="image-20230301142015554"><span> </span></li></ul></li><li><p><span>系统评价分类</span></p><ul><li><span>立项评价:系统开发前的预评价，分析是否立项开发，做可行性评价</span></li><li><span>中期评价:项目开发中期每个阶段的阶段评审。或者项目在开发中途遇到重大变故，评价是否还要继续。</span></li><li><span>结项评价:系统投入正式运行后，了解系统是否达到预期的目的和要求而对系统进行的综合评价。</span></li></ul></li><li><p><span>系统评价的指标</span></p><ul><li><span>(1)从信息系统的组成部分出发，信息系统是一个由人机共同组成的系统，所以可以按照</span>
<span>运行效果和用户需求(人)、系统质量和技术条件(机)这两条线索构造指标。</span></li><li><span>(2)从信息系统的评价对象出发，对于开发方来说，他们所关心的是系统质量和技术水平:对于用户方而言，关心的是用户需求和运行质量:系统外部环境则主要通过社会效益指标来反映。</span></li><li><span>(3)从经济学角度出发，分别按</span><mark><span>系统成本、系统效益和财务指标</span></mark><span>3条线索建立指标</span></li></ul></li></ul><h2><a name="span-id15项目管理15项目管理案例分析考点3-1span" class="md-header-anchor"></a><span id="15.项目管理"><span>15.项目管理(案例分析考点3-1)</span></span></h2><p><mark><span>通读教材: 第15章 系统运行与维护;第19章 系统可靠性分析与设计</span></mark></p><h4><a name="范围管理" class="md-header-anchor"></a><span>范围管理</span></h4><ul><li><p><span>范围管理确定在项目内</span><mark><span>包括什么工作和不包括什么工作</span></mark><span>，由此</span><mark><span>界定的项目范围</span></mark><span>在项目的全生命周期内可能因种种原因而变化，项目范围管理</span><mark><span>也要管理项目范围的这种变化。项目范围的变化也叫变更</span></mark></p></li><li><p><span>对项目范围的管理，是通过5个管理过程来实现的:</span></p><ul><li><span>(1)规划范围管理(编制范围管理计划)。对</span><mark><span>如何定义、确认和控制项目范围的过程进行描述。</span></mark></li><li><span>(2)定义范围。</span><mark><span>详细描述产品范围和项目范围，编制项目范围说明书</span></mark><span>，作为以后项目决策的基础。其输入包括: </span><mark><span>项目章程。项目范围管理计划。组织过程资产批准的变更申请。</span></mark></li><li><span>(3)创建工作分解结构。把整个项目工作</span><mark><span>分解为较小的、易于管理的组成部分</span></mark><span>形成一个</span><mark><span>自上而下</span></mark><span>的分解结构。</span></li><li><span>(4)确认范围。</span><mark><span>正式验收已完成的可交付成果</span></mark></li><li><span>(5)范围控制。</span><mark><span>监督</span></mark><span>项目和产品的范围状态、管理范围基准变更</span></li></ul></li><li><p><span>产品范围和项目范围</span></p><ul><li><strong><span>产品范围</span></strong><span>是指</span><mark><span>产品或者服务所应该包含的功能</span></mark><span>。产品范围是否完成，要</span><mark><span>根据产品是否满足了产品描述</span></mark><span>来判断。</span><mark><span>产品范围是项目范围的基础</span></mark><span>，产品范围的定义</span><mark><span>是产品要求的描述</span></mark></li><li><strong><span>项目范围</span></strong><span>是指</span><mark><span>为了能够交付产品，项目所必须做的工作</span></mark><span>。项目范围的定义是</span><mark><span>产生项目管理计划的基础</span></mark><span>。判断项目范围是否完成，要以</span><mark><span>范围基准来衡量</span></mark><span>。项目的范围基准</span><mark><span>是经过批准的项目范围说明书、WBS和WBS词典</span></mark></li><li><mark><span>产品范围描述是项目范围说明书的重要组成部分</span></mark><span>，因此，产品范围变更后，首先受到影响的是项目的范围。</span></li></ul></li><li><p><mark><span>WBS(工作分解结构)</span></mark><span>将项目整体或者主要的可交付成果分解成容易管理、方便控制的若干个子项目或者</span><mark><span>工作包</span></mark><span>，</span><mark><span>子项目需要继续分解为工作包</span></mark><span>，持续这个过程，</span><mark><span>直到整个项目部分解为可管理的工作包，这些工作包的总和是项目的所有工作范围</span></mark><span>。最普通的WBS 如下表所示:</span></p><p><img src="http://qn.qs520.mobi/image-20230220182927103.png" referrerpolicy="no-referrer" alt="image-20230220182927103"><span> </span></p></li></ul><h4><a name="进度管理" class="md-header-anchor"></a><span>进度管理</span></h4><ul><li><p><span>进度管理(时间管理)就是采用科学的方法，确定进度目标，编制进度计划和资源供应计划，进行进度控制，在与质量、成本目标协调的基础上，</span><mark><span>实现工期目标</span></mark><span>。</span></p></li><li><p><span>具体来说，包括以下过程:</span></p><ul><li><strong><span>活动定义</span></strong><span>: 确定</span><mark><span>完成项目各项可交付成果而需要开展的具体活动</span></mark></li><li><strong><span>活动排序</span></strong><span>:识别和记录</span><mark><span>各项活动之间的先后关系和逻辑关系</span></mark><span>。</span></li><li><strong><span>活动资源估算</span></strong><span>: 估算完成</span><mark><span>各项活动所需要的资源类型和效益</span></mark></li><li><strong><span>活动历时估算</span></strong><span>: 估算完成</span><mark><span>各项活动所需要的具体时间</span></mark><span>。</span></li><li><strong><span>进度计划编制</span></strong><span>: 分析活动顺序、活动持续时间、资源要求和进度制约因素，</span><mark><span>制订项目进度计划。</span></mark></li><li><strong><span>进度控制</span></strong><span>: 根据进度计划开展项目活动，</span><mark><span>如果发现偏差，则分析原因或进行调整</span></mark></li></ul></li><li><p><span>进行</span><mark><span>活动资源估算的方法</span></mark><span>主要有</span><mark><span>专家判断法、替换方案的确定、公开的估算数据、估算软件和自下而上的估算</span></mark></p><ul><li><span>(1)</span><strong><span>专家判断法</span></strong><span>。专家判断法通常是</span><mark><span>由项目管理专家根据以往类似项目经的验和对本项目的判断</span></mark><span>，经过周密思考，进行合理预测，从而估算出项目资源。</span></li><li><span>(2)</span><strong><span>替换方案的确定</span></strong><span>。资源估算是为了给项目预算明确空间，为早期的资源筹备提供数据，如果</span><mark><span>某项活动存在替代方案，或提供的资源有替代支持可能</span></mark><span>，则需要明确声明。</span></li><li><span>(3)</span><strong><span>公开的估算数据</span></strong><span>。有些公司会</span><mark><span>定期地公开一些生产率或人工费率数据</span></mark><span>，其中包括很多国家和地区的劳动力交易、材料和设备信息。</span></li><li><span>(4)</span><strong><span>估算软件</span></strong><span>。依靠软件的强大功能，可以定义资源可用性、费率，以及不同的资源日历。</span>
<span>(5)</span><strong><span>自下而上的估算</span></strong><span>。把复杂的活动</span><mark><span>分解为更小的工作</span></mark><span>，以便于资源估算。将每项工作所需要的资源估算出来，然后汇总即是整个活动所需要的资源数量。</span></li></ul></li><li><p><strong><span>COCOMO模型</span></strong><span>: 常见的软件规模估算方法。常用的</span><mark><span>代码行分析方法</span></mark><span>作为其中一种度量估计单位，以代码行数估算出每个程序员工作量，累加得软件成本模型按其详细程度可以分为三级:</span></p><ul><li><span>(1)</span><mark><span>基本COCOMO模型</span></mark><span>是一个</span><mark><span>静态单变量模型</span></mark><span>，它用一个以已估算出来的</span><mark><span>原代码行数(LOC)为自变量</span></mark><span>的经验函数计算软件开发工作量。</span></li><li><span>(2)</span><mark><span>中间COCOMO模型</span></mark><span>在基本COCOMO模型的基础上，再用</span><mark><span>涉及产品、硬件人员、项目等方面的影响因素</span></mark><span>调整工作量的估算。</span></li><li><span>(3)</span><mark><span>详细COCOMO模型</span></mark><span>包括中间COCOMO模型的所有特性，将软件系统模型分为</span><mark><span>系统、子系统和模块</span></mark><span>3 个层次，</span><mark><span>更进一步考虑了软件工程中每一步骤(如分析设计) 的影响。</span></mark></li></ul></li><li><p><strong><span>COCOMOⅡ模型</span></strong><span>: COCOMO的升级，也是以软件规模作为成本的主要因素考虑多个成本驱动因子。该方法包括三个阶段性模型，即</span><mark><span>应用组装模型、早期设计阶段模型和体系结构阶段模型</span></mark><span>。包含三种不同规模估算选择: </span><mark><span>对象点、功能点和代码行</span></mark></p></li><li><p><span>进度安排的常用图形描述方法有</span><mark><span>Gantt 图(甘特图)</span></mark><span>和</span><mark><span>项目计划评审技术(Program Evaluation&amp; Review Technique，PERT)图</span></mark><span>:</span></p><ul><li><p><span>甘特图：反应了任务之间的并行关系，可以同时进行，不能反映依赖关系</span></p></li><li><p><span>PERT图：不反应任务之间的并行关系 反应的是</span><mark><span>任务之间的依赖关系</span></mark></p><ul><li><span>基于f-s的依赖关系(f-s, finish-start)</span></li></ul></li></ul><p><img src="http://qn.qs520.mobi/image-20230220185735704.png" referrerpolicy="no-referrer" alt="image-20230220185735704"><span> </span></p></li><li><p><strong><span>关键路径法</span></strong></p><ul><li><p><span>关键路径: 是项目的</span><mark><span>最短工期，但却是从开始到结束时间最长的路径</span></mark><span>。进度网络图中可能有多条关键路径，因为活动会变化，因此关键路径也在不断变化中关键活动:关键路径上的活动，最早开始时间=最晚开始时间。通常，，每个节点的活动会有如下几个时间:</span></p><ul><li><span>(1)</span><mark><span>最早开始时间 (ES: Earliest start)</span></mark><span>某项活动能够开始的最早时间。</span></li><li><span>(2)</span><mark><span>最早结束时间(EF: Earliest finish)</span></mark><span>某项活动能够完成的最早时间。</span><mark><span>EF=ES+工期</span></mark></li><li><span>(3)</span><mark><span>最迟结束时间(LE: last end)</span></mark><span>为了使项目按时完成，某项活动必须完成的最迟时间。</span></li><li><span>(4)</span><mark><span>最迟开始时间 (LS: last start)</span></mark><span>。为了使项目按时完成，某项活动必须开始的最迟时间。</span><mark><span>LS=LF-工期</span></mark></li></ul></li><li><p><span>这几个时间通常作为每个节点的组成部分，如图所示:</span></p><ul><li><mark><span>顺推: 最早开始ES=所有前置活动最早完成EF的最大值;  最早完成EF=最早开始ES+持续时间</span></mark></li><li><mark><span>逆推: 最晚完成LF=所有后续活动最晚开始LS的最小值:  最晚开始LS=最晚完成LF-持续时间</span></mark></li></ul><p><img src="http://qn.qs520.mobi/image-20230220190115803.png" referrerpolicy="no-referrer" alt="image-20230220190115803"><span> </span></p></li></ul></li><li><p><strong><span>总浮动时间(总时差，松弛时差)</span></strong><span>: </span><mark><span>在不延误项目完工时间且不违反进度制约因素</span></mark><span>的前提下，活动</span><mark><span>可以从最早开始时间推迟或拖延的时间量</span></mark><span>，就是该活动的进度灵活性。正常情况下，关键活动的总浮动时间为零。</span></p></li><li><p><strong><span>总浮动时间</span></strong><mark><span>=最迟开始LS-最早开始ES 或 最迟完成LF - 最早完成EF 或 关键路径 - 非关键路径时长。</span></mark></p></li><li><p><strong><span>自由浮动时间</span></strong><span>: 是指在</span><mark><span>不延误任何紧后活动的最早开始时间且不违反进度制约因素</span></mark><span>的前提下，活动可以</span><mark><span>从最早开始时间推迟或拖延的时间量</span></mark></p></li><li><p><strong><span>自由浮动时间</span></strong><mark><span>=紧后活动最早开始时间的最小值-本活动的最早完成时间</span></mark></p></li><li><p><strong><span>甘特图解题示例</span></strong></p><p><img src="http://qn.qs520.mobi/image-20230306143558306.png" referrerpolicy="no-referrer" alt="image-20230306143558306"><span> </span></p></li></ul><h4><a name="成本管理" class="md-header-anchor"></a><span>成本管理</span></h4><ul><li><p><span>项目成本管理是在整个项目的实施过程中，为确保项目在批准的预算条件下尽可能保质按期完成，而对所需的各个过程进行管理与控制。</span></p></li><li><p><span>项目成本管理包括</span><mark><span>成本估算、成本预算和成本控制</span></mark><span>三个过程</span></p><ul><li><span>(1)</span><strong><span>成本估算</span></strong><span>是对完成项目</span><mark><span>所需成本的估计和计划</span></mark><span>，是项目计划中的一个重要的、关键的、敏感的部分:成本估算主要靠分解和类推的手段进行，基本估算方法分为三类: </span><mark><span>自顶向下的估算、自底向上的估算和差别估算法</span></mark></li><li><span>(2)</span><strong><span>成本预算</span></strong><span>是</span><mark><span>把估算的总成本分配到项目的各个工作包</span></mark><span>，建立成本基准计划以衡量项目绩效; </span><mark><span>应急储备和管理储备</span></mark></li><li><span>(3)</span><strong><span>成本控制</span></strong><span>保证</span><mark><span>各项工作在各自的预算范围内进行</span></mark></li></ul></li><li><p><strong><span>成本的类型(考点)：</span></strong></p><ul><li><span>(1)</span><strong><span>可变成本</span></strong><span>: 随着</span><mark><span>生产量、工作量或时间而变的</span></mark><span>成本为可变成本。可变成本又称变动成本。</span></li><li><span>(2)</span><strong><span>固定成本</span></strong><span>: </span><mark><span>不随生产量、工作量或时间的变化而变化的非重复成本</span></mark><span>为固定成本。</span></li><li><span>(3)</span><strong><span>直接成本</span></strong><span>: </span><mark><span>直接可以归属于项目工作的成本</span></mark><span>为直接成本。如项目团队差旅费、工资项目使用的物料及设备使用费等。</span></li><li><span>(4)</span><strong><span>间接成本</span></strong><span>: 来自</span><mark><span>一般管理费用</span></mark><span>科目或几个项目共同担负的项目成本所</span><strong><mark><span>分摊</span></mark></strong><span>给本项目的费用，就形成了项目的间接成本，如税金、额外福利和保卫费用等。</span></li><li><span>(5)</span><strong><span>机会成本</span></strong><span>: 是利用一定的时间或资源生产一种商品时，而</span><mark><span>失去利用这些资源生产其他最佳替代品的机会</span></mark><span>就是机会成本,泛指一切在做出选择后其中一个最大的损失。例如有一块地，种水稻赚12万，种小麦赚10万，种果树赚15w，现在选择种小麦，机会成本就是5w</span></li><li><span>(6)</span><strong><span>沉没成本</span></strong><span>: 是指由于过去的决策已经发生了的，而不能由现在或将来的任何决策改变的成本。沉没成本是一种历史成本，对现有决策而言是不可控成本，会很大程度上影响人们的行为方式与决策，</span><mark><span>在投资决策时应排除沉没成本的干扰</span></mark><span>。</span></li><li><strong><span>学习曲线</span></strong><span>: 重复生成产品时，</span><mark><span>产品的单位成本会随着产量的扩大呈现规律性递减</span></mark><span>。估算成本时，也要考虑此因素</span></li></ul></li><li><p><strong><span>成本计算(考到要写公式)</span></strong></p><ul><li><p><span>实例场景分析: </span></p><ul><li><span>总规划:10天造100张桌子，完工预算为10000元</span></li><li><span>详细计划:每天造10张桌子，每张桌子的预算为100元，每天花费1000元</span></li></ul></li><li><p><span>现在是第5天结束了，预算及执行情况按计划应该造50张桌子，花费预算5000元实际造了30张桌子，实际花费了4500元</span></p></li><li><p><span>系分教材成本与最新成本术语对比:</span></p><ul><li><p><mark><span>BCWS (计划工作量的预算费用) =总的是BAC，阶段性的是PV</span></mark></p></li><li><p><span>ACWP(已完成工作量的实际费用)=AC</span></p></li><li><p><span>BCWP(已完成工作量的预算成本)=EV</span></p></li><li><p><span>其他SV CV SPICPIETCEAC，一样</span></p><p><img src="http://qn.qs520.mobi/image-20230308120914929.png" referrerpolicy="no-referrer" alt="image-20230308120914929"><span> </span></p></li></ul></li></ul></li><li><h4><a name="时标网络图" class="md-header-anchor"></a><span>时标网络图</span></h4><ul><li><img src="http://qn.qs520.mobi/image-20230308144522124.png" referrerpolicy="no-referrer" alt="image-20230308144522124"><span> </span></li></ul></li></ul><h4><a name="软件配置管理考点" class="md-header-anchor"></a><span>软件配置管理(考点)</span></h4><ul><li><p><strong><span>配置管理</span></strong><span>是为了</span><mark><span>系统地控制配置变更</span></mark><span>在系统的</span><mark><span>整个生命周期中维持配置的完整性和可跟踪性</span></mark><span>，而标识系统在不同时间点上配置的学科。</span></p></li><li><p><span>在GB/T11457-2006中将“配置管理”正式定义为:“应用技术的和管理的指导和监控方法以</span><mark><span>标识和说明配置项的功能和物理特征</span></mark><span>，控制这些特征的变更，记录和报告变更处理和实现状态并验证与规定的需求的遵循性。</span></p></li><li><p><span>配置管理包括</span><mark><span>6个主要活动</span></mark><span>: 制订配置管理计划、配置标识、配置控制、配置状态报告、配置审计、发布管理和交付。</span></p></li><li><p><strong><span>配置项</span></strong><span>:GB/T11457-2006对配置项的定义为:“</span><mark><span>为配置管理设计的硬件、软件或二者的集合</span></mark><span>，在配置管理过程中作为</span><mark><span>一个单个实体</span></mark><span>来对待</span></p></li><li><p><span>以下内容都可以作为配置项进行管理: </span><mark><span>外部交付的软件产品和数据、指定的内部软件工作产品和数据、指定的用于创建或支持软件产品的支持工具、供方/供应商提供的软件和客户提供的设备/软件。</span></mark></p></li><li><p><span>典型配置项包括</span><mark><span>项目计划书、需求文档、设计文档、源代码、可执行代码、测试用例，运行软件所需的各种数据</span></mark><span>，它们经</span><mark><span>评审和检查通过后</span></mark><span>进入配置管理。</span></p></li><li><p><span>每个配置项的主要属性有: </span><mark><span>名称、标识符、文件状态、版本、作者、日期</span></mark><span>等。</span></p></li><li><p><span>配置项可以分为</span><mark><span>基线配置项和非基线配置项</span></mark><span>两类，例如，</span><mark><span>基线配置项可能包括所有的设计文档和源程序等;非基线配置项可能包括项目的各类计划和报告等。</span></mark></p></li><li><p><mark><span>所有配置项的操作权限应由CMO (配置管理员) 严格管理</span></mark><span>，基本原则是: </span><mark><span>基线配置项向开发人员开放读取的权限;非基线配置项向PM、CCB及相关人员开放。</span></mark></p></li><li><p><strong><span>配置项的状态</span></strong><span>可分为</span><mark><span>“草稿”“正式”和“修改”</span></mark><span>三种。</span><mark><span>配置项刚建立时，其状态为“草稿”。配置项通过评审后，其状态变为“正式”。此后若更改配置项，!则其状态变为“修改”</span></mark><span>。当配置项</span><mark><span>修改完毕并重新通过评审时，其状态又变为“正式”</span></mark><span>。如图所示:</span></p><p><img src="http://qn.qs520.mobi/image-20230221095717348.png" referrerpolicy="no-referrer" alt="image-20230221095717348"><span> </span></p></li><li><p><strong><span>配置项版本号</span></strong></p><ul><li><span>(1)处于</span><mark><span>“草稿”状态</span></mark><span>的配置项的</span><mark><span>版本号格式为</span><code>0.YZ</code><span>，YZ</span></mark><span>的数字范围为01-99。</span><mark><span>随着草稿的修正，YZ的取值应递增</span></mark><span>。YZ的</span><mark><span>初值和增幅由用户自己把握。</span></mark></li><li><span>(2)处于</span><mark><span>“正式”状态</span></mark><span>的配置项的</span><mark><span>版本号格式为</span><code>X.Y</code></mark><span>，X为主版本号，取值范围为1-9。Y为次版本号，取值范围为0-9。配置项</span><mark><span>第一次成为“正式”文件时，版本号为1.0</span></mark><span>。如果配置项</span><mark><span>升级幅度比较小</span></mark><span>，可以将变动部分制作成配置项的附件，</span><mark><span>附件版本依次为1.0，1.1...。</span></mark><span>当附件的变动积累到一定程度时，配置项的Y值可适量增加，</span><mark><span>Y值增加一定程度时X值将适量增加。当配置项升级幅度比较大时，才允许直接增大X值。</span></mark></li><li><span>(3)处于</span><mark><span>“修改”状态</span></mark><span>的配置项的</span><mark><span>版本号格式为</span><code>X.YZ</code></mark><span>。</span><mark><span>配置项正在修改时，一般只增大Z值XY值保持不变</span></mark><span>。当配置项修改完毕，</span><mark><span>状态成为“正式”时，将Z值设置为0,增加XY值</span></mark><span>。参见上述规则 (2)</span></li></ul></li><li><p><strong><span>配置项版本管理(考点)</span></strong><span>: 在项目开发过程中，绝大部分的配置项都要</span><mark><span>经过多次的修改</span></mark><span>才能最终确定下来。对配置项的</span><mark><span>任何修改都将产生新的版本</span></mark><span>。由于我们不能保证新版本一定比旧版本“好”，所以</span><mark><span>不能抛弃旧版本</span></mark><span>。版本管理的目的是</span><mark><span>按照一定的规则保存配置项的所有版本避免发生版本丢失或混淆等现象</span></mark><span>，并且可以</span><mark><span>快速准确地查找到配置项的任何版本</span></mark><span>。</span></p></li><li><p><strong><span>配置基线(常简称为基线)</span></strong><span>由</span><mark><span>一组配置项</span></mark><span>组成，这些配置项</span><mark><span>构成一个相对稳定的逻辑实体</span></mark><span>。基线中的</span><mark><span>配置项被“冻结”了</span></mark><span>，不能再被任何人随意修改。对基线的</span><mark><span>变更必须遵循正式的变更控制程序</span></mark><span>。</span></p></li><li><p><span>基线通常对应于开发过程中的</span><mark><span>里程碑</span></mark><span>，</span><mark><span>一个产品可以有多个基线，也可以只有一个基线</span></mark><span>。:</span><mark><span>内部开发交付给外部顾客的基线一般称为发行基线(Release)，使用的基线一般称为构造基线(Build)</span></mark></p></li><li><p><span>一组拥有唯一标识号的需求、设计、源代码文卷以及相应的可执行代码、构造文卷和用户文档构成一条基线。</span></p></li><li><p><span>产品的一个测试版本(可能包括需求分析说明书、概要设计说明书、详细设计说明书、已编译的可执行代码、测试大纲、测试用例、使用手册等) 是基线的一个例子。</span></p></li><li><p><span>对于</span><mark><span>每一个基线</span></mark><span>，要定义下列内容: </span><mark><span>建立基线的事件、受控的配置项、建立和变更基线的程序批准变更基线所需的权限</span></mark><span>。在项目实施过程中，每个基线都要纳入配置控制，对这些基线的更新</span><mark><span>只能采用正式的变更控制程序</span></mark></p></li><li><p><span>建立基线还可以有如下好处:</span></p><ul><li><span>(1)基线为开发工作提供了一个</span><mark><span>定点和快照</span></mark></li><li><span>(2)新项目可以</span><mark><span>在基线提供的定点上建立</span></mark><span>。新项目作为一个单独分支，将与随后对原始项目(在主要分支上) 所进行的变更进行隔离。</span></li><li><span>(3)当认为</span><mark><span>更新不稳定或不可信时，基线为团队提供一种取消变更的方法</span></mark></li><li><span>(4)可以</span><mark><span>利用基线重新建立基于某个特定发布版本的配置</span></mark><span>，以重现已报告的错误。</span></li></ul></li><li><p><strong><span>配置库</span></strong><mark><span>存放配置项并记录与配置项相关的所有信息</span></mark><span>，是配置管理的有力工具。主要作用:</span></p><ul><li><span>(1)记录与配置相关的</span><mark><span>所有信息</span></mark><span>，其中</span><mark><span>存放受控的软件配置项</span></mark><span>是很重要的内容</span></li><li><span>(2)利用库中的信息</span><mark><span>评价变更的后果</span></mark><span>，这对变更控制有着重要的意义。</span></li><li><span>(3)从库中</span><mark><span>可提取各种配置管理过程的管理信息</span></mark></li></ul></li><li><p><span>使用配置库可以帮助配置管理员把信息系统开发过程的各种工作产品，包括半成品或阶段产品和最终产品</span><mark><span>管理得井井有条，使其不致管乱、管混、管丢</span></mark></p></li><li><p><span>配置库可以分</span><mark><span>开发库、受控库、产品库</span></mark><span>3种类型。</span></p><ul><li><span>(1)</span><strong><span>开发库</span></strong><span>,也称为</span><mark><span>动态库、程序员库或工作库</span></mark><span>，用于保存</span><mark><span>开发人员当前正在开发的配置实体</span></mark><span>，如:新模块、文档、数据元素或进行修改的已有元素。动态中的配置项被置于版本管理之下。</span><mark><span>动态库是开发人员的个人工作区，由开发人员自行控制</span></mark><span>。</span><mark><span>库中的信息可能有较为频繁的修改，只要开发库的使用者认为有必要，无需对其进行配置控制</span></mark><span>，因为这通常不会影响到项目的其他部分。可</span><mark><span>以任意的修改。</span></mark></li><li><span>(2)</span><strong><span>受控库</span></strong><span>,也称为</span><mark><span>主库</span></mark><span>，包含</span><mark><span>当前的基线加上对基线的变更</span></mark><span>受控库中的配置项</span><mark><span>被置于完全的配置管理之下</span></mark><span>。在信息系统开发的某个阶段工作</span><mark><span>结束时,将当前的工作产品存入受控库。可以修改，需要走变更流程</span></mark></li><li><span>(3)</span><strong><span>产品库</span></strong><span>,也称为</span><mark><span>静态库、发行库、软件仓库</span></mark><span>，包含</span><mark><span>已发布使用的各种基线的存档，被置于完全的配置管理之下</span></mark><span>。在开发的信息系统产品完成系统测试之后作为</span><mark><span>最终产品</span></mark><span>存入产品库内，等待交付用户或现场安装。</span><mark><span>一般不再修改，真要修改的话需要走变更流程</span></mark></li></ul></li></ul><h4><a name="质量管理" class="md-header-anchor"></a><span>质量管理</span></h4><ul><li><p><span>质量是</span><mark><span>软件产品特性的综合</span></mark><span>，表示</span><mark><span>软件产品满足明确(基本需求)或隐含(期望需求)要求的能力</span></mark><span>。质量管理是指确定质量方针、目标和职责，并通过质量体系中的质量计划、质量控制、质量保证和质量改进来使其实现的所有管理职能的全部活动;</span></p></li><li><p><span>主要包括以下过程;</span></p><ul><li><span>(1)</span><strong><span>质量规划</span></strong><span>:识别项目及其产品的质量要求和标准，并书面描述项目将如何达到这些要求和标准的过程。</span></li><li><span>(2)</span><strong><span>质量保证</span></strong><span>:一般是每隔一定时间(例如，每个阶段末) 进行的，主要通过系统的</span><mark><span>质量审计(软件评审) 和过程分析</span></mark><span>来保证项目的质量。</span></li><li><span>(3) </span><strong><span>质量控制</span></strong><span>:实时监控项目的具体结果以判断它们是否符合相关质量标准制订有效方案，以消除产生质量问题的原因。</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230221111845036.png" referrerpolicy="no-referrer" alt="image-20230221111845036"><span> </span></p></li><li><p><strong><span>软件质量评审</span></strong></p><ul><li><span>质量两个必要条件: </span><mark><span>设计的规格说明书符合用户标准，称为设计质量</span></mark><span>。</span><mark><span>程序按照设计规格说明书所规定的情况正确执行，称为程序质量。</span></mark></li></ul></li><li><p><strong><span>软件容错技术</span></strong><span>: 容错就是软件遇到错误的处理能力，实现容错的手段主要是</span><mark><span>冗余(备份)</span></mark><span>，三种容错技术如下图：</span></p><ul><li><img src="http://qn.qs520.mobi/image-20230306172747791.png" referrerpolicy="no-referrer" alt="image-20230306172747791"><span> </span></li></ul></li><li><p><mark><span>双机容错技术</span></mark><span>:是一种</span><mark><span>软硬件结合</span></mark><span>的容错应用方案。该方案是由</span><mark><span>两台服务器和一个外接共享磁盘阵列及相应的双机软件组成。</span></mark>
<span>双机容错系统采用</span><mark><span>“心跳”</span></mark><span>方法保证主系统与备用系统的联系。所谓心跳，是指主从系统之间相互按照</span><mark><span>一定的时间间隔发送通信信号</span></mark><span>，表明各自系统当前的运行状态。一旦心跳信号表明主机系统发生故障，或者备用系统无法收到主系统的心跳信号，则系统的高可用性管理软件认为主系统发生故障，立即将系统资源转移到备用系统上，备用系统替代主系统工作，以保证系统正常运行和网络服务不间断。</span></p><ul><li><span>工作模式: </span><mark><span>双机热备模式，双机互备模式，双机双工模式</span></mark></li></ul></li><li><p><mark><span>集群技术</span></mark><span>就是将</span><mark><span>多台计算机组织起来进行协同工作</span></mark><span>，它是提高系统可用性和可靠性的一种技术在集群系统中，每台计算机均</span><mark><span>承担部分计算任务和容错任务</span></mark><span>，当其中一台计算机出现故障时，系统使用集群软件将这台计算机从系统中隔出离去，通过各计算机之间的负载转嫁机制</span><mark><span>完成新的负载分担</span></mark><span>，同时向系统管理人员发出警报。集群系统通过功能整合和故障过渡，实现了系统的高可用性和可靠性。</span></p><ul><li><span>特点:可伸缩性、高可用性、可管理性、高性价比、高透明性</span></li><li><span>分类:高性能计算集群、负载均衡集群、高可用性集群。</span></li></ul></li><li><p><strong><span>四种主要冗余技术</span></strong><span>:</span></p><ul><li><strong><span>结构冗余</span></strong><span>: 分为</span><mark><span>静态、动态、混合冗余</span></mark><span>三种，</span><mark><span>当错误发生时对错误进行备份处理</span></mark></li><li><strong><span>信息冗余</span></strong><span>: 为检错和纠错在数据中</span><mark><span>加上一段额外的信息</span></mark><span>，例如校验码原理。</span></li><li><strong><span>时间冗余</span></strong><span>: </span><mark><span>遇到错误时重复执行</span></mark><span>，例如回滚，重复执行还有错，则转入错误处理逻辑</span></li><li><strong><span>冗余附加</span></strong><span>: 是指为实现结构、信息和时间冗余技术</span><mark><span>所需的资源和技术</span></mark><span>，包括程序、指数据、存放和调动它们的空间和通道等。</span></li></ul></li><li><p><strong><span>负载均衡</span></strong><span>是</span><mark><span>集群系统</span></mark><span>中的一项重要技术，可以提高集群系统的整体处理能力，也提高了系统的可靠性。</span><mark><span>最终目的是加快集群系统的响应速度，提高客户端访问的成功概率</span></mark><span>。集群的</span><mark><span>最大特征是多个节点的并行和共同工作</span></mark><span>，如何让所有节点承受的负荷平均，不出现局部过大负载或过轻负载的情况，是负载均衡的重要目的。比较常用的负载均衡实现技术主要有以下几种:</span></p><ul><li><span>(1)</span><mark><span>基于特定软件的负载均衡(应用层)</span></mark><span>。很多网络协议都支持</span><mark><span>重定向功能</span></mark><span>，例如，基于HTTP重定向服务，其主要原理是服务器使用HTTP重定向指令，将一个客户端重新定位到另一个位置。服务器返回个重定向响应，而不是返回请求的对象。客户端确认新地址然后重发请求，从而达到负载均衡的目的。</span></li><li><span>(2)</span><mark><span>基于DNS的负载均衡属于传输层负载均衡技术</span></mark><span>，其主要原理是在DNS服务器中为同一个主机名配置多个地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的节点上去，使得不同的客户端访问不同的节点，从而达到负载均衡的目的。</span></li><li><span>(3)</span><mark><span>基于NAT的负载均衡</span></mark><span>。将一个外部IP 地址映射为多个内部IP 地址，对每次连接需求动态地转换为个内部节点的地址，将外部连接请求引到转换得到地址的那个节点，上从而达到负载均衡的目的。</span></li><li><span>(4)</span><mark><span>反向代理负载均衡</span></mark><span>。将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多个节点进行处理，从而达到负载均衡的目的。</span></li><li><span>(5) </span><mark><span>混合型负载均衡</span></mark><span>。</span></li></ul></li></ul><h4><a name="风险管理" class="md-header-anchor"></a><span>风险管理</span></h4><ul><li><p><span>风险管理就是要对项目风险进行认真的分析和科学的管理,这样是</span><mark><span>能够避开不利条件、少受损失、取得预期的结果并实现项目目标的</span></mark><span>，能够争取避免风险的发生或尽量减小风险发生后的影响。但是，</span><mark><span>完全避开或消除风险，或者只享受权益而不承担风险是不可能的。</span></mark></p><ul><li><mark><span>风险管理计划编制</span></mark><span>: 如何安排与实施项目的风险管理，制定下列各步的计划</span></li><li><mark><span>风险识别</span></mark><span>:识别出项目中已知和可预测的风险，确定风险的来源、产生的条件、描述风险的特征以及哪些项目可以产生风险，形成一个风险列表。</span></li><li><mark><span>风险定性分析</span></mark><span>: 对已经识别的风险进行排序，确定风险可能性与影响、确定风险优先级、确定风险类型。</span></li><li><mark><span>风险定量分析</span></mark><span>: 进一步了解风险发生的可能性具体由多大，后果具体由多严重。包括灵敏度分析期望货币价值分析、决策树分析、蒙特卡罗模拟。</span></li><li><mark><span>风险应对计划编制</span></mark><span>: 对每一个识别出来的风险来分别制定应对措施，这些措施组成的文档称为风险应对计划。包括消极风险(避免策略、转移策略(买保险，转移风险给第三方)、减轻策略);积极风险 (开拓、分享、强大)。</span></li><li><mark><span>风险监控</span></mark><span>:监控风险计划的执行，检测残余风险，识别新的风险，保证风险计划的执行，并评价这些计划对减少风险的有效性。</span></li></ul></li><li><p><strong><span>项目风险</span></strong><span>: 作用于项目上的</span><mark><span>不确定的</span></mark><span>事件或条件，</span><mark><span>既可能产生威胁，也可能带来机会</span></mark><span>。</span></p></li><li><p><span>通过积极和合理的规划，</span><mark><span>超过90%的风险都可以进行提前应对和管理</span></mark></p></li><li><p><span>风险应该</span><mark><span>尽早识别出来，高层次风险应记录在章程里</span></mark></p></li><li><p><span>应由</span><mark><span>对风险最有控制力的一方承担相应的风险。</span></mark></p></li><li><p><mark><span>承担风险程度与所得回报相匹配原则，承担的风险要有上限</span></mark></p></li><li><p><span>风险的属性:</span></p><ul><li><span>(1)</span><strong><span>随机性</span></strong><span>:风险事件</span><mark><span>发生及其后果</span></mark><span>都具有</span><mark><span>偶然性</span></mark><span> (双重偶然)，遵循一定的</span><mark><span>统计规律</span></mark><span>。</span></li><li><span>(2)</span><strong><span>相对性</span></strong><span>: 风险是相对</span><mark><span>项目活动主体而言的。承受力不同，影响不同</span></mark><span>。风险承受力影响因素: </span><mark><span>收益大小</span></mark><span> (收益越大，越愿意承担风险) : </span><mark><span>投入大小</span></mark><span>(投入越大，承受能力越小);</span><mark><span>主体的地位和资源</span></mark><span>(级别高的人能承担较大的风险)</span></li><li><span>(3)</span><strong><span>风险的可变性</span></strong><span>: </span><mark><span>条件变化，会引起风险变化</span></mark><span>。包括性质、后果的变化，以及出现新风险</span></li></ul></li><li><p><strong><span>风险的分类</span></strong><span>:</span></p><ul><li><span>按照</span><mark><span>后果的不同</span></mark><span>，风险可划分为</span><mark><span>纯粹风险 (无任何收益) 和投机风险(可能带来收益)</span></mark><span>。</span></li><li><span>按</span><mark><span>风险来源</span></mark><span>划分，</span><mark><span>自然风险 (天灾) 和人为风险</span></mark><span> (人的活动，又可分为行为风险、经济风险、技术风险、政治和组织风险等)</span></li><li><span>按</span><mark><span>是否可管理</span></mark><span>划分，</span><mark><span>可管理(如内部多数风险)和不可管理 (如外部政策)</span></mark><span>也要看主体管理水平</span></li><li><span>按</span><mark><span>影响范围</span></mark><span>划分，</span><mark><span>局部风险(非关键路径活动延误) 和总体风险关键路径活动延误)</span></mark></li><li><span>按</span><mark><span>后果承担者</span></mark><span>划分: 业主、政府、承包商、投资方、设计单位、监理单位保险公司等。</span></li><li><span>按</span><mark><span>可预测性</span></mark><span>划分: 已知风险(已知的进度风险)、可预测风险(可能服务器故障)、不可预测风险(地震、洪水、政策变化等)</span></li></ul></li><li><p><span>在信息系统项目中，从宏观上来看，风险可以分为</span><mark><span>项目风险、技术风险和商业风险</span></mark><span>。</span></p><ul><li><p><strong><span>项目风险</span></strong><span>是指</span><mark><span>潜在的预算、进度、个人 (包括人员和组织) 、资源、用户和需求方面的问题，以及它们对项目的影响</span></mark><span>。项目复杂性、规模和结构的不确定性也构成项目的(估算)风险因素。项目风险</span><mark><span>威胁到项目计划</span></mark><span>，一旦项目风险成为现实，可能会拖延项目进度，增加项目的成本。</span></p></li><li><p><strong><span>技术风险</span></strong><span>是指潜在的</span><mark><span>设计、实现、接口、测试和维护方面的问题</span></mark><span>。此外，</span><mark><span>规格说明的多义性、技术上的不确定性、技术陈旧、最新技术(不成熟)</span></mark><span>也是风险因素。技术风险</span><mark><span>威胁到待开发系统的质量和预定的交付时间</span></mark><span>。如果技术风险成为现实，开发工作可能会变得很困难或根本不可能。</span></p></li><li><p><strong><span>商业风险</span></strong><mark><span>威胁到待开发系统的生存能力</span></mark><span>，主要有以下5 种不同的商业风险</span></p><ul><li><span>(1)市场风险。开发的系统虽然很优秀但不是市场真正所想要的。</span></li><li><span>(2)策略风险。开发的系统不再符合企业的信息系统战略。</span></li><li><span>(3)销售风险。开发了销售部门不清楚如何推销的系统。</span></li><li><span>(4)管理风险。由于重点转移或人员变动而失去上级管理部门的支持。</span></li><li><span>(5)预算风险。开发过程没有得到预算或人员的保证。</span></li></ul></li></ul></li></ul><h4><a name="补充知识" class="md-header-anchor"></a><span>补充知识</span></h4><ul><li><p><strong><span>组织结构模式</span></strong><span>: </span><mark><span>项目型</span></mark><span>(项目经理绝对领导)、</span><mark><span>职能型</span></mark><span>(部门领导为主)，</span><mark><span>矩阵型</span></mark><span> (二者结合，既有项目经理也有部门领导，但权利分割不同)</span></p></li><li><p><strong><span>程序设计小组的组织方式</span></strong><span>:</span></p><ul><li><span>(1)</span><mark><span>主程序员制小组</span></mark><span>(主程序员全权负责，后援工程师必要时能替代主程序员适合大规模项目)</span></li><li><span>(2)</span><mark><span>民主制小组</span></mark><span>(也即无主程序员小组，成员之间地位平等，任何决策都是全员参与投票，适合于项目规模小，开发人员少，采用新技术和确定性较小的项</span></li><li><span>(3)</span><mark><span>层次式小组</span></mark><span>(两个层次，一名组长领导若千个高级程序员，每个高级程序员领导若千个程序员)。</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230221161250202.png" referrerpolicy="no-referrer" alt="image-20230221161250202"><span> </span></p></li></ul><h2><a name="span-id16嵌入式技术16嵌入式技术案例分析考点5span" class="md-header-anchor"></a><span id="16.嵌入式技术"><span>16.嵌入式技术(案例分析考点5)</span></span></h2><h3><a name="span-id嵌入式微处理器嵌入式微处理器span" class="md-header-anchor"></a><span id="嵌入式微处理器"><span>嵌入式微处理器</span></span></h3><h4><a name="嵌入式微处理器体系结构" class="md-header-anchor"></a><span>嵌入式微处理器体系结构</span></h4><ul><li><p><strong><span>冯诺依曼结构</span></strong></p><ul><li><p><span>传统计算机采用冯·诺依曼 (Von Neumann)结构，也称</span><mark><span>普林斯顿结构</span></mark><span>是一种</span><mark><span>将程序指令存储器和数据存储器合并在一起的存储器结构</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230221201453031.png" referrerpolicy="no-referrer" alt="image-20230221201453031"><span> </span></p></li><li><p><span>冯·诺依曼结构的计算机程序和数据共用一个存储空间程序</span><mark><span>指令存储地址和数据存储地址指向同一个存储器的不同物理位置,</span></mark><span>，采用</span><mark><span>单一的地址及数据总线</span></mark><span>，</span><mark><span>程序指令和数据的宽度相同处理器执行指令时，先从储存器中取出指令解码，再取操作数执行运算</span></mark><span>，即使单条指令也要耗费儿个甚至几十个周期，在高速运算时，在传输通道上会出现瓶颈效应。</span></p></li></ul></li><li><p><strong><span>哈佛结构</span></strong></p><ul><li><p><span>哈佛结构是一种</span><mark><span>并行体系结构</span></mark><span>，&quot;</span><mark><span>它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个相互独立的存储器每个存储器独立编址、独立访问</span></mark></p><p><img src="http://qn.qs520.mobi/image-20230221201653917.png" referrerpolicy="no-referrer" alt="image-20230221201653917"><span> </span></p></li><li><p><span>与两个存储器相对应的是系统中的</span><mark><span>两套独立的地址总线和数据总线</span></mark><span>，这种分离的程序总线和数据总线可允许在</span><mark><span>一个机器周期内同时获取指令字(来自程序存储器)和操作数(来自数据存储器)</span></mark><span>，从而提高了执行速度，使数据的吞吐率提高了1倍</span></p></li></ul></li></ul><h4><a name="微处理器分类" class="md-header-anchor"></a><span>微处理器分类</span></h4><ul><li><p><span>根据嵌入式微处理器的</span><mark><span>字长宽度，可分为4 位、8 位、16 位、32 位和64 位</span></mark><span>般把</span><mark><span>16 位及以下的称为嵌入式微控制器 (Embedded Micro Controller)，32 位及以上的称为嵌入式微处理器</span></mark><span>。</span></p></li><li><p><span>如果按</span><mark><span>系统集成度</span></mark><span>划分，可分为两类:</span></p><ul><li><span>一种是微处理器内部仅包含单纯的中央处理器单元，称为一般用途型微处理器: </span></li><li><span>另一种则是将CPU、ROM、RAM及l/0 等部件集成到同一个芯片上，称为单芯片微控制器 (single chipMicrocontroller)</span></li></ul></li><li><p><span>如果根据</span><mark><span>用途分类</span></mark><span>一般分为</span><mark><span>嵌入式微控制器MCU、嵌入式微处理器MPU，嵌入式数字信号处理器DSP、嵌入式片上系统SOC等</span></mark></p><ul><li><strong><span>嵌入式微控制器MCU</span></strong><span>的典型代表是</span><mark><span>单片机</span></mark><span>，其片上外设资源比较丰富，适合于控制。MCU芯片内部集成ROM/EPROM、RAM、总线、总线逻辑、定时/计数器、看门狗、I/0、串行口、脉宽调制输出、A/D、D/A、 Flash RAM、EEPROM等各种必要功能和外设。和嵌入式微处理器相比，微控制器的最大特点是单片化体积大大减小，从而使功耗和成本下降、可靠性提高，其片上外设资源一般较丰富，适合于控制，是嵌入式系统工业的主流。</span></li><li><strong><span>嵌入式微处理器MPU</span></strong><mark><span>由通用计算机中的CPU演变而来</span></mark><span>。它的特征是</span><mark><span>具有32位以上的处理器</span></mark><span>，具有较高的性能，当然其价格也相应较高。但与计算机处理器不同的是，在实际嵌入式应用中，</span><mark><span>只保留和嵌入式应用紧密相关的功能硬件去除其他的几余功能部分，这样就以最低的功耗和资源实现嵌入式应用的特殊要求</span></mark><span>。与工业控制计算机相比，嵌入式微处理器具有体积小、重量轻、成本低可靠性高的优点。目前常见的有ARM、MIPS、POWER PC等。</span></li><li><strong><span>嵌入式数字信号处理器DSP</span></strong><span>是</span><mark><span>专门用于信号处理方面的处理器</span></mark><span>其</span><mark><span>在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令的执行速度</span></mark><span>，采用</span><mark><span>哈佛结构，流水线处理，其处理速度比最快的CPU还快10-50倍</span></mark><span>。在数字滤波、FFT、谱分析等各种仪器上DSP获得了大规模的应用。</span></li><li><strong><span>嵌入式片上系统SOC</span></strong><span>，是</span><mark><span>追求产品系统最大包容的集成器件</span></mark><span>。SoC最大的特点是成功实现了软硬件无缝结合，直接在处理器片内嵌入操作系统的代码模块是一个有专用目标的集成电路，其中包含完整系统并有嵌入软件的全部内容。</span></li></ul></li></ul><h4><a name="多核处理器" class="md-header-anchor"></a><span>多核处理器</span></h4><ul><li><p><mark><span>多核指多个微处理器内核</span></mark><span>是将两个或更多的微处理器封装在一起，</span><mark><span>集成在一个电路中</span></mark><span>。多核处理器是</span><mark><span>单枚芯片</span></mark><span>，能够直接插入单一的处理器插槽中。多核与多CPU相比，</span><mark><span>很好的降低了计算机系统的功耗和体积</span></mark><span>。在多核技术中，</span><mark><span>由操作系统软件进行调度，多进程，多线程并发都可以</span></mark><span>。</span></p></li><li><p><span>2个或多个内核工作协调实现方式:</span></p><ul><li><mark><span>对称多处理技术SMP</span></mark><span>: 将2颗完全一样的处理器封装在一个芯片内，达到双倍或接近双倍的处理性能，节省运算资源。</span></li><li><mark><span>非对称处理技术AMP</span></mark><span>: 2个处理内核彼此不同，各自处理和执行特定的功能，在软件的协调下分担不同的计算任务</span></li></ul></li><li><p><strong><span>多核CPU的调度</span></strong></p><ul><li><span>多核CPU环境下进程的调度算法一般有</span><mark><span>全局队列调度和局部队列调度</span></mark><span>两种</span></li><li><strong><span>全局队列调度</span></strong><span>是指操作系统维护一个</span><mark><span>全局的任务等待队列</span></mark><span>，当系统中有一个CPU空闲时操作系统就从全局任务等待队列中选取就绪任务开始执行，CPU核心利用率高。</span></li><li><strong><span>局部队列调度</span></strong><span>是</span><mark><span>操作系统为每个CPU内核维护一个局部的任务等待队列</span></mark><span>，当系统中有个CPU内核空闲时，就从该核心的任务等待队列中选取适当的任务执行，优点是无需在多个CPU之间切换</span></li></ul></li></ul><h3><a name="span-id嵌入式软件与操作系统嵌入式软件与操作系统span" class="md-header-anchor"></a><span id="嵌入式软件与操作系统"><span>嵌入式软件与操作系统</span></span></h3><h4><a name="嵌入式软件" class="md-header-anchor"></a><span>嵌入式软件</span></h4><ul><li><p><span>嵌入式软件是指</span><mark><span>应用在嵌入式计算机系统当中的各种软件</span></mark><span>，除了具有通用软件的一般特性，还具有一些与嵌入式系统相关的特点，包括: </span><mark><span>规模较小、开发难度大、实时性和可靠性要求高、要求固化存储</span></mark></p></li><li><p><span>嵌入式软件分类</span></p><ul><li><strong><span>系统软件</span></strong><span>: </span><mark><span>控制和管理入式系统资源</span></mark><span>，为嵌入式应用提供支持的各种软件如设备驱动程序、嵌入式操作系统、嵌入式中间件等。</span></li><li><strong><span>应用软件</span></strong><span>:嵌入式系统中的</span><mark><span>上层软件</span></mark><span>，定义了嵌入式设备的主要功能和用途并负责与用户交互，一般面向特定的应用领域，如飞行控制软件、手机软件、地图等。</span></li><li><strong><span>支撑软件</span></strong><span>:</span><mark><span>辅助软件开发的工具软件</span></mark><span>，如系统分析设计工具、在线仿真工具.交叉编译器等</span></li></ul></li><li><p><strong><span>板级支持包(BSP</span></strong><span>)是</span><mark><span>介于主板硬件和操作系统中驱动层程序之间的一层(设备驱动层)</span></mark><span>，一般认为它属于操作系统一部分，:主要是实现对操作系统的支持，为上层的驱动程序提供访问硬件设备寄存器的函数包，使之能够更好的运行于硬件主板。具体功能包括：</span></p><ol start='' ><li><span>单板</span><mark><span>硬件初始化</span></mark><span>，主要是CPU的初始化，为整个软件系统提供底层硬件支持</span></li><li><span>为操作系统</span><mark><span>提供设备驱动程序和系统中断服务程序</span></mark></li><li><mark><span>定制操作系统的功能</span></mark><span>，为软件系统提供一个实时多任务的运行环境</span></li><li><mark><span>初始化操作系统</span></mark><span>，为操作系统的正常运行做好准备</span></li></ol></li><li><p><span>主要具有以下两个特点</span></p><ul><li><strong><span>硬件相关性</span></strong><span>，因为嵌入式实时系统的硬件环境具有应用相关性，而作为上层软件与硬件平台之间的接口，BSP需为操作系统提供操作和控制具体硬件的方法</span></li><li><strong><span>操作系统相关性</span></strong><span>，不同的操作系统具有各自的软件层次结构，因此不同操作系统具有特定的硬件接口形式</span></li><li><span>一般来说，</span><mark><span>BSP主要包括两个方面的内容: 引导加载程序BootLoader和设备驱动程序。</span></mark></li></ul></li><li><p><span>BootLoader是嵌入式系统</span><mark><span>加电后运行的第一段软件代码</span></mark><span>，是在操作系统内核运行之前运行的一小段程序，通过这段程序，可以</span><mark><span>初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境设置到一个合适的状态，以便为最终调用操作系统内核做好准备</span></mark><span>。一般包括以下功能:</span></p><ul><li><mark><span>片级初始化</span></mark><span>: 主要</span><mark><span>完成微处理器的初始化，包括设置微处理器的核心寄存器和控制寄存器.微处理器的核心工作模式及其局部总线模式等</span></mark><span>。片级初始化把微处理器从上电时的默认状态逐步设置成系统所要求的工作状态。这是一个</span><mark><span>纯硬件的初始化过程</span></mark></li><li><mark><span>板级初始化</span></mark><span>: </span><mark><span>通过正确地设置各种寄存器的内容来完成微处理器以外的其他硬件设备的初始化</span></mark><span>。例如，初始化LED显示设备、初始化定时器、设置中断控制寄存器、初始化串口通信、初始化内存控制器、建立内存空间的地址映射等在此过程中，除了要设置各种硬件寄存器以外，还要设置某些软件的数据结构和参数。因此，这是一个</span><mark><span>同时包含有软件和硬件在内的初始化过程</span></mark><span>。</span></li><li><mark><span>加载内核(系统级初始化)</span></mark><span>：</span><mark><span>将操作系统和应用程序的映像从Flash存储器复制到系统的内存当中</span></mark><span>，然后跳转到系统内核的第一条指令处继续执行。</span></li></ul></li><li><p><span>在一个嵌入式系统当中，操作系统是可能有也可能无的。但无论如何，</span><mark><span>设备驱动程序是必不可少的</span></mark><span>。所谓的设备驱动程序，</span><mark><span>就是一组库函数，用来对硬件进行初始化和管理，并向上层软件提供良好的访问接口</span></mark></p></li><li><p><span>对于不同的硬件设备来说，它们的功能是不一样的，所以它们的设备驱动程序也是不一样的。但是一-般来说，大多数的设备驱动程序都会具备以下的一些基本功能：</span></p><ul><li><span>硬件启动:在开机上电或系统重启的时候，对硬件进行初始化。</span></li><li><span>硬件关闭:将硬件设置为关机状态。硬件停用:暂停使用这个硬件</span></li><li><span>硬件启用: 重新启用这个硬件</span></li><li><span>读操作:从硬件中读取数据</span></li><li><span>写操作:往硬件中写入数据</span></li></ul></li></ul><h4><a name="嵌入式系统" class="md-header-anchor"></a><span>嵌入式系统</span></h4><ul><li><p><strong><span>嵌入式系统的组成</span></strong></p><ul><li><mark><span>嵌入式处理器</span></mark><span>。嵌入式系统的核心部件是各种类型的嵌入式处理器</span></li><li><mark><span>总线</span></mark><span>。嵌入式系统的总线一般分为片内总线和片外总线</span></li><li><mark><span>存储器</span></mark><span>。嵌入式系统的存储器主要包括主存和外存。</span></li><li><mark><span>I/0 设备与接口</span></mark><span>。嵌入式系统的输入设备因其应用领域的不同，有多种多样，比较常见的有键盘、鼠标、触摸屏、手柄和声控开关等。</span></li><li><mark><span>操作系统</span></mark><span>。嵌入式操作系统由操作系统内核、应用程序接口和设备驱动程序接口等几部分组成，-般采用微内核结构。</span></li><li><mark><span>应用支撑软件</span></mark><span>。应用支撑软件一般由窗口系统、网络系统、数据库管理系统和Java 虚拟机等部分组成，但这些部分都不是必须的，不同的嵌入式系统具有不同的应用支撑软件。</span></li><li><mark><span>应用软件</span></mark><span>。应用软件位于嵌入式系统层次结构的</span><mark><span>最上层</span></mark><span>，直接与最终用户交互，是系统整体功能的集中体现。</span></li></ul></li><li><p><strong><span>嵌入式系统的特点</span></strong></p><ul><li><mark><span>系统专用性强</span></mark><span>。嵌入式系统是</span><mark><span>针对具体应用的专门系统</span></mark><span>它的个性化很强软件和硬件结合紧密一般要针对硬件进行软件的开发和移植，根据硬件的变化和增减对软件进行修改。</span></li><li><mark><span>系统实时性强</span></mark><span>。很多嵌入式系统对外来事件要求在限定的时间内及时做出响应，具有实时性</span></li><li><mark><span>软硬件依赖性强</span></mark><span>。嵌入式系统的专用性决定了</span><mark><span>其软硬件的互相依赖性很强两者必须协同设计，</span></mark><span>以达到共同实现预定功能的目的，并满足性能、成本和可靠性等方面的严格要求</span></li><li><mark><span>处理器专用</span></mark><span>。嵌入式系统的处理器一般是为某一特定目的和应用而专门设计的。通常具有功耗低、体积小和集成度高等优点。</span></li><li><mark><span>多种技术紧密结合</span></mark><span>。通用计算机技术也离不开这些技术，但它们相互结合的紧密程度不及嵌入式系统。</span></li><li><mark><span>系统透明性</span></mark><span>。嵌入式系统在形态上与通用计算机系统差异甚大。它的输入设备往往不是常见的鼠标和键盘之类的设备，甚至没有输出装置。</span></li><li><mark><span>系统资源受限</span></mark><span>。嵌入式系统为了达到结构紧凑、高可靠性和低成本的目的其存储容量、I/0 设备的数量和处理器的处理能力都比较有限。</span></li></ul></li><li><p><strong><span>系统组成</span></strong></p><ul><li><p><span>一个完整的EDBMS 由若千子系统组成，包括</span><mark><span>主数据库、同步服务器、嵌入式数据库和连接网络</span></mark><span>等几个子系统。</span><strong><span>嵌入式移动数据库在实际应用中必须解决好</span></strong><mark><span>数据的一致性(复制性)，高效的事务处理和数据的安全性</span></mark><span>等关键问题</span></p><p><img src="http://qn.qs520.mobi/image-20230221204111318.png" referrerpolicy="no-referrer" alt="image-20230221204111318"><span> </span></p></li></ul></li><li><p><strong><span>嵌入式操作系统EOS</span></strong></p></li><li><p><span>与通用操作系统相比，EOS 主要有以下特点:</span></p><ul><li><span>(1)</span><strong><span>微型化</span></strong><span>。EOS 的运行平台不是通用计算机，而是嵌入式系统。这类系统般没有大容量的内存，几乎没有外存，因此，EOS 必须做得小巧，以占用尽量少的系统资源。</span></li><li><span>(2)</span><strong><span>代码质量高</span></strong><span>。在大多数嵌入式应用中，存储空间依然是宝贵的资源，这就要求程序代码的质量要高，代码要尽量精简。</span></li><li><span>(3)</span><strong><span>专业化</span></strong><span>。嵌入式系统的硬件平台多种多样，处理器的更新速度快，每种处理器都是针对不同的应用领域而专门设计的。因此，EOS 要有很好适应性和移植性，还要支持多种开发平台。</span></li><li><span>(4)</span><strong><span>实时性强</span></strong><span>。嵌入式系统广泛应用于过程控制、数据采集、通信、多媒体信息处理等要求实时响应的场合，因此，实时性成为EOS 的又一特点。</span></li><li><span>(5)</span><strong><span>可裁减和可配置</span></strong><span>。应用的多样性要求EOS 具有较强的适应能力，能够根据应用的特点和具体要求进行灵活配置和合理裁减，以适应微型化和专业化的要求。</span></li></ul></li><li><p><strong><span>嵌入式实时系统</span></strong><span>是一种完全嵌入受控器件内部，为特定应用而设计的专用计算机系统。在嵌入式实时系统中，要求</span><mark><span>系统在投入运行前即具有确定性和可预测性</span></mark><span>。</span></p><ul><li><span>可预测性是指</span><mark><span>系统在运行之前，其功能、响应特性和执行结果是可预测的</span></mark></li><li><span>确定性是指系统在</span><mark><span>给定的初始状态和输入条件下，在确定的时间内给出确定的结果</span></mark></li></ul></li><li><p><strong><span>实时操作系统(RTOS)的特点</span></strong></p><ul><li><span>当外界事件或数据产生时，</span><mark><span>能够接受并以足够快的速度予以处理</span></mark><span>，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，并控制所有实时任务协调一致运行因而，</span><mark><span>提供及时响应和高可靠性是其主要特点</span></mark></li><li><span>实时操作系统有</span><mark><span>硬实时和软实时</span></mark><span>之分，硬实时要求在规定的时间内必须完成操作，这是在操作系统设计时保证的;软实时则只要按照任务的优先级，尽可能快地完成操作即可</span></li></ul></li></ul><h4><a name="嵌入式实时操作系统" class="md-header-anchor"></a><span>嵌入式实时操作系统</span></h4><ul><li><p><strong><span>实时操作系统的特征</span></strong></p><ul><li><mark><span>高精度计时系统</span></mark><span>：计时精度是影响实时性的一个重要因素。在实时应用系统中，经常需要精确确定实时地操作某个设备或执行某个任务，或精确的计算一个时间函数。这些不仅依赖于一些硬件提供的时钟精度，也依赖于实时操作系统实现的高精度计时功能。</span></li><li><mark><span>多级中断机制</span></mark><span>：个实时应用系统通常需要处理多种外部信息或事件，但处理的紧迫程度有轻重缓急之分。有的必须立即作出反应，有的则可以延后处理。因此，需要建立多级中断嵌套处理机制，以确保对紧迫程度较高的实时事件进行及时响应和处。</span></li><li><mark><span>实时调度机制</span></mark><span>：实时操作系统不仅要及时响应实时事件中断，同时也要及时调度运行实时任务但是，处理机调度并不能随心所欲的进行，因为涉及到两个进程之间的切换只能在确保“安全切换”的时间点上进行，实时调度机制包括两个方面，一是在调度策略和算法上保证优先调度实时任务;二是建立更多“安全切换”时间点，保证及时调度实时任务。</span></li></ul></li></ul><h3><a name="span-id嵌入式开发嵌入式开发span" class="md-header-anchor"></a><span id="嵌入式开发"><span>嵌入式开发</span></span></h3><h4><a name="嵌入式软件设计" class="md-header-anchor"></a><span>嵌入式软件设计</span></h4><ul><li><p><strong><span>一个典型的交叉平台开发环境，包含三个高度集成的部分</span></strong><span>:</span></p><ul><li><span>运行在宿主机和目标机上的</span><mark><span>强有力的交叉开发工具和实用程序</span></mark></li><li><span>运行在目标机上的</span><mark><span>高性能、可裁剪的实时操作系统。</span></mark></li><li><mark><span>连接宿主机和目标机的多种通信方式</span></mark><span>，例如，以太网、USB、串口等</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230221204752773.png" referrerpolicy="no-referrer" alt="image-20230221204752773"><span> </span></p></li><li><p><strong><span>交叉编译</span></strong><span>：</span><mark><span>嵌入式软件开发所采用的编译为交叉编译</span></mark><span>。所谓交叉编译就是</span><mark><span>在一个平台上生成可以在另一个平台上执行的代码</span></mark><span>。编译的最主要的工作就在将程序转化成运行该程序的CPU所能识别的机器代码，由于不同的体系结构有不同的指令系统。因此，不同的CPU需要有相应的编译器，而交叉编译就如同翻译样，把相同的程序代码翻译成不同CPU的对应可执行二进制文件。</span><mark><span>嵌入式系统的开发需要借助宿主机(通用计算机)来编译出目标机的可执行代码</span></mark></p></li><li><p><strong><span>交叉调试</span></strong><span>: 嵌入式软件经过编译和链接后即进入调试阶段，调试是软件开发过程中必不可少的一个环节，嵌入式软件开发过程中的交叉调试与通用软件开发过程中的调试方式有很大的差别。在嵌入式软件开发中，调试时采用的是</span><mark><span>在宿主机和目标机之间进行的交叉调试，调试器仍然运行在宿主机的通用操作系统之上，但被调试的进程却是运行在基于特定硬件平台的嵌入式操作系统中</span></mark><span>，调试器和被调试进程通过串口或者网络进行通信，调试器可以控制、访问被调试进程，读取被调试进程的当前状态并能够改变被调试进程的运行状态。</span></p></li></ul><h4><a name="软件开发工具" class="md-header-anchor"></a><span>软件开发工具</span></h4><ul><li><span>嵌入式软件的开发可以分为几个阶段: </span><strong><span>编码、交叉编译、交叉调试</span></strong><span>。</span></li><li><strong><span>编辑器</span></strong><span>: 用于编写嵌入式源代码程序，从理论上来说，任何一个文本编辑器都可以用来编写源代码。各种集成开发环境会提供功能强大的编辑器，如VS系列、eclipse、 keil、Css等。常见的独立编辑器: UE、Source Insight、 vim等.</span></li><li><strong><span>编译器gcc</span></strong><span>: 编译阶段的工作是用交叉编译工具处理源代码，生成可执行的目标文件，在嵌入式系统中，由于宿主机和目标机系统不一样，需要使用交叉编译，GNU c/C++ (gcc)是目前常用的一种交叉编译器，支持非常多的宿主机/目标机组合。</span></li><li><strong><span>调试器gdb</span></strong><span>：在开发嵌入式软件时，交叉调试是必不可少的一步。嵌入式软件调试特点调试器运行在宿主机上，被调试程序运行在目标机上调试器通过某种通信方式与目标机建立联系，如串口、并口、网络、JTAG等在目标机上一般有调试器的某种代理，能配合调试器一起完成对目标机上运行程序的调试，可以是软件或支持调试的硬件。gdb是GNU开源组织发布的一个强大的程序调试工具</span></li></ul><h3><a name="span-id嵌入式系统案例分析嵌入式系统案例分析span" class="md-header-anchor"></a><span id="嵌入式系统案例分析"><span>嵌入式系统案例分析</span></span></h3><ul><li><p><span>几乎每年必考一题，选做题，考察比较的多的是嵌入式系统的实时性和可靠性以及容错等概念。大概率会考到一些嵌入式领域陌生技术，如果是完全没见过的技术，不选即可。</span></p></li><li><p><strong><span>相关概念</span></strong></p><ul><li><span>系统可靠性是</span><mark><span>系统在规定的时间内及规定的环境条件下，完成规定功能的能力，也就是系统无故障运行的概率</span></mark><span>。</span></li><li><span>系统可用性是指</span><mark><span>在某个给定时间点上系统能够按照需求执行的概率</span></mark></li><li><span>可靠度就是</span><mark><span>系统在规定的条件下、规定的时间内不发生失效的概率</span></mark></li><li><span>失效率又称风险函数，也可以称为条件失效强度，是指</span><mark><span>运行至此刻系统未出现失效的情况下单位时间系统出现失效的概率。</span></mark></li></ul></li><li><p><strong><span>软件可靠性和硬件可靠性区别</span></strong></p><ul><li><span>复杂性: </span><mark><span>软件复杂性比硬件高</span></mark><span>，大部分失效来自于软件失效。</span></li><li><span>物理退化: </span><mark><span>硬件失效主要是物理退化所致</span></mark><span>，软件不存在物理退化。</span></li><li><span>唯一性: </span><mark><span>软件是唯一的</span></mark><span>，每个COPY版本都一样，而两个硬件不可能完全一样</span></li><li><span>版本更新周期: </span><mark><span>硬件较慢，软件较快。</span></mark></li></ul></li></ul><h2><a name="span-id17web应用开发案例分析考点617web应用开发案例分析考点6span" class="md-header-anchor"></a><span id="17.Web应用开发(案例分析考点6)"><span>17.Web应用开发(案例分析考点6)</span></span></h2><p><mark><span>通读教材:第16章 新技术应用J2EE与.NET平台</span></mark></p><ul><li><p><strong><span>Web应用技术分类</span></strong></p><ul><li><span>从架构来看: </span><mark><span>MVC,MVP MVVM,REST,Webservice，微服务</span></mark></li><li><span>从缓存来看: </span><mark><span>MemCache,Redis,Squid。</span></mark></li><li><span>从并发分流来看: </span><mark><span>集群 (负载均衡) 、CDN</span></mark></li><li><span>从数据库来看: </span><mark><span>主从库(主从复制)，内存数据库，反规范化技术，NoSQL分区 (分表) 技术，视图.</span></mark></li><li><span>从持久化来看:Hibernate,Mybatis。</span></li><li><span>从分布存储来看:Hadoop,FastDFS，区块链</span></li><li><span>从数据编码看: </span><mark><span>XML，JSON。</span></mark></li><li><span>从Web应用服务器来看: Apache,WebSphere,Weblogic, Tomcat,JBOSSIIS。</span></li></ul></li><li><p><span>其它: </span><mark><span>有状态与无状态，响应式Web设计。</span></mark></p></li><li><p><strong><span>Web技术演变</span></strong></p><p><img src="http://qn.qs520.mobi/image-20230301210308616.png" referrerpolicy="no-referrer" alt="image-20230301210308616"><span> </span></p></li><li><p><strong><span>CDN</span></strong></p><ul><li><span>CDN的全称是Content Delivery Network，即</span><mark><span>内容分发网络</span></mark></li><li><span>CDN是</span><mark><span>构建在网络之上的内容分发网络</span></mark><span>，依靠</span><mark><span>部署在各地的边缘服务器</span></mark><span>，通过</span><mark><span>中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞</span></mark><span>，，提高用户访问响应速度和命中率。CDN的关键技术主要有</span><mark><span>内容存储和分发技术。</span></mark></li><li><span>CDN的基本原理是</span><mark><span>广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中</span></mark><span>，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</span></li></ul></li><li><p><strong><span>REST(表述性状态传递)</span></strong></p><ul><li><span>REST(Representational State Transfer，表述性状态转移)是一种</span><mark><span>只使用HTTP和XML进行基于Web通信的技术</span></mark><span>，可以</span><mark><span>降低开发的复杂性，提高系统的可伸缩性。</span></mark></li></ul></li><li><p><strong><span>REST的5个原则</span></strong><span>：</span></p><ul><li><span>(1)网络上的</span><mark><span>所有事物都被抽象为资源</span></mark></li><li><span>(2)每个资源对应一个</span><mark><span>唯一的资源标识</span></mark></li><li><span>(3)通过</span><mark><span>通用的连接件接口对资源进行操作</span></mark></li><li><span>(4)对资源的</span><mark><span>各种操作不会改变资源标识</span></mark></li><li><span>(5)所有的操作都是</span><mark><span>无状态的。</span></mark></li></ul></li><li><p><strong><span>微服务架构</span></strong><span>建议</span><mark><span>将大型复杂的单体架构应用划分为一组微小的服务</span></mark><span>，每个微服务根据其负责的具体业务职责</span><mark><span>提炼为单一的业务功能</span></mark><span>;每个服务可以</span><mark><span>很容易地部署并发布到生产环境里隔离和独立的进程内部，</span></mark><span>它可以很容易地扩展和变更;对于一个具体的服务来说可以采用任何适用的语言和工具来快速实现;服务之间基于基础设施互相协同工作</span></p><ul><li><p><span>微服务的优势:</span></p><ul><li><span>(1)</span><mark><span>解决了复杂性问题</span></mark><span>。它把庞大的单一模块应用分解为一系列的服务，同时保持总体功能不变。</span></li><li><span>(2)</span><mark><span>每个服务能够独立开发</span></mark><span>，开发者能够自由选择可行的技术，让服务来决定API约定。</span></li><li><span>(3)</span><mark><span>每个微服务都能独立配置</span></mark><span>，开发者不必协调对于本地服务配置上的变化这种变化一旦测试完成就被配置了。</span></li><li><span>(4)</span><mark><span>每个服务都可以独立调整</span></mark><span>，你可以给每个服务配置正好满足容量和可用性限制的实例数。</span></li></ul></li><li><p><span>微服务架构带来的挑战</span></p><ul><li><span>(1)</span><mark><span>并非所有的系统都能转成微服务</span></mark><span>。例如一些数据库层的底层操作是不推荐服务化的。</span></li><li><span>(2)</span><mark><span>部署较以往架构更加复杂</span></mark><span>:系统由众多微服务搭建，每个微服务需要单独部署，从而增加部署的复杂度，容器技术能够解决这一问题。</span></li><li><span>(3)</span><mark><span>性能问题</span></mark><span>: 由于微服务注重独立性，互相通信时只能通过标准接口，可能产生延迟或调用出错。例如一个服务需要访问另一个服务的数据，只能通过服务间接口来进行数据传输，如果是频繁访问，则可能带来较大的延迟</span></li><li><span>(4)</span><mark><span>数据一致性问题</span></mark><span>: 作为分布式部署的微服务，在保持数据一致性方面需要比传统架构更加困难</span></li></ul></li></ul></li><li><p><mark><span>扩展标记语言</span></mark><span> (Extensible Markup Language,XML)，用于标记</span><mark><span>电子文件使其具有结构性的标记语言</span></mark><span>，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。</span></p><ul><li><p><span>XML的优点</span></p><ul><li><mark><span>格式统一，符合标准</span></mark></li><li><mark><span>容易与其他系统选行远程交互</span></mark><span>，数据共享比较方便</span></li></ul></li><li><p><span>XML的缺点</span></p><ul><li><span>XML</span><mark><span>文件庞大，文件格式复杂</span></mark><span>，传输占带宽</span></li><li><span>服务器端和客户端都</span><mark><span>需要花费大量代码来解析XML</span></mark><span>，导致服务器端和客户端代码变得异常复杂且不易维护;</span></li><li><span>客户端</span><mark><span>不同浏览器之间解析XML的方式不一致</span></mark><span>，需要重复编写很多代码</span></li></ul></li></ul></li><li><p><mark><span>JSON</span></mark><span>(JavaScript Object Notation) </span><mark><span>一种轻量级的数据交换格式</span></mark><span>，具有良好的可读和便于快速编写的特性。</span><mark><span>可在不同平台之间进行数据交换</span></mark></p><ul><li><p><span>JSON的优点</span></p><ul><li><mark><span>数据格式比较简单</span></mark><span>，易于读写，格式都是压缩的，占用带宽小;</span></li><li><mark><span>易于解析</span></mark><span>，客户端JavaScript可以简单的通过eval0进行JSON数据的读取;</span></li><li><mark><span>支持多种语言</span></mark><span>，包括C,C#,ColdFusion,Java,JavaScript, Perl,PHP,Python,Ruby等服务器端语言，便于服务器端的解析;</span></li><li><span>因为</span><mark><span>JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量</span></mark><span>，旦完成任务不变，并且易于维护</span></li></ul></li><li><p><span>JSON的缺点没有XML格式这么推广的深入人心和使用广泛，没有XML那么通用性</span></p></li></ul></li><li><p><mark><span>无状态服务(stateless service) 对单次请求的处理，不依赖其他请求</span></mark><span>，也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到(比如说数据库)，</span><mark><span>服务器本身不存储任何信息</span></mark><span>。</span></p></li><li><p><mark><span>有状态服务(stateful service) 则相反，它会在自身保存一些数据</span></mark><span>，先后的请求是有关联的。</span></p></li><li><p><mark><span>响应式web设计</span></mark><span>:是一种网络页面设计布局，其理念是:集中创建页面的图片排版大小，可以</span><mark><span>智能地根据用户行为以及使用的设备环境进行相对应的布局。</span></mark></p></li><li><p><span>方法与策略：</span></p><ul><li><span>(1)采用流式布局和弹性化设计:使用相对单位，</span><mark><span>设定百分比</span></mark><span>而非具体值的方式设置页面元素的大小。</span></li><li><span>(2)响应式图片:不仅要同比的缩放图片，还要</span><mark><span>在小设备上降低图片自身的分辨率。</span></mark></li></ul></li><li><p><mark><span>MVC</span></mark><span>: MVC强制性地把一个应用的输入、处理、输出流程按照</span><mark><span>视图、控制、模型</span></mark><span>的方式进行分离形成了三个核心模块：</span></p><ul><li><p><span>(1)</span><mark><span>控制器 (Controller)</span></mark><span> : 是应用程序中</span><mark><span>处理用户交互的部分</span></mark><span>。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</span></p></li><li><p><span>(2) </span><mark><span>模型 (Model)</span></mark><span>:是应用程序中用于</span><mark><span>处理应用程序数据逻辑的部分</span></mark><span>。通常模型对象负责在数据库中存取数据模型表示业务数据和业务逻辑。</span></p></li><li><p><span>(3) </span><mark><span>视图 (View)</span></mark><span>: 是应用程序中</span><mark><span>处理数据显示的部分</span></mark><span>通常视图是依据模型数据创建的。是用户看到并与之交互的界面。视图向用户显示相关的数据，并能接收用户的输入数据，但是它并不进行任何实际的业务处理:</span></p><p><img src="http://qn.qs520.mobi/image-20230302100315551.png" referrerpolicy="no-referrer" alt="image-20230302100315551"><span>  </span></p></li></ul></li><li><p><mark><span>MVP</span></mark><span>: MVP是把MVC中的</span><mark><span>Controller换成了Presenter (呈现</span></mark><span>)，</span><mark><span>目的就是为了完全切断View跟Model之间的联系</span></mark><span>，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。MVP特点: </span></p><ol start='' ><li><p><span>M、V、P之间双向通信。</span></p></li><li><p><span>View 与 Model不通信，都通过 Presenter 传递。Presenter完全把Model和view进行了分离，主要的程序逻辑在Presenter里实现。</span></p></li><li><p><span>View 非常薄，不部署任何业务逻辑，称为”被动视图” (PassiveView)，即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</span></p></li><li><p><span>Presenter与具体的view是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。</span></p><p><img src="http://qn.qs520.mobi/image-20230302100504373.png" referrerpolicy="no-referrer" alt="image-20230302100504373"><span> </span></p></li></ol></li><li><p><mark><span>MVVM</span></mark><span>: MVVM模式和MVC模式类似，主要目的是分离视图 (View) 和模型 (Model) ,有几大优点</span></p><ol start='' ><li><p><span>低耦合，视图(View)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</span></p></li><li><p><span>可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</span></p></li><li><p><span>独立开发，开发人员可以专注于业务逻辑和数据的开发(ViewModel) ，设计人员可以专注于页面设计。</span></p></li><li><p><span>可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。</span></p><p><img src="http://qn.qs520.mobi/image-20230302100645931.png" referrerpolicy="no-referrer" alt="image-20230302100645931"><span> </span></p></li></ol></li></ul><h2><a name="span-id18数字与经济管理18数字与经济管理span" class="md-header-anchor"></a><span id="18.数字与经济管理"><span>18.数字与经济管理</span></span></h2><h4><a name="最小生成树" class="md-header-anchor"></a><span>最小生成树</span></h4><p><img src="http://qn.qs520.mobi/image-20230222105947386.png" referrerpolicy="no-referrer" alt="image-20230222105947386"><span> </span></p><h4><a name="最短路径" class="md-header-anchor"></a><span>最短路径</span></h4><p><img src="http://qn.qs520.mobi/image-20230222113352045.png" referrerpolicy="no-referrer" alt="image-20230222113352045"><span> </span></p><p><img src="http://qn.qs520.mobi/image-20230223152520896.png" referrerpolicy="no-referrer" alt="image-20230223152520896"><span> </span></p><h4><a name="网络与最大流量" class="md-header-anchor"></a><span>网络与最大流量</span></h4><p><img src="http://qn.qs520.mobi/image-20230222121348425.png" referrerpolicy="no-referrer" alt="image-20230222121348425"><span> </span></p><h4><a name="线性规划" class="md-header-anchor"></a><span>线性规划</span></h4><ul><li><p><span>在一组约束条件下来寻找目标函数的极值(极大值和极小值) 问题。</span></p></li><li><p><span>线性规划问题的数学模型通常由线性目标函数、线性约束条件、变量非负条件组成(实际问题中的变量一般都是非负的)。</span></p></li><li><p><span>线性规划问题就是面向实际应用，求解一组非负变量，使其满足给定的一组线性约束条任并使某个线性目标函数达到极值。满足这些约束条件的非负变量组的集合称为可行解域。可行解域中使目标函数达到极值的解称为最优解。</span></p></li><li><p><span>线性规划问题的</span><mark><span>最优解要么是0个(没有) ，要么是唯一的(1个) ，要么有无穷个(只要有2个，就会有无穷个)</span></mark><span>。</span></p></li><li><p><span>在实际应用中，可以直接求约束条件方程组的解，即是交叉点，将这些解代入到目标函数中判断是否极值即可。</span></p></li><li><p><span>线性规划问题的求解结果可能出现以下几种情况: </span></p><ul><li><strong><span>得到的最优解是唯一的，</span></strong></li><li><strong><span>无穷多最优解(多重解)，</span></strong></li><li><strong><span>无界解(无最优解)，</span></strong></li><li><strong><span>无可行解。</span></strong></li><li><span>当求解结果出现后两种情况时，一般说明线性规划问题的数学模型有错误。无界解源于缺乏必要的约束条件，无可行解源于矛盾的约束条件。当线性规划问题的可行域非空时，它是有界或无界凸多边形。</span><mark><span>若线性规划问题存在最优解，它一定在可行域的某个顶点得到;若在两个顶点同时得到最优解，则它们连线上的任意一点都是最优解，即有无穷多最优解</span></mark><span>。</span></li></ul><p><img src="http://qn.qs520.mobi/image-20230222153706606.png" referrerpolicy="no-referrer" alt="image-20230222153706606"><span> </span></p></li></ul><h4><a name="动态规划" class="md-header-anchor"></a><span>动态规划</span></h4><p><img src="http://qn.qs520.mobi/image-20230222172233170.png" referrerpolicy="no-referrer" alt="image-20230222172233170"><span> </span></p><h4><a name="伏格尔法" class="md-header-anchor"></a><span>伏格尔法</span></h4><p><img src="http://qn.qs520.mobi/image-20230222185013888.png" referrerpolicy="no-referrer" alt="image-20230222185013888"><span> </span></p><h4><a name="博弈论" class="md-header-anchor"></a><span>博弈论</span></h4><p><img src="http://qn.qs520.mobi/image-20230222194720127.png" referrerpolicy="no-referrer" alt="image-20230222194720127"><span> </span></p><h4><a name="状态转移矩阵" class="md-header-anchor"></a><span>状态转移矩阵</span></h4><p><img src="http://qn.qs520.mobi/image-20230222200350748.png" referrerpolicy="no-referrer" alt="image-20230222200350748"><span> </span></p><h4><a name="排队论" class="md-header-anchor"></a><span>排队论</span></h4><p><img src="http://qn.qs520.mobi/image-20230222201052346.png" referrerpolicy="no-referrer" alt="image-20230222201052346"><span> </span></p><h4><a name="决策论" class="md-header-anchor"></a><span>决策论</span></h4><ul><li><p><span>按决策环境分类</span></p><ul><li><strong><span>确定型决策</span></strong><span>:决策环境是确定的，结果也是确定的。</span></li><li><strong><span>风险决策</span></strong><span>:决策环境是不确定的，但是结果发生的概率是一致的。</span></li><li><strong><span>不确定型决策</span></strong><span>:决策环境不确定，，且结果也不确定，完全凭主观意识来决定</span></li></ul></li><li><p><span>决策的六个要素</span></p><ul><li><mark><span>决策者、可供选择的方案(包括行动、策略) 、量选择方案的准则(目的、目标、正确性等)、事件(被决策的对象) 、每一事件的发生将会产生的某种结果、决策者的价值观</span></mark></li></ul></li><li><p><span>不确定型决策五种方案</span></p><ul><li><p><mark><span>悲观主义准则</span></mark><span>(小中取大max(min)，先取每个方案最小的收益，再取所有最小收益中最大的那个);</span></p></li><li><p><mark><span>乐观主义准则</span></mark><span> (大中取大max(max)，先取每个方案最大的收益，再取所有最大收益中最大的那个);</span></p></li><li><p><span>折中主义准则</span><code>(设定折中系数a，用每个方案的最大收益*a + 最小收益*(1-a)</code><span>，选择每个方案中计算结果最大的那个，可知，</span><strong><span>a=1时为乐观主义，a=0时为悲观主义</span></strong><span>) ;</span></p></li><li><p><span>等可能性准则(设定每个可能的结果的发生都是等可能的，这样就知道每个结果发生的概率，即将不确定型的问题转换为了风险决策问题) ;</span></p></li><li><p><mark><span>后悔值准则</span></mark><span>(最小最大后悔值min(max)，在不同的环境中 (之前都是方案)，投资方案获得的最大收益-当前选择的收益=后悔值，将所有后悔值中每个方案的最大后悔值选出，再从这些最大的后悔值中选择最小的即可)</span></p><p><img src="http://qn.qs520.mobi/image-20230222202737017.png" referrerpolicy="no-referrer" alt="image-20230222202737017"><span> </span></p></li></ul></li></ul><h4><a name="决策树" class="md-header-anchor"></a><span>决策树</span></h4><p><img src="http://qn.qs520.mobi/image-20230222203723376.png" referrerpolicy="no-referrer" alt="image-20230222203723376"><span> </span></p><h4><a name="数学建模" class="md-header-anchor"></a><span>数学建模</span></h4><ul><li><p><span>数学建模是一种数学的思考方法，，是运用数学的语言和方法，通过抽象和简化，建立能近似刻画并解决实际问题的模型的种强有力的数学手段。</span></p></li><li><p><span>数学建摸过程</span></p><ul><li><span>模型准备。了解问题的实际背景，明确其实际意义，掌握对象的各种信息。用数学语言来描述问题</span></li><li><span>模型假设。根据实际对象的特征和建模目的，对问题进行必要的简化，并用精确的语言提出一些恰当的假设</span></li><li><span>模型建立。在假设的基础上，利用适当的数字工具来刻划各变量之间的数学关系，建立相应的数学结构。只要能把问题描述清楚，尽量使用简单的数字工具</span></li><li><span>模型求解。利用获取的数据资料，对模型的所有参数做出计算(估计)</span></li><li><span>模型分析:对所得的结果进行数学上的分析。</span></li><li><span>模型检验:将模型分析结果与实际情形进行比较，以此来验证模型的准确性、合理性和适用性。如果模型与实际较吻合，则要对计算机结果给出其实际含义并解释，如果模型与实际吻合较差，则应该修改假设，再次重复建模过程</span></li><li><span>模型应用: 应用方式因问题的性质和建模的目的而异</span></li></ul></li><li><p><span>数学建模方法</span></p><ul><li><span>直接分析法: 根据对问题直接的内在的认识，直接构造出模型</span></li><li><span>类比法: 根据之前类似的模型构造出一个新的模型。</span></li><li><span>数据分析法: 通过实验获得与问题相关的大量数据，用统计分析的方法来进行建模</span></li><li><span>构想法:对将来可能发生的情况给出逻辑上合理的方法和描述，而后用现有的方法来建模然后不断的完善。</span></li></ul></li></ul><h4><a name="补充方法-指派问题匈牙利指派法" class="md-header-anchor"></a><span>补充方法-指派问题(匈牙利指派法)</span></h4><p><img src="http://qn.qs520.mobi/image-20230222210035439.png" referrerpolicy="no-referrer" alt="image-20230222210035439"><span> </span></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></div>
</body>
</html>