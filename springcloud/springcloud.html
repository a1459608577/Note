<!DOCTYPE html>
<html>
<head>
<title>springCloud</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<base href=''/>
</head>
<body>
<h1>SpringCloud笔记</h1>
<hr />
<h2>SpringCloud升级,部分组件停用:</h2>
<p>1, Eureka停用,可以使用zk作为服务注册中心</p>
<p>2, 服务调用,Ribbon准备停更,代替为LoadBalance</p>
<p>3, Feign改为OpenFeign</p>
<p>4, Hystrix停更,改为resilence4j 或者阿里巴巴的sentienl</p>
<p>5, Zuul改为gateway</p>
<p>6, 服务配置Config改为  Nacos</p>
<p>7, 服务总线Bus改为Nacos</p>
<h2>环境搭建</h2>
<h3>yml文件配置</h3>
<pre><code>server:
  port: 8001 #端口号

spring:
  application:
    name: cloud-payment-service # 服务名称
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    url: jdbc:mysql://localhost:3306/guigu?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8
    password: root
    username: root
    driver-class-name: com.mysql.cj.jdbc.Driver

mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.hnguigu.domain # 实体类所在包名， 会用包名简单映射
</code></pre>

<h3>新建主启动类就可以开始写代码了</h3>
<pre><code>@SpringBootApplication
public class PayMentMain {

    public static void main(String[] args) {
        SpringApplication.run(PayMentMain.class, args);
    }
}
</code></pre>

<h3>使用restTemplate进行远程调用</h3>
<h4>1.导入spring相关依赖，</h4>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<h4>2. 建立一个配置类</h4>
<pre><code>@Configuration
public class ApplicattionContextConfig {

    @Bean
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}
</code></pre>

<h4>3. 调用</h4>
<pre><code>public static final String URL = &quot;http://localhost:8001&quot;;

@Resource
private RestTemplate restTemplate;

@GetMapping(&quot;/payment/add&quot;)
public CommonReault&lt;Payment&gt; add(Payment payment) {
    // 三个参数分别是， 要远程调用的url地址， 第二个是参数， 第三个是返回值类型
    return restTemplate.postForObject(URL + &quot;/payment/payment&quot;, payment, CommonReault.class);
}
</code></pre>

<h2>2. 服务注册与发现</h2>
<h3>1. Eureka</h3>
<h5>Eureka是什么： 它是一个基于REST的服务，有服务发现注册功能，就可以通过服务标识符访问服务，底层是 使用http client进行RPC远程调用(有待补充)</h5>
<h5>能干嘛：</h5>
<ul>
<li>Registe服务注册</li>
<li>Renew服务续约</li>
<li>Fetch Registries获取注册列表信息</li>
<li>Cancel服务下线</li>
<li>Eviction服务剔除</li>
<li><strong>总的来说就是服务注册把微服务注册到eureka的注册中心，然后会建立一个心跳连接，每间隔三十秒发送一次心跳，如果超过九十秒没有发送心跳，注册中心就会把这个微服务剔除， eurekaclient从eurekaserver获取服务注册表信息，将其缓存在jvm中(用到了Ribbon)，然后进行远程连接，每隔30秒刷新一次，若由于某种原因导致注册表信息不能即使匹配，会重新获取整个注册表的信息，他们之间可以通过json或xml传输，一般是用的json，这个就是获取注册表信息，当eirekaclient在程序关闭时可以向server端发送下线请求，发送请求后将从注册中心将其删除，需要手动发请求</strong></li>
</ul>
<blockquote>
<p>DiscoveryManager. getinstance() .shutdownComponent(); 
* <img src="./img/1.png" /></p>
</blockquote>
<h3>单机版Eureka</h3>
<h5>创建项目cloud-eureka-server7001</h5>
<ul>
<li>
<p>改pom</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

</li>
<li>步骤还是和之前一样，，写yml， 建启动类有点不一样，要加一个注解</li>
<li><img src="./img/2.png" /></li>
</ul>
<h5>修改cloud-payment8001项目</h5>
<ul>
<li>
<p>先添加pom</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

</li>
<li>然后在启动类上添加<strong>@EnableEurekaClient</strong>注解，<strong>表示吧这个注册进eureka成为服务提供者</strong></li>
<li>
<p>然后修改yml文件， 添加如下配置</p>
<pre><code>eureka:
  client:
    register-with-eureka: true # 表示是否将自己默认注册进eureka， 默认为true
    fetch-registry: true # 是否从eureka抓取已有的注册信息， 默认为true，单节点无所谓，集群必须设置成true才配合ribbon负载均衡
    service-url:
      defaultZone: http://localhost:7001/eureka  #表示这个要去那个地址注册
</code></pre>

</li>
<li>步骤还是和之前一样，，写yml， 建启动类有点不一样，要加一个注解</li>
<li>先启动eureka注册中心启动类，然后把刚这个启动，在eureka监控页面就能看到</li>
<li><img src="./img/3.png" /></li>
</ul>
<h4>然后把order80项目按照上面的样子修改，然后启动，结果如下</h4>
<ul>
<li><img src="./img/5.png" /></li>
<li><img src="./img/4.png" /></li>
</ul>
<h3>集群Eureka(高可用)</h3>
<ul>
<li><img src="./img/6.png" /></li>
</ul>
<h4>集群Eureka原理说明：互相注册，相互守望</h4>
<ul>
<li>按照搭建项目的样子创建项目cloud-eureka-server7002，pom跟启动类都跟cloud-eureka-server7001一样，配置文件有点不同</li>
<li><strong>eureka7002.com</strong>是因为两台机器不能都用localhost，需要在<strong>C:\Windows\System32\drivers\etc</strong>下修改host文件吧端口映射一下</li>
</ul>
<blockquote>
<p>127.0.0.1  eureka7001.com</p>
<p>127.0.0.1  eureka7002.com</p>
</blockquote>
<pre><code>    server:
      port: 7002

    eureka:
      instance:
        hostname: eureka7002.com #服务端的实例名称
      client:
        register-with-eureka: false  # false表示注册中心不能自己注册自己，
        fetch-registry: false # 表示本端就是注册中心，不用检索服务
        service-url:
          # 设置eureka server交互的地址， 查询服务和注册服务都要依赖这个地址
          defaultZone: http://eureka7001.com:7001/eureka/
</code></pre>

<ul>
<li>然后启动两个启动类</li>
<li>
<p>然后修改8001和80项目的yml</p>
<pre><code>改这个地方就可以了
service-url:
  #defaultZone: http://localhost:7001/eureka 单机版
  defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版
</code></pre>

</li>
<li><img src="./img/7.png" /></li>
</ul>
<h3>支付服务提供者8001集群环境搭建</h3>
<ul>
<li><img src="./img/8.png" /></li>
<li>然后使用消费者访问端口不能写死</li>
</ul>
<blockquote>
<p>public static final String URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;;</p>
</blockquote>
<ul>
<li><img src="./img/9.png" /></li>
<li>使用<strong>@LoadBalanced</strong>注解让消费者实现负载均衡，在8001,8002两个端口中切换</li>
<li><img src="./img/10.png" /></li>
<li>
<p>修改在eureka注册信息表中的服务名称和访问信息有ip信息提示</p>
<ul>
<li>
<p>只需要在yml文件中的eureka中添加如下配置</p>
<pre><code>instance:
    instance-id: payment8001
    prefer-ip-address: true
</code></pre>

</li>
</ul>
</li>
</ul>
<h3>Eureka的自我保护</h3>
<ul>
<li><img src="./img/11.png" /></li>
</ul>
<h4>原因：</h4>
<ul>
<li>某个时候某一个微服务不能用了不会被立即删除，依旧会对他进行保存<strong>属于CAP中的AP分支</strong></li>
<li><img src="./img/12.png" /></li>
</ul>
<h4>禁用自我保护机制</h4>
<ul>
<li>先把7001和8001变成单机版，然后修改yml配置，然后关闭8001的服务，会发现立即被删除了，之前是不会立即删除的</li>
<li><img src="./img/13.png" /></li>
</ul>
<h3>2. Zookeeper作为注册中心</h3>
<h4>还是建工程，改pom， 写yml</h4>
<ul>
<li>
<p>pom文件的差别</p>
<pre><code>&lt;!--SpringBoot整合Zookeeper客户端--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;!--先排除自带的zookeeper3.5.3， 不然会报错，要跟linux上安装的zookeeper版本一致--&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;!--添加zookeeper3.4.14版本--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
    &lt;version&gt;3.4.14&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

</li>
</ul>
<h4>改yml</h4>
<pre><code>server:
  port: 8004  # 表示注册到zookeeper服务器的支付提供者的端口号
spring:
  application:
    name: cloud-zookeeper-payment  # 表示注册到zookeeper的服务名
  cloud:
    zookeeper:
      connect-string: 192.168.43.79:2181 # linux的ip地址，加zookeeper的端口号
</code></pre>

<h4>启动类</h4>
<pre><code>@SpringBootApplication
@EnableDiscoveryClient //该注解作用于consul或zookeeper作为注册中心时的注册服务
public class PayMentMain8004 {

    public static void main(String[] args) {
        SpringApplication.run(PayMentMain8004.class, args);
    }
}
</code></pre>

<h4>controller业务类</h4>
<pre><code>@RestController
@RequestMapping(&quot;/payment&quot;)
@Slf4j
public class PamentController {

    @Value(&quot;${server.port}&quot;)
    private String port;

    @GetMapping(&quot;/payment/zk&quot;)
    public String paymentzk() {
        return &quot;springcloud with zookeeper&quot; + port  + &quot;**     &quot; + UUID.randomUUID().toString();
    }
}
</code></pre>

<h3>3. Consul</h3>
<h3>介绍</h3>
<ul>
<li><img src="./img/14.png" /></li>
<li><img src="./img/15.png" /></li>
</ul>
<h3>创建项目</h3>
<h4>1. 改pom，新增如下pom依赖就可</h4>
<pre><code>&lt;!--SpringCloud consul-server--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<h4>2. 写yml</h4>
<pre><code>server:
  port: 80

spring:
  application:
    name: cloud-consumer-order

  # consul注册中心
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: ${spring.application.name}
      #hostname: 127.0.0.1
</code></pre>

<h4>3. 其他还跟之前一样</h4>
<h3>三个注册中心的异同</h3>
<ul>
<li><img src="./img/16.png" /></li>
<li><img src="./img/18.png" /></li>
<li><img src="./img/17.png" /></li>
</ul>
<h2>3. Ribbon负载均衡服务调用</h2>
<h3>简介</h3>
<h4>是什么</h4>
<ul>
<li>Ribbon是通过restTemplate实现提供给客户端做负载均衡的，有五种的方式<strong>(轮询， 哈希， 随机， 权重， 自定义)</strong></li>
<li>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。</li>
</ul>
<h4>LB方案分类</h4>
<ul>
<li>目前主流的LB方案可分成两类：一种是<strong>集中式LB</strong>, 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；另一种是<strong>进程内LB</strong>，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于后者，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址</li>
<li><img src="./img/19.png" /></li>
</ul>
<h3>Ribbon负载均衡演示</h3>
<ul>
<li>
<p><img src="./img/20.png" /></p>
<pre><code>//使用getEntry
@GetMapping(&quot;/payment/getEntity/{id}&quot;)
public CommonReault&lt;Payment&gt; queryById1(@PathVariable Integer id) {
    ResponseEntity&lt;CommonReault&gt; entity = restTemplate.getForEntity(URL + &quot;/payment/payment/&quot; + id, CommonReault.class);
    if (entity.getStatusCode().is2xxSuccessful()) {
        return entity.getBody();
    } else {
        return new CommonReault(444, &quot;失败&quot;);
    }
}
</code></pre>

</li>
</ul>
<h3>Ribbon核心组件IRule</h3>
<ul>
<li><img src="./img/21.png" /></li>
</ul>
<h4>如何替换</h4>
<ul>
<li><img src="./img/22.png" /></li>
</ul>
<h3>Ribbon负载均衡算法</h3>
<h4>原理</h4>
<ul>
<li><img src="./img/24.png" /></li>
<li><img src="./img/23.png" /></li>
<li><strong>就是RestTemplate发起一个请求，这个请求被LoadBalancerInterceptor给拦截了，拦截后将请求的地址中的服务逻辑名转为具体的服务地址，然后继续执行请求，就是这么一个过程。</strong></li>
</ul>
<h4>源码</h4>
<pre><code>private AtomicInteger nextServerCyclicCounter; //原子整形类
private static final boolean AVAILABLE_ONLY_SERVERS = true;
private static final boolean ALL_SERVERS = false;

public Server choose(ILoadBalancer lb, Object key) {
    // 没有负载均衡规则直接报错
    if (lb == null) {
        log.warn(&quot;no load balancer&quot;);
        return null;
    }

    Server server = null;
    int count = 0;
    while (server == null &amp;&amp; count++ &lt; 10) {
        List&lt;Server&gt; reachableServers = lb.getReachableServers();  //把活着的健康的机器选出来
        List&lt;Server&gt; allServers = lb.getAllServers(); //拿到所有的机器
        int upCount = reachableServers.size();
        int serverCount = allServers.size();

        if ((upCount == 0) || (serverCount == 0)) {
            log.warn(&quot;No up servers available from load balancer: &quot; + lb);
            return null;
        }

        int nextServerIndex = incrementAndGetModulo(serverCount);
        server = allServers.get(nextServerIndex);

        if (server == null) {
            /* Transient. */
            Thread.yield();
            continue;
        }

        if (server.isAlive() &amp;&amp; (server.isReadyToServe())) {
            return (server);
        }

        // Next.
        server = null;
    }

    if (count &gt;= 10) {
        log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;
                + lb);
    }
    return server;
}

/**
 * Inspired by the implementation of {@link AtomicInteger#incrementAndGet()}.
 *
 * @param modulo The modulo to bound the value of the counter.
 * @return The next value.
 */
private int incrementAndGetModulo(int modulo) {
    //自旋锁
    for (;;) {
        int current = nextServerCyclicCounter.get();
        int next = (current + 1) % modulo;
        if (nextServerCyclicCounter.compareAndSet(current, next)) //比较并设值
            return next;
    }
}
</code></pre>

<ul>
<li>用了JUC(CAS和自旋锁的复习)</li>
</ul>
<h4>手写</h4>
<h2>4. OpenFeign服务接口调用</h2>
<h3>简介</h3>
<h4>是什么</h4>
<ul>
<li>Feign是一个声明式的Web Service客户端。它的出现使开发Web Service客户端变得很简单。使用Feign只需要创建一个接口加上对应的注解，比如：@FeignClient注解。</li>
</ul>
<h4>能干嘛</h4>
<ul>
<li><img src="./img/25.png" /></li>
</ul>
<h4>Feign跟OpenFeign的区别</h4>
<ul>
<li><img src="./img/26.png" /></li>
</ul>
<h3>使用步骤</h3>
<h4>1. 接口加注解： 微服务调用接口 + @FeignClient</h4>
<h4>2. 新建cloud-consumer-feign-order80项目： Feign在消费端使用</h4>
<h4>3. pom</h4>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
    &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h4>4. yml</h4>
<pre><code>server:
  port: 80

eureka:
  client:
    register-with-eureka: false
    service-url: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/
</code></pre>

<h4>5. 启动类</h4>
<pre><code>@SpringBootApplication
@EnableFeignClients //表示使用Feign，激活Feign
public class OrderFeignMain80 {

    public static void main(String[] args) {
        SpringApplication.run(OrderFeignMain80.class, args);
    }
}
</code></pre>

<h4>6.业务类</h4>
<ul>
<li>业务逻辑接口 + @FeignClient配置调用orivider服务</li>
<li>
<p>新建PaymentFeignService接口并添加<strong>@FeignClient</strong>注解</p>
<pre><code>@FeignClient(&quot;CLOUD-PAYMENT-SERVICE&quot;) //表示要访问哪个服务
@Component
public interface PaymentFeignService {

    @GetMapping(&quot;/payment/payment/{id}&quot;)
    public CommonReault&lt;Payment&gt; queryById(@PathVariable(&quot;id&quot;) Integer id);
}
</code></pre>

</li>
<li>
<p>控制层controller</p>
<pre><code>@RestController
@RequestMapping(&quot;/consumer&quot;)
@Slf4j
public class OrderFeignController {

    @Autowired
    private PaymentFeignService paymentFeignService;

    @GetMapping(&quot;/order/{id}&quot;)
    public CommonReault&lt;Payment&gt; getById(@PathVariable Integer id) {
        return  paymentFeignService.queryById(id);
    }
}
</code></pre>

</li>
<li><img src="./img/27.png" /></li>
</ul>
<h4>7. 测试： Feign自带负载均衡规则</h4>
<h3>超时控制</h3>
<h4>超过一秒钟就会报错</h4>
<h4>需要配置yml</h4>
<pre><code>#设置feign的超时时间（openfeign默认支持ribbon）
ribbon:
  ReadTimeout: 5000  # 指的是建立连接所用的时间， 使用用两端网络正常的原因，两端所用的时间
  ConnectTimeout: 5000 # 指的是建立连接后从服务器读取到可用资源所用的时间
</code></pre>

<h3>日志打印功能</h3>
<h4>是什么</h4>
<ul>
<li><img src="./img/28.png" /></li>
</ul>
<h4>日止级别</h4>
<ul>
<li><img src="./img/29.png" /></li>
</ul>
<h4>配置日志bean</h4>
<pre><code>@Configuration
public class FeignConfig {

    @Bean
    Logger.Level feignLoggerLevel () {
        return Logger.Level.FULL;
    }
}
</code></pre>

<h4>yml文件里需要开启日志的Feign客户端</h4>
<pre><code>logging:
  level:
    # feign日志以什么级别监控哪个接口
    com.hnguigu.springcloud.service.PaymentFeignService: debug
</code></pre>

<h4>后台日志查看</h4>
<h2>5. 服务降级，Hystrix断路器</h2>
<h3>概述</h3>
<ul>
<li><img src="./img/30.png" /></li>
</ul>
<h4>能干嘛：服务降级，服务熔断，接近实时的监控</h4>
<h3>Hystrix重要概念</h3>
<h4>服务降级</h4>
<ul>
<li>作用： <strong>不让客户端等待并l立刻返回一个友好提示， fallback</strong></li>
<li>
哪些情况会触发降级
<ul>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池/信号量打满也会导致服务降级</li>
</ul>
</li>
</ul>
<h4>服务熔断</h4>
<ul>
<li>类比保险丝达到最大访问后，直接拒绝访问，拉闸断电，然后调用服务降级的方法并返回友好提示</li>
</ul>
<h4>服务限流</h4>
<ul>
<li>秒杀高并发等操作，严禁一窝蜂的拥挤过来，大家排队，一秒钟N个，有序进行</li>
</ul>
<h3>Hystrix案例(解决方案)</h3>
<h4>服务降级</h4>
<h5>1. 8001fallback</h5>
<ul>
<li>业务类启用： <strong>@HystrixCommand</strong></li>
<li>
<p>主启动类激活： <strong>添加这个注解@EnableCircuitBreaker</strong></p>
<pre><code>//表示使用哪个方法兜底，就是出异常或者超时后会执行这个方法
    @HystrixCommand(fallbackMethod = &quot;payemntInfo_TimeOutHandler&quot;, commandProperties = {
            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;3000&quot;)
            // timeoutInMilliseconds  这个线程的超时时间是3秒
    })
    public String payemntInfo_TimeOut (Integer id) {
        int a = 10/0;
        return &quot;线程池： &quot; + Thread.currentThread().getName() + &quot;payemntInfo_TimeOut, id:&quot; + id + &quot;耗时(秒)&quot;;
//        int time = 5;
//        try { TimeUnit.SECONDS.sleep(time); } catch (InterruptedException e) { e.printStackTrace(); }
//        return &quot;线程池： &quot; + Thread.currentThread().getName() + &quot;payemntInfo_TimeOut, id:&quot; + id + &quot;耗时(秒)&quot; + time;
    }

    public String payemntInfo_TimeOutHandler (Integer id) {
        return &quot;线程池： &quot; + Thread.currentThread().getName() + &quot;payemntInfo_TimeOutHandler, id:&quot; + id + &quot;兜底方法&quot;;
    }

然后在主启动类上加@EnableCircuitBreaker这个注解，即可实现服务降级，不管出异常还是超时都会进兜底方法
</code></pre>

</li>
</ul>
<h5>2. 80fallback(服务降级一般放在客户端)</h5>
<ul>
<li>
<p>先配置yml</p>
<pre><code>spring:
  application:
    name: cloud-hystrix-order

feign:
  hystrix:
    enabled: true
</code></pre>

</li>
<li>
<p>在controller里加上</p>
<pre><code>@GetMapping(&quot;/order/payment/hystrix/timeout/{id}&quot;)
@HystrixCommand(fallbackMethod = &quot;orderInfo_TimeOutMethods&quot;, commandProperties = {
        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;)
})
public String payemntInfo_TimeOut (@PathVariable Integer id) {
    return  orderHystrixService.payemntInfo_TimeOut(id);
}

public String orderInfo_TimeOutMethods(@PathVariable(&quot;id&quot;) Integer id) {
    return  &quot;80兜底方法&quot;;
}
</code></pre>

</li>
<li>然后在80主启动类上加注解： <strong>@EnableHystrix</strong></li>
</ul>
<h5>目前问题：</h5>
<ul>
<li>每一个业务类对应一个兜底方法，代码膨胀</li>
<li>与业务逻辑代码混合了</li>
</ul>
<h5>解决问题</h5>
<ul>
<li>
每个方法配置一个？？？膨胀
<ul>
<li>在controller上加<strong>@DefaultProperties(defaultFallback = &quot;globalFallBack&quot;)</strong>注解，其中globalFallBack是一个方法，被指定成全局异常处理方法。 在controller方法上只写@HystrixCommand即可，<strong>这样通用的和独享 的就分开了，减少代码量</strong></li>
</ul>
</li>
<li>
<p>与业务逻辑代码混一起？？？混乱</p>
<ul>
<li>
<p>写一个类实现有feign接口的接口，然后重写类里的方法，再到接口的<strong>@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)</strong>注解上加<strong>, fallback = PaymentFallbackService.class</strong>，再到yml里配置一下</p>
<pre><code>feign:
  hystrix:
    enabled: true
</code></pre>

</li>
</ul>
</li>
<li><img src="./img/31.png" /></li>
</ul>
<h4>服务熔断</h4>
<ul>
<li><img src="./img/32.png" /></li>
<li><img src="./img/33.png" /></li>
<li><img src="./img/34.png" /></li>
</ul>
<h4>服务限流</h4>
<ul>
<li>高级篇Sentinel讲</li>
</ul>
<h3>Hystrix工作流程</h3>
<ul>
<li>
<p><img src="./img/35.png" /></p>
<pre><code>1请求进来,首先查询缓存,如果缓存有,直接返回
    如果缓存没有,---&gt;2
2,查看断路器是否开启,如果开启的,Hystrix直接将请求转发到降级返回,然后返回
    如果断路器是关闭的,
                判断线程池等资源是否已经满了,如果已经满了
                    也会走降级方法
            如果资源没有满,判断我们使用的什么类型的Hystrix,决定调用构造方法还是run方法
        然后处理请求
        然后Hystrix将本次请求的结果信息汇报给断路器,因为断路器此时可能是开启的
                    (因为断路器开启也是可以接收请求的)
                断路器收到信息,判断是否符合开启或关闭断路器的条件,
                如果本次请求处理失败,又会进入降级方法
        如果处理成功,判断处理是否超时,如果超时了,也进入降级方法
        最后,没有超时,则本次请求处理成功,将结果返回给controller
</code></pre>

</li>
</ul>
<h3>服务监控HystrixDashboard</h3>
<ul>
<li><img src="./img/36.png" /></li>
<li><img src="./img/37.png" /></li>
</ul>
<h4>断路器演示</h4>
<pre><code>需要在被监控的工程的主启动类里加如下代码

/**
 * 此配置是为了服务监控而配置，与服务 容错本身无关，springcloud 升级后的坑
 * ServletRegistrationBean因为springboot的默认路径不是&quot;/hystcix. stream&quot;,
 * 只要在自己的项目里配置上:下面的servlet就可以了
 **/
@Bean
public ServletRegistrationBean getServlet() {
    HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
    ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
    registrationBean.setLoadOnStartup(1);
    registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);
    registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);
    return registrationBean;
}
</code></pre>

<ul>
<li><img src="./img/38.png" /></li>
</ul>
<h2>6. 服务网关gateway</h2>
<h3>简介</h3>
<h4>SpringCloud Gateway使用的Webflex中的reactor-netty响应式编程组件， 底层使用了netty通讯框架</h4>
<ul>
<li><img src="./img/39.png" /></li>
</ul>
<h4>能干嘛： 反向代理，鉴权， 流量控制， 熔断， 日志监控</h4>
<ul>
<li><img src="./img/40.png" /></li>
</ul>
<h3>三大核心概念</h3>
<h4>路由：构建网关的基本模块，它是由ID， 目标URI， 一系列断言和过滤器组成，如果断言为true则匹配该路由</h4>
<h4>Predicate(断言)：参考的是Java8的java.util.function.Predicate,开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由</h4>
<h4>Filter(过滤):指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</h4>
<h4>总体</h4>
<ul>
<li><img src="./img/41.png" /></li>
</ul>
<h3>Gateway工作流程</h3>
<ul>
<li><img src="./img/42.png" /></li>
</ul>
<h3>入门配置</h3>
<ul>
<li><img src="./img/43.png" /></li>
</ul>
<h3>通过微服务名实现动态路由</h3>
<ul>
<li><img src="./img/44.png" /></li>
</ul>
<h3>Predicate的使用</h3>
<ul>
<li><img src="./img/45.png" /></li>
</ul>
<h3>Filter的使用</h3>
<h4>自定义Filter</h4>
<ul>
<li><img src="./img/46.png" /></li>
</ul>
<h2>7. 分布式配置中心SpringCloud Config</h2>
<h3>概述</h3>
<h4>是什么</h4>
<ul>
<li><img src="./img/47.png" /></li>
</ul>
<h3>Config服务端配置与测试</h3>
<h4>先使用git命令吧仓管clone到本地</h4>
<ul>
<li>git addr .</li>
<li>git commit -m &quot;注释&quot;</li>
<li>git push -u origin master</li>
</ul>
<h4>pom</h4>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<h4>yml</h4>
<pre><code>server:
  port: 3344

spring:
  application:
    name: cloud-config-center
  cloud:
    config:
      server:
        git:
          uri: git@github.com:a1459608577/springcloud-config.git  #github上仓库的名字
          search-paths:  # 搜索目录
            - springcloud-config
      label: master  #读取分支
eureka:
  client:
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka
</code></pre>

<h4>启动类</h4>
<pre><code>@SpringBootApplication
@EnableConfigServer
public class ConfigCenterMain3344 {

    public static void main(String[] args) {
        SpringApplication.run(ConfigCenterMain3344.class, args);
    }
}
</code></pre>

<h4>增加映射 127.0.0.1 config-3344.com</h4>
<h4>从git上获取内容</h4>
<h4>配置的读取规则</h4>
<ul>
<li><img src="./img/48.png" /></li>
</ul>
<h3>Config客户端配置与测试</h3>
<h4>其他配置都一样，不一样的写在下面</h4>
<ul>
<li><img src="./img/49.png" /></li>
</ul>
<h3>Config客户端之动态刷新</h3>
<ul>
<li><img src="./img/50.png" /></li>
</ul>
<h2>8. SpringCloud Bus消息总线</h2>
<h3>概述</h3>
<ul>
<li><img src="./img/51.png" /></li>
</ul>
<h3>SpringCloud Bus动态刷新全局广播</h3>
<ul>
<li><img src="./img/52.png" /></li>
</ul>
<h3>SpringCloud Bud动态刷新定点通知</h3>
<ul>
<li><img src="./img/53.png" /></li>
</ul>
<h2>9. SpringCloud Stream消息驱动</h2>
<h3>概述</h3>
<h4>是什么：屏蔽底层消息中间件的差异，降低切换成本， 统一消息的编程模型</h4>
<ul>
<li><img src="./img/54.png" /></li>
</ul>
<h4>设计思想</h4>
<ul>
<li><img src="./img/56.png" /></li>
</ul>
<h4>SpringCloud Stream标准流程套路</h4>
<ul>
<li><img src="./img/57.png" /></li>
</ul>
<h4>常用api和常用注解</h4>
<ul>
<li><img src="./img/55.png" /></li>
</ul>
<h3>消息驱动之生产者</h3>
<h4>pom</h4>
<pre><code>&lt;!--stream rabbit --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>

<h4>yml</h4>
<pre><code>server:
  port: 8801

spring:
  application:
    name: cloud-stream-rabbit-provider
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitmq的服务信息
        defaultRabbit: # 表示定义的名称，用于与binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
                host: localhost
                port: 5672
                username: guest
                password: guest
      bindings: #  服务的整合处理
        output: # 这个是一个通道的名称
          destination: studyEachange # 表示要定义的Exchange的名称
          content-type: application/json # 设置消息类型  本次为json  文本则设置“text/plain”
          binders: defaultRabbit # 设置要绑定的消息服务的具体设置， 就是上面的defaultRabbit
eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka
  instance:
    lease-renewal-interval-in-seconds: 2 # 设置心跳时间间隔(默认是30秒)
    lease-expiration-duration-in-seconds: 5 # 间隔时间(默认为90秒)
    instance-id: send-8801.com # 在信息列表时显示主机名称
    prefer-ip-address: true # 访问路径变为ip地址
</code></pre>

<h4>启动类</h4>
<pre><code>@SpringBootApplication
@EnableEurekaClient
public class StreamRabbitmqMain8801 {

    public static void main(String[] args) {
        SpringApplication.run(StreamRabbitmqMain8801.class, args);
    }
}
</code></pre>

<h4>业务类</h4>
<pre><code>新建一个接口和实现类(service)

@EnableBinding(Source.class)  // 定义消息的推送管道，就相当于output输出管道
public class IMessageProviderImpl implements IMessageProvider {

    @Resource
    private MessageChannel output; //消息发送管理

    @Override
    public String send() {
        String s = UUID.randomUUID().toString();
        output.send(MessageBuilder.withPayload(s).build());
        System.out.println(&quot;***********序列号**&quot; + s);
        return null;
    }
}


新建controller

@RestController
@Slf4j
public class SendMessageController {

    @Resource
    private IMessageProvider iMessageProvider;

    @GetMapping(&quot;/sendMessage&quot;)
    public String sendMessage() {
        return iMessageProvider.send();
    }
}
</code></pre>

<h3>消息驱动之消费者</h3>
<h4>一直到业务类之前都是跟生产者一样，唯一不同就是yml文件中的output改成input</h4>
<h4>业务类</h4>
<pre><code>@Component
@EnableBinding(Sink.class)
public class ReceiveMessageListenerController {

    @Value(&quot;${server.port}&quot;)
    private String port;

    @StreamListener(Sink.INPUT)
    public void input(Message&lt;String&gt; message) {
        System.out.println(&quot;消费者一号*****接受到的消息:&quot; + message.getPayload() + &quot;----端口port：&quot; + port);
    }
}
</code></pre>

<h4>测试结果：8801发送的uuid在8802这边可以收到</h4>
<h3>分组消费与持久化</h3>
<h4>消费：存在重复消费的问题，就是一个订单被两个人获取到造成重复消费，原因是两个消费者不是同一个组，默认分组的group不同，组流水号不同，所以可以重复消费，在同一个组的话就不能重复消费了</h4>
<h4>分组(解决重复消费)</h4>
<ul>
<li><img src="./img/58.png" /></li>
</ul>
<h4>持久化</h4>
<ul>
<li><img src="./img/59.png" /></li>
</ul>
<h2>10. SpringCloud Sleuth分布式请求链路跟踪</h2>
<ul>
<li><img src="./img/60.png" /></li>
</ul>
<h3>概述</h3>
<h4>在分布式系统中提供追踪解决方案并兼容支持了zipkin</h4>
<h4><a href="https://cloud.spring.io/spring-cloud-sleuth/reference/html/#features">官网</a></h4>
<ul>
<li><img src="./img/61.png" /></li>
</ul>
<h3>搭建链路监控步骤</h3>
<ul>
<li><img src="./img/62.png" /></li>
</ul>
<h2>11. SpringCloud Alibaba Nacos服务注册和配置中心，<a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html">官方文档</a></h2>
<h3>Nacos简介，<a href="https://nacos.io/zh-cn/">官网</a></h3>
<ul>
<li><img src="./img/63.png" /></li>
</ul>
<h3>安装并运行Nacos，<a href="https://github.com/alibaba/nacos/releases">下载地址</a></h3>
<h4>解压后直接运行bin下的startup.cmd命令，运行成功后访问http://localhost:8848/nacos即可，默认账号密码都是nacos</h4>
<h3>Nacos作为服务注册中心演示</h3>
<h4>生产者的配置pom</h4>
<pre><code>&lt;dependency&gt;   //父pom
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;  //子pom
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<h4>yml</h4>
<pre><code>server:
  port: 9001

spring:
  application:
    name: nacos-payment-provider
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
management:
  endpoints:
    web:
      exposure:
        include: *
</code></pre>

<h4>启动类跟之前一样，业务类随便写个能访问的就行</h4>
<h4>投机取巧的方法，虚拟映射</h4>
<ul>
<li><img src="./img/64.png" /></li>
</ul>
<h4>消费者配置</h4>
<ul>
<li><img src="./img/65.png" /></li>
<li><img src="./img/66.png" /></li>
</ul>
<h3>Nacos作为服务配置中心演示</h3>
<h4>Nacao作为配置中心-基础配置</h4>
<ul>
<li><img src="./img/68.png" /></li>
<li><img src="./img/67.png" /></li>
</ul>
<h4>Nacao作为配置中心-分类配置</h4>
<ul>
<li><img src="./img/69.png" /></li>
</ul>
<h3>Nacos集群和持久化配置</h3>
<h4>官网说明</h4>
<ul>
<li><img src="./img/70.png" /></li>
</ul>
<h4>Nacos持久化配置解释</h4>
<ul>
<li><img src="./img/71.png" /></li>
</ul>
<h4>Linux版Nacos + MySql生产环境配置</h4>
<ul>
<li><img src="./img/72.png" /></li>
</ul>
<h2>12. SpringCloud Alibaba Sentinel实现熔断和限流</h2>
<h3>Sebtinel</h3>
<h4><a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">官方文档</a>，<a href="https://github.com/alibaba/Sentinel/releases">下载链接</a></h4>
<ul>
<li><img src="./img/73.png" /></li>
<li><img src="./img/74.png" /></li>
</ul>
<h3>初始化演示工程</h3>
<ul>
<li><img src="./img/75.png" /></li>
</ul>
<h3>流控规则</h3>
<h4>基本介绍</h4>
<ul>
<li><img src="./img/76.png" /></li>
</ul>
<h4>流控模式</h4>
<h5>直接(默认)</h5>
<ul>
<li><img src="./img/77.png" /></li>
</ul>
<h5>关联</h5>
<ul>
<li><img src="./img/79.png" /></li>
<li><img src="./img/78.png" /></li>
</ul>
<h5>链路</h5>
<h4>流控效果</h4>
<ul>
<li><img src="./img/80.png" /></li>
</ul>
<h3>降级规则</h3>
<ul>
<li><img src="./img/81.png" /></li>
</ul>
<h4>降级策略实战</h4>
<h5>1. RT(平均响应时间)</h5>
<ul>
<li><img src="./img/82.png" /></li>
</ul>
<h5>2. 异常比例</h5>
<ul>
<li><img src="./img/83.png" /></li>
</ul>
<h5>3. 异常数</h5>
<ul>
<li><img src="./img/84.png" /></li>
</ul>
<h3>热点key限流</h3>
<h4>使用热点规则</h4>
<ul>
<li><img src="./img/85.png" /></li>
</ul>
<h4>参数例外项</h4>
<ul>
<li><img src="./img/86.png" /></li>
</ul>
<h3>系统规则(系统自适应限流)</h3>
<ul>
<li><img src="./img/87.png" /></li>
</ul>
<h3>@SentinelResource</h3>
<ul>
<li><img src="./img/88.png" /></li>
</ul>
<h3>服务熔断功能，sentinel整合ribbon + openfeign + fallback</h3>
<h4>Ribbon系列</h4>
<ul>
<li><img src="./img/89.png" /></li>
</ul>
<h4>Feign系列</h4>
<ul>
<li><img src="./img/90.png" /></li>
</ul>
<h4>熔断框架比较</h4>
<ul>
<li><img src="./img/91.png" /></li>
</ul>
<h3>规则持久化</h3>
<ul>
<li><img src="./img/92.png" /></li>
</ul>
<h2>13. SpringCloud Alibaba Seata处理分布式事务</h2>
<h3>分布式事务问题</h3>
<h4>打个比方，淘宝下单有订单库，有金融库，这两个库看似没有关系，实则是一个事务里的，要么一起成功，要么一起失败，订单失败金额不减少，订单成功金额减少，所以就有了分布式事务的问题</h4>
<h3>Seata简介， <a href="http://seata.io/zh-cn/">官网</a></h3>
<h4>1. Seata是用来解决分布式事务的一个解决方案</h4>
<ul>
<li><img src="./img/93.png" /></li>
</ul>
<h3>Seata-Server安装</h3>
<ul>
<li><img src="./img/94.png" /></li>
</ul>
<h3>订单/库存/账户业务数据库准备</h3>
<ul>
<li><img src="./img/95.png" /></li>
</ul>
<h3>订单/库存/账户业务微服务准备</h3>
<ul>
<li><img src="./img/96.png" /></li>
</ul>
<h3>Test</h3>
<h3>补充</h3>
<ul>
<li><img src="./img/97.png" /></li>
</ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
