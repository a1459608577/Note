<!DOCTYPE html>
<html>
<head>
<title>springsecurity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<base href=''/>
</head>
<body>
<h1>Spring Security</h1>
<h2>1. CAS整合 Spring Security(一)</h2>
<p><img src="./img/1.png" /></p>
<h3>三个概念</h3>
<ul>
<li><strong>TGT</strong>：TGT 全称叫做 Ticket Granting Ticket，这个相当于我们平时所见到的 HttpSession 的作用，用户登录成功后，用户的基本信息，如用户名、登录有效期等信息，都将存储在此。</li>
<li><strong>TGC</strong>：TGC 全称叫做 Ticket Granting Cookie，TGC 以 Cookie 的形式保存在浏览器中，根据 TGC 可以帮助用户找到对应的 TGT，所以这个 TGC 有点类似与会话 ID。</li>
<li><strong>ST</strong>：ST 全称是 Service Ticket，这是 CAS Sever 通过 TGT 给用户发放的一张票据，用户在访问其他服务时，发现没有 Cookie 或者 ST ，那么就会 302 到 CAS Server 获取 ST，然后会携带着 ST 302 回来，CAS Client 则通过 ST 去 CAS Server 上获取用户的登录状态。</li>
</ul>
<h3>CAS登录流程</h3>
<p><img src="./img/2.png" /></p>
<h1></h1>
<ol>
<li>用户通过浏览器访问应用1，应用1 发现用户没有登录，于是返回 302，并且携带上一个 service 参数，让用户去 CAS Server 上登录。</li>
<li>浏览器自动重定向到 CAS Server 上，CAS Server 获取用户 Cookie 中携带的 TGC，去校验用户是否已经登录，如果已经登录，则完成身份校验（此时 CAS Server 可以根据用户的 TGC 找到 TGT，进而获取用户的信息）；如果未登录，则重定向到 CAS Server 的登录页面，用户输入用户名/密码，CAS Server 会生成 TGT，并且根据 TGT 签发一个 ST，再将 TGC 放在用户的 Cookie 中，完成身份校验。</li>
<li>CAS Server 完成身份校验之后，会将 ST 拼接在 service 中，返回 302，浏览器将首先将 TGC 存在 Cookie 中，然后根据 302 的指示，携带上 ST 重定向到应用1。</li>
<li>应用1 收到浏览器传来的 ST 之后，拿去 CAS Server 上校验，去判断用户的登录状态，如果用户登录合法，CAS Server 就会返回用户信息给 应用1。</li>
<li>浏览器再去访问应用2，应用2 发现用户未登录，重定向到 CAS Server。</li>
<li>CAS Server 发现此时用户实际上已经登录了，于是又重定向回应用2，同时携带上 ST。</li>
<li>应用2 拿着 ST 去 CAS Server 上校验，获取用户的登录信息。</li>
</ol>
<h3>搭建CAS Server服务</h3>
<h4>1. 下载构建CAS Server的模板,版本选择5.3的maven版</h4>
<blockquote>
<p>https://github.com/apereo/cas-overlay-template</p>
</blockquote>
<h4>2. 生成HTTPS证书，云服务申请，或者去买，或者jdk自带的keytool工具</h4>
<blockquote>
<p>keytool -genkey -alias casserver -keyalg RSA -keystore ./keystore</p>
</blockquote>
<p><img src="./img/3.png" /></p>
<h4>3. 配置并启动</h4>
<h6>1. 首先进入cas-overlay-template下，打开cmd，输入mvn clean package，在新建目录src/main/resource，再把verlays/org.apereo.cas.cas-server-webapp-tomcat-5.3.14/WEB-INF/classes/application.properties文件跟生成的keystore放到resources下，如图：</h6>
<p><img src="./img/4.png" /></p>
<h6>2. 更改application.properties配置文件，配置keystore的地址和password</h6>
<p><img src="./img/5.png" /></p>
<h6>3. 在当前项目下执行<code>build.cmd run</code>，第一次会有点久，成功后如图：</h6>
<p><img src="./img/6.png" /></p>
<h6>4. 输入<code>https://127.0.0.1:8443/cas/login</code>,访问成功即可。默认的用户名是 casuser，密码是 Mellon。可以再配置文件中修改,改完重启即可</h6>
<blockquote>
<p>cas.authn.accept.users=casuser::Mellon</p>
</blockquote>
<p><img src="./img/7.png" /></p>
<h6>5. 配置用户从数据库读取，打开https://github.com/javalanxiongwei/cas-overlay-template-master/blob/master/cas.sql，拿到cas.sql文件并执行。此时会多出一张用户表sys_user</h6>
<p><img src="./img/8.png" /></p>
<h6>6. 在pom.xml中新增依赖</h6>
<pre><code>&lt;!--新增支持jdbc验证--&gt;
&lt;dependency&gt;
        &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt;
        &lt;artifactId&gt;cas-server-support-jdbc&lt;/artifactId&gt;
        &lt;version&gt;${cas.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--使用mysql驱动--&gt;
&lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.21&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h6>7. 配置数据库相关,以下配置，如驱动，查询数据库等等需要根据不同的场景进行调整:</h6>
<ul>
<li>若密码无加密，调整passwordEncoder.type=NONE</li>
<li>若密码加密策略为SHA，调整passwordEncoder.encodingAlgorithm=SHA</li>
<li>
<p>若算法为自定义，实现org.springframework.security.crypto.password.PasswordEncoder接口，并且把类名配置在passwordEncoder.type</p>
<pre><code>#jdbc验证配置
#Query Database Authentication 数据库查询校验用户名开始
#查询账号密码sql，必须包含密码字段
cas.authn.jdbc.query[0].sql=select * from sys_user where username=?
#指定上面的sql查询字段名（必须）
cas.authn.jdbc.query[0].fieldPassword=password
#指定过期字段，1为过期，若过期需要修改密码
cas.authn.jdbc.query[0].fieldExpired=expired
#为不可用字段段，1为不可用，
cas.authn.jdbc.query[0].fieldDisabled=disabled
#数据库方言hibernate的知识
cas.authn.jdbc.query[0].dialect=org.hibernate.dialect.MySQLDialect
#数据库驱动
cas.authn.jdbc.query[0].driverClass=com.mysql.jdbc.Driver
#数据库连接
cas.authn.jdbc.query[0].url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&amp;characterEncoding=UTF-8
#数据库用户名
cas.authn.jdbc.query[0].user=root
#数据库密码
cas.authn.jdbc.query[0].password=root
#默认加密策略，通过encodingAlgorithm来指定算法，默认NONE不加密
cas.authn.jdbc.query[0].passwordEncoder.type=DEFAULT
cas.authn.jdbc.query[0].passwordEncoder.characterEncoding=UTF-8
cas.authn.jdbc.query[0].passwordEncoder.encodingAlgorithm=MD5
#Query Database Authentication 数据库查询校验用户名结束
#jdbc验证配置
</code></pre>

</li>
</ul>
<h6>8. 分别使用admin/admin, wolfcode/wolfcode, lanxw/666 登录效果如下：</h6>
<p><img src="./img/9.png" /></p>
<h6>9. 其他</h6>
<ul>
<li>
<p>我们已经把CAS Server端的验证变成使用JDBC的方式认证,而且在数据库中也已经对明文密码使用md5进行加密,但是只是用md5加密安全性不够高.所以一般我们会对密码使用md5+盐加密来增加密码管理的安全性.我们需要修改application.properties,在配置文件中指定盐值和加密次数:
对应的sys_user_encode的脚本也是从上面的github地址获取.</p>
<pre><code>#Encode Database Authentication 开始
#加密次数
cas.authn.jdbc.encode[0].numberOfIterations=2
#该列名的值可替代上面的值，但对密码加密时必须取该值进行处理(如果使用这个配置需要把上面的配置注释)
#cas.authn.jdbc.encode[0].numberOfIterationsFieldName=
# 盐值固定列
cas.authn.jdbc.encode[0].saltFieldName=username
#静态盐值(如果使用这个配置需要把上面的配置注释)
#cas.authn.jdbc.encode[0].staticSalt=.
cas.authn.jdbc.encode[0].sql=select * from sys_user_encode where username=?
#对处理盐值后的算法
cas.authn.jdbc.encode[0].algorithmName=MD5
cas.authn.jdbc.encode[0].passwordFieldName=password
cas.authn.jdbc.encode[0].expiredFieldName=expired
cas.authn.jdbc.encode[0].disabledFieldName=disabled
cas.authn.jdbc.encode[0].url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&amp;characterEncoding=UTF-8
cas.authn.jdbc.encode[0].dialect=org.hibernate.dialect.MySQLDialect
cas.authn.jdbc.encode[0].user=root
cas.authn.jdbc.encode[0].password=root
cas.authn.jdbc.encode[0].driverClass=com.mysql.jdbc.Driver
#Encode Database Authentication 结束
</code></pre>

</li>
</ul>
<h2>2. CAS整合 Spring Security(二)</h2>
<h3>1. 服务记录</h3>
<h4>1.1. 某一个 Client 需要接入 CAS Server 进行验证，则该 Client 必须提前在 CAS Server 上配置其信息。</h4>
<h6>1.1.1 首先新建<code>src/main/resources/services</code>文件夹，再创建client1-99.json文件，（这个配置可以参考官方给出的模版：overlays/org.apereo.cas.cas-server-webapp-tomcat-5.3.14/WEB-INF/classes/services/Apereo-10000002.json）</h6>
<pre><code>    {
      // @calss 指定注册服务类，这个是固定的org.apereo.cas.services.RegexRegisteredService。
      &quot;@class&quot;: &quot;org.apereo.cas.services.RegexRegisteredService&quot;, 
      // serviceId 则通过正则表达式用来匹配具体的请求。
      &quot;serviceId&quot;: &quot;^(https|http)://.*&quot;,
      // name 是接入的 client 的名称。
      &quot;name&quot;: &quot;client1&quot;,
      // id 是接入的 client 的 id。
      &quot;id&quot;: 99,
      // description 是接入的 client 的描述信息。
      &quot;description&quot;: &quot;应用1 的定义信息&quot;,
      // evaluationOrder 则指定了执行的优先级。
      &quot;evaluationOrder&quot;: 1
    }
</code></pre>

<h6>然后在<code>src/main/resources/application.properties</code>下配置</h6>
<pre><code>#指定配置 JSON 文件的位置。
cas.serviceRegistry.json.location=classpath:/services
#开启 JSON 识别。
cas.serviceRegistry.initFromJson=true
</code></pre>

<h4>1.2. JDK证书</h4>
<h6>1.2.1 首先使用命令到处<code>.cer</code>文件</h6>
<blockquote>
<p>keytool -export -trustcacerts -alias casserver -file ./cas.cer -keystore ./keystore</p>
</blockquote>
<h6>1.2.2 导入jdk,导入完成后重启CAS Server</h6>
<blockquote>
<p>keytool -import -v -trustcacerts -alias casserver -file ./cas.cer -storepass changeit -keystore &quot;%JAVA_HOME%/jre/lib/security/cacerts&quot;</p>
<p>keytool -import -v -trustcacerts -alias 文件名 -file &quot;文件完整路径&quot; -storepass changeit -keystore &quot;%JAVA_HOME%/jre/lib/security/cacerts&quot;</p>
</blockquote>
<pre><code>查看证书命令
keytool -list -keystore cacerts -alias 证书名
默认密码:changeit
删除证书
keytool -delete -alias casserver -keystore cacerts 
</code></pre>

<h6>1.2.3 修改 hosts</h6>
<pre><code>#CAS Server 的请求域名
127.0.0.1 cas.ksn.com
#CAS Client 的请求域名
127.0.0.1 client1.cas.ksn.com
</code></pre>

<h3>2. 开发 Client</h3>
<h1>Spring Secrity + OAuth2</h1>
<h2>授权码模式</h2>
<h3>1. 首先导入依赖</h3>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<h3>2. 配置security相关的</h3>
<pre><code>@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    // 配置密码
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // 简单配置下用户
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser(&quot;admin&quot;).password(passwordEncoder().encode(&quot;123&quot;)).roles(&quot;admin&quot;)
                .and()
                .withUser(&quot;user&quot;).password(passwordEncoder().encode(&quot;123&quot;)).roles(&quot;user&quot;);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().formLogin();
    }
}
</code></pre>

<h3>3. 配置授权服务</h3>
<pre><code>// 表示开启授权服务器自动化配置
@EnableAuthorizationServer
@Configuration
public class AuthorizationServer extends AuthorizationServerConfigurerAdapter {

    @Autowired
    ClientDetailsService clientDetailsService;


    /**
     * 配置token存放位置，可以是内存，redis也可以结合jwt一起使用
     * @return
     */
    @Bean
    TokenStore tokenStore() {
        return new InMemoryTokenStore();
    }
    /**
     * 用来配置token的一些基本信息，
     * @return
     */
    @Bean
    AuthorizationServerTokenServices authorizationServerTokenServices() {
        DefaultTokenServices services = new DefaultTokenServices();
        services.setClientDetailsService(clientDetailsService);
        // 是否支持刷新
        services.setSupportRefreshToken(true);
        // 存储位置
        services.setTokenStore(tokenStore());
        // 过期时间
        services.setAccessTokenValiditySeconds(60 * 60 *2);
        // 刷新令牌过期时间
        services.setRefreshTokenValiditySeconds(60 * 60 * 24 * 3);
        return services;
    }

    @Bean
    public AuthorizationCodeServices authorizationCodeServices() {
        // 表示授权码存在内存中
        return new InMemoryAuthorizationCodeServices();
    }

    /**
     * 用来配置令牌端点的安全约束，就是说谁能访问，谁不能访问
     * @param security
     * @throws Exception
     */
    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
                // 指一个 Token 校验的端点，这个端点我们可以设置成直接访问，后面当资源服务器收到token后，需要去校验token的合法性，就会走这个
        security.checkTokenAccess(&quot;permitAll&quot;)
                .allowFormAuthenticationForClients();
    }

    /**
     * 授权码模式需要校验用户和客户端，这里就是校验客户端，可以从数据库查，类似UserDetailsService
     * @param clients
     * @throws Exception
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient(&quot;ksn_client&quot;)
                .secret(new BCryptPasswordEncoder().encode(&quot;ksn_secret&quot;))
                .resourceIds(&quot;res1&quot;)
                .authorizedGrantTypes(&quot;authorization_code&quot;, &quot;refresh_token&quot;)
                .scopes(&quot;all&quot;)
                .redirectUris(&quot;http://www.baidu.com&quot;);


    }

    /**
     * 用来配置令牌的访问端点和令牌服务，authorizationCodeServices用来配置授权码的存储位置，这里是先存在内存中
     * authorizationServerTokenServices是用来配置token的存储位置，token是用来获取资源的，授权码是用来获取token的用一次就失效
     * @param endpoints
     * @throws Exception
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.authorizationCodeServices(authorizationCodeServices())
                .tokenServices(authorizationServerTokenServices());
    }
}
</code></pre>

<h3>4. 测试</h3>
<h6>首先访问链接一，这个地址会跳转到一个页面如图一,点击确认之后会跳转到配置的redirect_uri，这里的redirect_uri要和代码中配置的一致，跳转后这个地址后面会多一个code的属性，就是授权码，再用这个授权码访问链接二就能获取到token了，如图二</h6>
<pre><code>链接一：
http://localhost:8080/oauth/authorize?client_id=ksn_client&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.baidu.com

链接二：
localhost:8080/oauth/token?client_id=ksn_client&amp;grant_type=authorization_code&amp;redirect_uri=
http://www.baidu.com&amp;client_secret=ksn_secret&amp;code=h3pZrO
</code></pre>

<p><img src="./img/10.png" />
<img src="./img/11.png" /></p>
<h2>简单模式</h2>
<h4>1. 在上面的基础上，修改authorizedGrantTypes，加上implicit即可。然后访问链接一，登录后选择通过就跳转到redirect_uri了。跳转后的链接如链接二，后面的access_token就是token。</h4>
<pre><code>链接一：
http://localhost:8080/oauth/authorize?client_id=ksn_client&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.baidu.com

链接二：
https://www.baidu.com/#access_token=b9da9cd7-4498-4859-8b41-ecf497050bc9&amp;token_type=bearer&amp;expires_in=7199
</code></pre>

<p><img src="./img/12.png" /></p>
<h2>密码模式</h2>
<h4>1. 首先在SecurityConfig中实现authenticationManager方法并交给容器管理</h4>
<pre><code>@Bean
@Override
protected AuthenticationManager authenticationManager() throws Exception {
    return super.authenticationManager();
}
</code></pre>

<h4>2. 修改授权服务类的authorizedGrantTypes，加上password。然后修改configure方法</h4>
<pre><code>@Override
public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
    // 授权码模式，简单模式
    // endpoints.authorizationCodeServices(authorizationCodeServices())
    //          .tokenServices(authorizationServerTokenServices());

    // 密码模式
    endpoints.authenticationManager(authenticationManager)
            .tokenServices(authorizationServerTokenServices());
}
</code></pre>

<h4>3. 测试，访问如下链接即可返回token</h4>
<pre><code>http://localhost:8080/oauth/token
?grant_type=password
&amp;client_id=ksn_client
&amp;client_secret=ksn_secret
&amp;username=admin
&amp;password=123
</code></pre>

<h2>客户端模式</h2>
<h4>1. 在之前的基础上修改authorizedGrantTypes，加上client_credentials,然后访问如下链接即可。</h4>
<pre><code>http://localhost:8080/oauth/token?grant_type=client_credentials&amp;client_id=ksn_client&amp;client_secret=ksn_secret
</code></pre>

<p><img src="./img/13.png" /></p>
<h2>刷新token</h2>
<p><img src="./img/14.png" /></p>
<h4>各个接口</h4>
<p><img src="./img/15.png" /></p>
<h2>把token存入redis，从数据库读取token信息</h2>
<h3>1. 把token存入redis</h3>
<h6>1.1 首先导入redis依赖，配置redis</h6>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

spring.redis.host=127.0.0.1
spring.redis.port=6379
</code></pre>

<h3>1.2 修改TokenStore即可</h3>
<pre><code>@Autowired
RedisConnectionFactory redisConnectionFactory;
@Bean
TokenStore tokenStore() {
    return new RedisTokenStore(redisConnectionFactory);
}
</code></pre>

<p><img src="./img/16.png" /></p>
<h3>2. 从数据库读取token信息</h3>
<h6>2.1 通过查看ClientDetailsService，它有两个实现类，从数据库中读数据是使用了JdbcClientDetailsService这个类，又通过查看这个类推断出数据库的表结构并且导入数据库依赖，配置数据源</h6>
<p><img src="./img/17.png" /></p>
<h6>2.2 修改配置类即可，如果想要自定义规则就可以实现ClientDetailsService，然后实现其中的方法即可。</h6>
<pre><code>@Autowired
DataSource dataSource;

@Bean
ClientDetailsService clientDetailsService() {
    return new JdbcClientDetailsService(dataSource);
}

@Override
public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
    clients.withClientDetails(clientDetailsService());
}

@Bean
AuthorizationServerTokenServices tokenServices() {
    DefaultTokenServices services = new DefaultTokenServices();
    services.setClientDetailsService(clientDetailsService());
    services.setSupportRefreshToken(true);
    services.setTokenStore(tokenStore);
    return services;
}
</code></pre>

<h2>返回自定义token</h2>
<h3>新建token配置类</h3>
<pre><code>@Configuration
public class AgileJwtTokenConfig {

    @Autowired
    RedisConnectionFactory redisConnectionFactory;

    // 配置生成方式使用RSA非对称加密算法，token最大长度512
    @Bean
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        // 非对称加密
        converter.setKeyPair(SecureUtil.generateKeyPair(&quot;RSA&quot;, 512));
        return converter;
    }

    @Bean
    public TokenEnhancer tokenEnhancer() {
        return (accessToken, authentication) -&gt; {
            // 自定义token携带的信息
            Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());
            map.put(&quot;GlobalConstants.PLATFORM_NAME_KEY&quot;, &quot;GlobalConstants.PLATFORM_NAME_EN&quot;);

            ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(map);
            return accessToken;
        };
    }

    /**
     * 配置token存放位置，可以是内存，redis也可以结合jwt一起使用
     * @return
     */
    @Bean
    TokenStore tokenStore() {
        return new RedisTokenStore(redisConnectionFactory);
    }
}
</code></pre>

<h3>修改oauth2配置类</h3>
<pre><code>@Bean
AuthorizationServerTokenServices authorizationServerTokenServices() {
    TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();
    // 告诉spring security把自定义token生产方式加入到TokenEnhancerChain中
    tokenEnhancerChain.setTokenEnhancers(CollUtil.newArrayList(jwtAccessTokenConverter, tokenEnhancer));
    DefaultTokenServices services = new DefaultTokenServices();
    services.setClientDetailsService(clientDetailsService());
    // 是否支持刷新   
    services.setSupportRefreshToken(true);
    // 存储位置
    services.setTokenStore(tokenStore);
    // 刷新 token时把refresh_token也刷新
    services.setReuseRefreshToken(true);
    // 将自定义的token生产方式加到TokenEnhancer中
    services.setTokenEnhancer(tokenEnhancerChain);
    return services;
}

@Override
public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
    // 密码模式
    endpoints.authenticationManager(authenticationManager)
            .tokenServices(authorizationServerTokenServices())
            .accessTokenConverter(jwtAccessTokenConverter)
            .tokenStore(tokenStore)
            .allowedTokenEndpointRequestMethods(HttpMethod.OPTIONS, HttpMethod.GET, HttpMethod.POST);
}
</code></pre>

<h3>给别的服务加上权限认证，导入security， oauth2， redis的依赖，然后在添加一个配置类</h3>
<pre><code>@Configuration
// 开启资源服务的自动化配置
@EnableResourceServer
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {
    @Autowired
    RedisConnectionFactory redisConnectionFactory;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public TokenStore redisTokenStore() {
        return new RedisTokenStore(redisConnectionFactory);
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) {
        resources.resourceId(&quot;res1&quot;).tokenStore(redisTokenStore());
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated();
    }
}
</code></pre>

<h2>接入Github第三方登录</h2>
<h3>github新建一个应用</h3>
<p><img src="./img/18.png" /></p>
<h3>新建一个boot工程导入web，thymeleaf依赖，新建index.html，注意a标签的地址是获取授权码的.client_id是创建应用时的id，state随意，是用来防篡改的。</h3>
<blockquote>
<p>https://github.com/login/oauth/authorize?client_id=xxxxxx&amp;state=ksn</p>
</blockquote>
<pre><code>&lt;body&gt;
&lt;p&gt;hello 欢迎来到小站！&lt;/p&gt;
&lt;div&gt;
    社交账号登录：&lt;a href=&quot;https://github.com/login/oauth/authorize?client_id=xxxxxx&amp;state=javaboy&quot;&gt;
        &lt;svg t=&quot;1587352912571&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;
             p-id=&quot;2196&quot; width=&quot;32&quot; height=&quot;32&quot;&gt;
            &lt;path d=&quot;M512 42.666667A464.64 464.64 0 0 0 42.666667 502.186667 460.373333 460.373333 0 0 0 363.52 938.666667c23.466667 4.266667 32-9.813333 32-22.186667v-78.08c-130.56 27.733333-158.293333-61.44-158.293333-61.44a122.026667 122.026667 0 0 0-52.053334-67.413333c-42.666667-28.16 3.413333-27.733333 3.413334-27.733334a98.56 98.56 0 0 1 71.68 47.36 101.12 101.12 0 0 0 136.533333 37.973334 99.413333 99.413333 0 0 1 29.866667-61.44c-104.106667-11.52-213.333333-50.773333-213.333334-226.986667a177.066667 177.066667 0 0 1 47.36-124.16 161.28 161.28 0 0 1 4.693334-121.173333s39.68-12.373333 128 46.933333a455.68 455.68 0 0 1 234.666666 0c89.6-59.306667 128-46.933333 128-46.933333a161.28 161.28 0 0 1 4.693334 121.173333A177.066667 177.066667 0 0 1 810.666667 477.866667c0 176.64-110.08 215.466667-213.333334 226.986666a106.666667 106.666667 0 0 1 32 85.333334v125.866666c0 14.933333 8.533333 26.88 32 22.186667A460.8 460.8 0 0 0 981.333333 502.186667 464.64 464.64 0 0 0 512 42.666667&quot;
                  fill=&quot;#2c2c2c&quot; p-id=&quot;2197&quot;&gt;&lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
&lt;/div&gt;
&lt;div&gt;国际站：&lt;a href=&quot;http://www.javaboy.org&quot;&gt;javaboy.org&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;国内站：&lt;a href=&quot;http://www.itboyhub.com&quot;&gt;itboyhub.com&lt;/a&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>

<h3>然后添加一个接口/authorization/code</h3>
<pre><code>@ResponseBody
@GetMapping(&quot;/code&quot;)
public String code(@RequestParam(&quot;code&quot;) String code, @RequestParam(&quot;state&quot;) String state) {
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;client_id&quot;, &quot;cd2857419595e06f3721&quot;);// 应用中有
    map.put(&quot;client_secret&quot;, &quot;c07f67405d1563c4d785dc599e9091c1e333e6c6&quot;); // 应用中有
    map.put(&quot;state&quot;, &quot;ksn&quot;);// 跟请求的一致
    map.put(&quot;code&quot;, code); // 通过调用授权码接口会跟在url后面
    map.put(&quot;redirect_uri&quot;, &quot;http://127.0.0.1:8003/authorize/code&quot;);  // 这里要跟配置的回调地址一模一样
    String s = JSONUtil.toJsonStr(map);
    // 调用获取token的接口
    HttpResponse execute = HttpUtil.createPost(&quot;https://github.com/login/oauth/access_token&quot;).body(s).execute();
    System.out.println(execute.body());
    //拿到token放在请求用户信息的地址的请求头中
    String token = &quot;token &quot; + execute.body().substring(execute.body().indexOf(&quot;=&quot;) + 1, execute.body().indexOf(&quot;&amp;&quot;));
    HashMap&lt;String, String&gt; stringStringHashMap = new HashMap&lt;&gt;();
    stringStringHashMap.put(&quot;Authorization&quot;, token);
    HttpResponse execute1 = HttpUtil.createGet(&quot;https://api.github.com/user&quot;).addHeaders(stringStringHashMap).execute();
    // 获取到用户信息
    return execute1.body();
}
</code></pre>

<h2>SpringSecurity的异常处理流程</h2>
<h6>SpringSecurity是由一串过滤链组成的，典型的责任链模式。处理异常的过滤器在倒数第二个，叫ExceptionTranslationFilter。它继承了GenericFilterBean，所以查看它的doFilter方法会发现只有一句<code>chain.doFilter(request, response);</code>。而最后一个过滤器是FilterSecurityInterceptor。FilterSecurityInterceptor专门处理授权问题，然后抛出异常被ExceptionTranslationFilter捕捉到，调用catch块中的<code>throwableAnalyzer.getFirstThrowableOfType</code>，判断异常类型是认证异常还是授权异常，如果都不是就走ServletException 异常类型的处理逻辑，然后调用<code>handleSpringSecurityException(request, response, chain, ase);</code>。</h6>
<p><img src="./img/19.png" /></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
