<!DOCTYPE html>
<html>
<head>
<title>quartz笔记</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<base href=''/>
</head>
<body>
<h1>Quartz笔记</h1>
<h2><a href="https://www.w3cschool.cn/quartz_doc/quartz_doc-2put2clm.html">中文文档</a></h2>
<h2>quartz调度核心元素</h2>
<h4>Scheduler： 任务调度器，是实际执行任务调度的控制器，在spring中通过SchedulerFactoryBean封装起来</h4>
<h4>Trigger: 触发器，用于定义调度的时间规则。有SimpleTrigegr，CronTrigger，主要用第二种</h4>
<h4>Calendar： 它是一些日历特点时间点的集合，一个Trigger可以有多个Calender，以便排除或包含某些时间点</h4>
<h4>Job： 是一个接口，只有一个方法void execute(JobExecutionContext context)，实现这个接口定义运行任务</h4>
<h4>JobDetail：用来描述Job实现类和其他静态信息，如名字，关联监听器等。在spring中有JobDetailFactoryBean和 MethodInvokingJobDetailFactoryBean两种实现，如果任务调度中要执行某个类的某个方法就可以通过MethodInvokingJobDetailFactoryBean来调用</h4>
<h4>Quartz体系结构</h4>
<h4>监听器： JobListener,TriggerListener,SchedulerListener,对JobDetail,Trigger, Scheduler进行监听</h4>
<p><img src="./img/1.png" /></p>
<h2>Hello Quartz例子</h2>
<p><details style='background-color:#f9f2f4'>
<summary><font color='#c7254e' size='3px'> view code</font></summary></p>
<pre><code>public static void main(String[] args) throws SchedulerException {
    Scheduler defaultScheduler = StdSchedulerFactory.getDefaultScheduler();
    defaultScheduler.getContext().put(&quot;skey&quot;, &quot;sKey&quot;);

    SimpleTrigger trigger = TriggerBuilder.newTrigger()
            .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
            .usingJobData(&quot;t1&quot;, &quot;trigger1&quot;)
            .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(3).repeatForever()).build();
    trigger.getJobDataMap().put(&quot;t2&quot;, &quot;trigger2&quot;);

    JobDetail job = JobBuilder.newJob(HelloJob.class)
            .withIdentity(&quot;job1&quot;, &quot;group1&quot;)
            .usingJobData(&quot;j1&quot;, &quot;job1&quot;)
            .usingJobData(&quot;j2&quot;, &quot;job2&quot;).build();

    defaultScheduler.scheduleJob(job, trigger);
    defaultScheduler.start();
}

@Slf4j
public class HelloJob implements Job {

    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        log.info(&quot;j1:{}&quot;,context.getJobDetail().getJobDataMap().get(&quot;j1&quot;));
        log.info(&quot;j2:{}&quot;,context.getJobDetail().getJobDataMap().get(&quot;j2&quot;));

        log.info(&quot;t1:{}&quot;,context.getTrigger().getJobDataMap().get(&quot;t1&quot;));
        log.info(&quot;t2:{}&quot;,context.getTrigger().getJobDataMap().get(&quot;t2&quot;));

        Object skey = null;
        try {
            skey = context.getScheduler().getContext().get(&quot;skey&quot;);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }

        log.info(&quot;skey: {}&quot;, skey);
        log.info(LocalDateTime.now().toString());
    }
}
</code></pre>

<p></details></p>
<h2>Job &amp; JobDetail</h2>
<h4>实现自动注入getMergedJobDataMap里的属性</h4>
<p><details style='background-color:#f9f2f4'>
<summary><font color='#c7254e' size='3px'> view code</font></summary></p>
<pre><code>@Slf4j
public class HelloJob implements Job {

    // 先定义好属性名
    String t1;
    String t2;
    String j1;
    String j2;

    // 无参构造不能少，不然就不能构造job
    public HelloJob() {}

    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        log.info(&quot;j1:{}&quot;,context.getJobDetail().getJobDataMap().get(&quot;j1&quot;));
        log.info(&quot;j2:{}&quot;,context.getJobDetail().getJobDataMap().get(&quot;j2&quot;));

        log.info(&quot;t1:{}&quot;,context.getTrigger().getJobDataMap().get(&quot;t1&quot;));
        log.info(&quot;t2:{}&quot;,context.getTrigger().getJobDataMap().get(&quot;t2&quot;));

        log.info(&quot;合并后的map:{}&quot;,context.getMergedJobDataMap());

        log.info(&quot;-------------------------------------------------------&quot;);
        log.info(&quot;jobKey:{}&quot;,context.getJobDetail().getKey());
        log.info(&quot;注入的值:t1: {},t2: {},j1: {},j2: {},&quot;,t1, t2, j1, j2);
        log.info(&quot;-------------------------------------------------------&quot;);

        Object skey = null;
        try {
            skey = context.getScheduler().getContext().get(&quot;skey&quot;);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }

        log.info(&quot;skey: {}&quot;, skey);
        log.info(LocalDateTime.now().toString());
    }

    // 设置属性的set方法
    public void setT1(String t1) {
        this.t1 = t1;
    }

    public void setT2(String t2) {
        this.t2 = t2;
    }

    public void setJ1(String j1) {
        this.j1 = j1;
    }

    public void setJ2(String j2) {
        this.j2 = j2;
    }
}
</code></pre>

<p></details></p>
<h2>Trigger</h2>
<h4>Trigger的公共属性</h4>
<h6>jobKey： 当trigger触发时被执行的job身份</h6>
<h6>startTime： 设置trigger第一次触发的时间，是Date类型的。有些类型的trigger，会在设置的startTime时立即触发，有些类型的trigger，表示其触发是在startTime之后开始生效。比如，现在是1月份，你设置了一个trigger–“在每个月的第5天执行”，然后你将startTime属性设置为4月1号，则该trigger第一次触发会是在几个月以后了(即4月5号)。</h6>
<h6>endTime： 表示trigger的失效时间。比如，”每月第5天执行”的trigger，如果其endTime是7月1号，则其最后一次执行时间是6月5号。</h6>
<h6>priority： trigger的优先级。当有多个trigger，但是线程数量很少时，就会有多个trigger同时执行。这时候就可以设置优先级，默认值是5。只有同时执行的trigger才会比较优先级</h6>
<h6>misfire： 错过触发，如果控制器关闭或者线程池没有空闲线程，此时持久性trigger就会错过触发时间就是错过触发。不同类型的trigger的misfire机制不同，默认使用的都是“智能机制(smart policy)”，即根据trigger的类型和配置动态调整行为。当控制器重启时查询所有错过触发的trigger再更新trigger的信息</h6>
<h6>calendar： 日历示例。Calendar用于从trigger的调度计划中排除时间段，</h6>
<p><img src="./img/2.png" /></p>
<h3>Simple Trigger</h3>
<h5>可以在具体的时间点执行一次或者在具体的时间点执行，并以指定间隔重复执行若干次。包括开始时间，结束时间，重复次数，间隔时间</h5>
<h6>指定时间开始触发，不重复:</h6>
<pre><code>LocalDateTime of = LocalDateTime.of(2021, 01, 18, 15, 33, 0);
Date from = Date.from(of.atZone(ZoneId.systemDefault()).toInstant());

SimpleTrigger trigger = (SimpleTrigger) TriggerBuilder.newTrigger()
        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
        .startAt(from) // 设置开始时间
        .forJob(&quot;job1&quot;, &quot;group1&quot;)
        .build();
</code></pre>

<h6>指定时间触发，每隔10秒执行一次，重复10次：</h6>
<pre><code>SimpleTrigger trigger = TriggerBuilder.newTrigger()
        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
        // 设置开始时间，15后开始执行
        .startAt(futureDate(15, DateBuilder.IntervalUnit.SECOND))
        // 五秒执行一次，重复8次
        .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(5).withRepeatCount(8))
        .forJob(&quot;job1&quot;, &quot;group1&quot;)
        .build();
</code></pre>

<h6>立即触发，每个5s执行一次，直到15:58：</h6>
<pre><code>SimpleTrigger trigger = TriggerBuilder.newTrigger()
        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
        .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(5).repeatForever())
        .endAt(dateOf(15, 58, 0))
        .build();
</code></pre>

<h6>建立一个触发器，将在下一个小时的整点触发，然后每2小时重复一次：</h6>
<pre><code>SimpleTrigger trigger = TriggerBuilder.newTrigger()
        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
        .startAt(evenMinuteDate(null))
        .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(5).repeatForever())
        .build();
</code></pre>

<h4>SimpleTrigger Misfire策略</h4>
<h5>SimpleTrigger的Misfire策略常量：</h5>
<pre><code>MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY
MISFIRE_INSTRUCTION_FIRE_NOW
MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT
MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT
MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT
MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT

// 设置trigger的错过触发策略
SimpleTrigger trigger = TriggerBuilder.newTrigger()
            .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
            .withSchedule(SimpleScheduleBuilder.simpleSchedule()
                    .withIntervalInSeconds(5)
                    .repeatForever()
                    .withMisfireHandlingInstructionNextWithExistingCount())
            .build();
</code></pre>

<h3>CronTrigger</h3>
<h5>建立一个触发器，每隔一分钟，每天上午8点至下午5点之间：</h5>
<pre><code>CronTrigger trigger = TriggerBuilder.newTrigger()
        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
        .withSchedule(CronScheduleBuilder.cronSchedule(&quot;*/3 * 8-17 * * ?&quot;))
        .build();
</code></pre>

<h5>建立一个触发器，将在16:57每天发生：</h5>
<pre><code>CronTrigger trigger = TriggerBuilder.newTrigger()
        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
        .withSchedule(dailyAtHourAndMinute(16, 57))
        .forJob(&quot;job1&quot;, &quot;group1&quot;)
        .build();
</code></pre>

<h5>将在每周一的17:08触发：</h5>
<pre><code>CronTrigger trigger = TriggerBuilder.newTrigger()
        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
        .withSchedule(weeklyOnDayAndHourAndMinute(DateBuilder.MONDAY, 17, 8))
        .forJob(&quot;job1&quot;, &quot;group1&quot;)
        .build();
</code></pre>

<h4>CronTrigger Misfire说明</h4>
<h6>CronTrigger的Misfire指令常数</h6>
<pre><code>MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY
MISFIRE_INSTRUCTION_DO_NOTHING
MISFIRE_INSTRUCTION_FIRE_NOW

CronTrigger trigger = TriggerBuilder.newTrigger()
    .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
    .withSchedule(weeklyOnDayAndHourAndMinute(DateBuilder.MONDAY, 17, 8)
    .withMisfireHandlingInstructionFireAndProceed()) // 配置错过触发
    .forJob(&quot;job1&quot;, &quot;group1&quot;)
    .build();
</code></pre>

<h2>TriggerListeners，JobListeners和SchedulerListeners</h2>
<h4>添加jobListener(TriggerListener差不多)</h4>
<pre><code>scheduler.getListenerManager().addJobListener(myJobListener, jobKeyEquals(jobKey(&quot;myJobName&quot;, &quot;myJobGroup&quot;)));
</code></pre>

<h4>添加对特定组的所有job感兴趣的JobListener</h4>
<pre><code>scheduler.getListenerManager().addJobListener(myJobListener, jobGroupEquals(&quot;myJobGroup&quot;));
</code></pre>

<h4>添加对两个特定组的所有job感兴趣的JobListener</h4>
<pre><code>scheduler.getListenerManager().addJobListener(myJobListener, or(jobGroupEquals(&quot;myJobGroup&quot;), jobGroupEquals(&quot;yourGroup&quot;)));
</code></pre>

<h4>添加对所有job感兴趣的JobListener</h4>
<pre><code>scheduler.getListenerManager().addJobListener(myJobListener, allJobs());
</code></pre>

<h4>添加SchedulerListener</h4>
<pre><code>scheduler.getListenerManager().addSchedulerListener(mySchedListener);
</code></pre>

<h4>删除SchedulerListener</h4>
<pre><code>scheduler.getListenerManager().removeSchedulerListener(mySchedListener);
</code></pre>

<h2>Job Stores</h2>
<h3>RAMJobStore</h3>
<h5>存在内存中，速度很快，是默认选项，缺点是当程序崩了数据都会消失，具体的配置文件在 org/quartz/.quartz.properties中有一条如下：</h5>
<pre><code>org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore
</code></pre>

<h3>JDBC JobStore</h3>
<h5>它通过JDBC将其所有数据保存在数据库中。首先得找到创建表的sql脚本，然后配置使用JDBC JobStore中的JobStoreTX</h5>
<pre><code>#配置Quartz以使用JobStoreTx
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX
# 配置JDBCJobStore以使用DriverDelegate,DriverDelegate负责执行特定数据库可能需要的任何JDBC工作。常用StdJDBCDelegate
org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate
# 使用表前缀配置JDBCJobStore   
org.quartz.jobStore.tablePrefix = QRTZ_
#使用要使用的DataSource的名称配置JDBCJobStore
org.quartz.jobStore.dataSource = myDS
#线程管理
#线程池实现
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
#线程池数量
org.quartz.threadPool.threadCount = 50
#线程优先级
org.quartz.threadPool.threadPriority = 5
org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread = true
</code></pre>

<h2>Quartz配置参考</h2>
<h4>默认情况下会从quartz.properties里面加在配置信息，如果加载失败就从org/quartz包里加载默认的。如果想使用除了 这些默认的可以配置org.quartz.properties属性指向所需的文件</h4>
<p><img src="./img/3.png" /></p>
<h3>主配置调度器设置</h3>
<pre><code>// 指定任务名称
org.quartz.scheduler.instanceName

// 指定任务id必须唯一可以设置成AUTO表示自动生成，或者SYS_PROP，从系统获取
org.quartz.scheduler.instanceId
</code></pre>

<h3>Quartz配置ThreadPool设置</h3>
<pre><code>// 是要使用的ThreadPool实现的名称，一般用这个org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.class

// 配置可用于并发执行的线程数
org.quartz.threadPool.threadCount

// 线程优先级，默认为5
org.quartz.threadPool.threadPriority

// 设置是否是守护线程，默认为false
org.quartz.threadPool.makeThreadsDaemons

// 在自定义线程池
org.quartz.threadPool.class = com.mycompany.goo.FooThreadPool
org.quartz.threadPool.somePropOfFooThreadPool = someValue
</code></pre>

<h3>Quartz配置Global Listeners</h3>
<h5>通过配置文件配置Listener包括给一个全限定类名，然后指定类的属性，这个类必须要有无参构造且属性被反射设置只支持基本类型</h5>
<h4>配置全局TriggerListener</h4>
<pre><code>org.quartz.triggerListener.NAME.class = com.foo.MyListenerClass
org.quartz.triggerListener.NAME.propName = propValue
org.quartz.triggerListener.NAME.prop2Name = prop2Value
</code></pre>

<h4>配置全局JobListener</h4>
<pre><code>org.quartz.jobListener.NAME.class = com.foo.MyListenerClass
org.quartz.jobListener.NAME.propName = propValue
org.quartz.jobListener.NAME.prop2Name = prop2Value
</code></pre>

<h3>Quartz插件配置</h3>
<pre><code>org.quartz.plugin.NAME.class = com.foo.MyPluginClass
org.quartz.plugin.NAME.propName = propValue
org.quartz.plugin.NAME.prop2Name = prop2Value
</code></pre>

<h4>日志记录Triggers历史插件的示例配置</h4>
<pre><code>org.quartz.plugin.triggHistory.class = \
  org.quartz.plugins.history.LoggingTriggerHistoryPlugin
org.quartz.plugin.triggHistory.triggerFiredMessage = \
  Trigger \{1\}.\{0\} fired job \{6\}.\{5\} at: \{4, date, HH:mm:ss MM/dd/yyyy}
org.quartz.plugin.triggHistory.triggerCompleteMessage = \
  Trigger \{1\}.\{0\} completed firing job \{6\}.\{5\} at \{4, date, HH:mm:ss MM/dd/yyyy\}.
</code></pre>

<h3>Quartz配置RAMJobStore</h3>
<h5>RAMJobStore用于存储内存中的调度信息(job，trigger，calendar)，但是是存在内存中，当进程终止所有信息都会丢失。</h5>
<pre><code>org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore

// 默认值为60s，在被认为“misfired”之前，调度程序将“tolerate”一个Triggers将其下一个启动时间通过的毫秒数
org.quartz.jobStore.misfireThreshold
</code></pre>

<h3>Quartz配置JDBC-JobStoreTX或JobStoreCMT</h3>
<pre><code>// 通过这个属性来设置JobStoreTX
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreCMT

// 代表不同数据库的方言，一般配置这个，用于完全符合JDBC的驱动程序
org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate

// 配置表前缀，
org.quartz.jobStore.tablePrefix

// 设置quartz是否是集群
org.quartz.jobStore.isClustered

/** 
* 必须是在“LOCKS”表中选择一行并在该行上放置一个锁的SQL字符串。如果未设置，
* 默认值为“SELECT * FROM {0} LOCKS WHERE SCHED_NAME = {1} AND LOCK_NAME =？FOR UPDATE“，
* 适用于大多数数据库。在运行时使用上面配置的TABLE_PREFIX替换“{0}”。“{1}”被替换为调度程序的名称。
** /
org.quartz.jobStore.selectWithLockSQL
</code></pre>

<h3>使用JDBC-JobStore配置群集</h3>
<h4>集群配置示例</h4>
<pre><code>#============================================================================
# Configure Main Scheduler Properties  
#============================================================================

org.quartz.scheduler.instanceName = MyClusteredScheduler
org.quartz.scheduler.instanceId = AUTO

#============================================================================
# Configure ThreadPool  
#============================================================================

org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 25
org.quartz.threadPool.threadPriority = 5

#============================================================================
# Configure JobStore  
#============================================================================

org.quartz.jobStore.misfireThreshold = 60000

org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.oracle.OracleDelegate
org.quartz.jobStore.useProperties = false
org.quartz.jobStore.dataSource = myDS
org.quartz.jobStore.tablePrefix = QRTZ_

org.quartz.jobStore.isClustered = true
org.quartz.jobStore.clusterCheckinInterval = 20000

#============================================================================
# Configure Datasources  
#============================================================================

org.quartz.dataSource.myDS.driver = oracle.jdbc.driver.OracleDriver
org.quartz.dataSource.myDS.URL = jdbc:oracle:thin:@polarbear:1521:dev
org.quartz.dataSource.myDS.user = quartz
org.quartz.dataSource.myDS.password = quartz
org.quartz.dataSource.myDS.maxConnections = 5
org.quartz.dataSource.myDS.validationQuery=select 0 from dual
</code></pre>

<h2>SpringBoot2.0整合Quartz并持久化</h2>
<h4>启动类上添加@EnableScheduling注解，然后实现job类</h4>
<pre><code>public class SampleJob implements Job {
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        // 业务逻辑
        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));
    }
}
</code></pre>

<h4>在配置文件中配置持久化</h4>
<pre><code>spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://192.168.0.189:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;serverTimezone=PRC&amp;useSSL=false&amp;autoReconnect=true
      username: root
      password: root
  quartz:
    job-store-type: jdbc
    jdbc:
      initialize-schema: embedded
    properties:
      org:
        quartz:
          scheduler:
            instanceName: MyScheduler
            instanceId: AUTO
          jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
            tablePrefix: qrtz_
            isClustered: true
            clusterCheckinInterval: 10000
            useProperties: false
          threadPool:
            class: org.quartz.simpl.SimpleThreadPool
            threadCount: 10
            threadPriority: 5
            threadsInheritContextClassLoaderOfInitializingThread: true
</code></pre>

<h4>一个任务配置多个触发器</h4>
<pre><code>@Service
public class QuartzService {

    public void test() throws SchedulerException {
        Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();

        JobDetail jobDetail = JobBuilder.newJob(QuartzJob.class)
                .withIdentity(&quot;job1&quot;, &quot;group1&quot;)
                .usingJobData(&quot;jobData1&quot;, &quot;asdf&quot;)
                .storeDurably()
                .build();

        CronTrigger trigger = TriggerBuilder.newTrigger()
                .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
                .forJob(&quot;job1&quot;, &quot;group1&quot;)
                .usingJobData(&quot;t1&quot;, &quot;qwer&quot;)
                .startNow()
                .withSchedule(CronScheduleBuilder.cronSchedule(&quot;*/1 * * * * ?&quot;))
                .build();

        SimpleTrigger trigger1 = TriggerBuilder.newTrigger()
                .withIdentity(&quot;trigger2&quot;, &quot;group1&quot;)
                .forJob(&quot;job1&quot;, &quot;group1&quot;)
                .usingJobData(&quot;t2&quot;, &quot;qwer2&quot;)
                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(3).repeatForever())
                .build();

        scheduler.scheduleJob(jobDetail, trigger);

        scheduler.scheduleJob(trigger1);
        scheduler.start();
    }
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
